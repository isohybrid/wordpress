<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-isohybrid</title><link>http://www.cnblogs.com/isohybrid/</link><description>业精于勤，荒于嬉；行成于思，毁于随</description><language>zh-cn</language><lastBuildDate>Sun, 08 Sep 2013 16:00:49 GMT</lastBuildDate><pubDate>Sun, 08 Sep 2013 16:00:49 GMT</pubDate><ttl>60</ttl><item><title>Stop WordPress Asking For FTP details When You Install / Upgrade Plugins</title><link>http://www.cnblogs.com/isohybrid/archive/2013/09/08/wordpress.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 08 Sep 2013 15:30:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/09/08/wordpress.html</guid><description><![CDATA[<p>When you want to install or upgrade a plugin, WordPress will most probably display this message:</p>
<blockquote>
<p>Connection Information</p>
<p>To perform the requested action, WordPress needs to access your web server. Please enter your FTP credentials to proceed. If you do not remember your credentials, you should contact your web host.</p>
</blockquote>
<p>If you are on shared hosting you might not have this problem but if you are on a VPS or Dedicated server you will most probably get asked to supply FTP credentials every time you want to install or upgrade plugin or even WordPress. This can become an annoyance if you install plugins a lot so this is one of the first things I always fix when I install new WordPress site.</p>
<p>Here is how to solve it: open your&nbsp;<code>wp-config.php</code>&nbsp;file (by default it can be found in your root WordPress directory) with text editor and simply add your ftp login information near the bottom of the wp-config.php file (just above the /** Sets up WordPress vars and included files. */ comment for example):</p>
<div>
<div id="highlighter_133369" class="syntaxhighlighter  php">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="php comments">//*add your FTP credentials*</code></div>
<div class="line number2 index1 alt1"><code class="php plain">define(</code><code class="php string">'FTP_HOST'</code><code class="php plain">, </code><code class="php string">'host_IP_or_FTP_url'</code><code class="php plain">);</code></div>
<div class="line number3 index2 alt2"><code class="php plain">define(</code><code class="php string">'FTP_USER'</code><code class="php plain">, </code><code class="php string">'FTP_username'</code><code class="php plain">);</code></div>
<div class="line number4 index3 alt1"><code class="php plain">define(</code><code class="php string">'FTP_PASS'</code><code class="php plain">, </code><code class="php string">'FTP_password'</code><code class="php plain">);</code></div>
<div class="line number5 index4 alt2"><code class="php comments">//*If you like and can use a SSL connection set this to true*</code></div>
<div class="line number6 index5 alt1"><code class="php plain">define(</code><code class="php string">'FTP_SSL'</code><code class="php plain">, true);</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>After you do this your won&rsquo;t be asked for FTP credentials anymore. There are other solutions like settings permission with chown via shell or installing suPHP on your server but this one seems to be the easiest.</p>
<p>If the above fails for whatever reason you can comment the above code and try adding the following code in the&nbsp;<code>wp-config.php</code>&nbsp;file,somewhere at the top:</p>
<div>
<div id="highlighter_506103" class="syntaxhighlighter  php">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2"><span style="color: #ff0000;">1</span></div>
<div class="line number2 index1 alt1"><span style="color: #ff0000;">2</span></div>
<div class="line number3 index2 alt2"><span style="color: #ff0000;">3</span></div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><span style="color: #ff0000;"><code class="php plain">define( </code><code class="php string">'FS_METHOD'</code><code class="php plain">, </code><code class="php string">'direct'</code> <code class="php plain">);</code></span></div>
<div class="line number2 index1 alt1"><span style="color: #ff0000;"><code class="php plain">define( </code><code class="php string">'FS_CHMOD_DIR'</code><code class="php plain">, 0777 );</code></span></div>
<div class="line number3 index2 alt2"><span style="color: #ff0000;"><code class="php plain">define( </code><code class="php string">'FS_CHMOD_FILE'</code><code class="php plain">, 0777 );</code></span></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>This forces files to be writable by the server. You should only use this if adding FTP credentials method fails.</p>
<p>&nbsp;</p>
<p>copy from:&nbsp;<a href="http://www.elcoderino.com/stop-wordpress-asking-for-ftp-details-when-you-installupgrade-plugins/">http://www.elcoderino.com/stop-wordpress-asking-for-ftp-details-when-you-installupgrade-plugins/</a></p>
<p>&nbsp;</p>
<p>The red line work for me,although I have changed the wordpress dir into 777.</p>]]></description></item><item><title>blog migration</title><link>http://www.cnblogs.com/isohybrid/archive/2013/09/08/migration.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sat, 07 Sep 2013 16:57:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/09/08/migration.html</guid><description><![CDATA[<p><strong><span>第一步</span></strong></p>
<p>CSDN是没有导出功能的，所以我先在博客园注册了一个账号，然后把自己在CSDN上面的博客全部转到了博客园上面。</p>
<p>&nbsp;</p>
<p><strong><span>第二步</span></strong></p>
<p>在博客园上自己的博客有一个&ldquo;管理选项&rdquo;，里面有一个博客备份的功能。备份完成以后会生成一个.xml文件。</p>
<p>但是这里要注意的是这个备份的.xml文件是只能在博客园上可以导入的（也就是说备份的文件只有在博客园上才能完全使用）。不同的博客系统的.xml的内部格式是不一样的。所以我们必须进行格式的转化。</p>
<p>&nbsp;</p>
<p>进去wordpress的&ldquo;导入&rdquo;这一栏里面看一下，没有发现能从博客园导入到wordpress的工具（当然没有了<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/sleep.gif" alt="睡觉" />）</p>
<p>&nbsp;</p>
<p><strong><span>第三步</span></strong></p>
<p>但是自己能力有限，又写不出转换的脚本，所以去网上搜索了下，找到了<span>下面</span>这个博客</p>
<p>http://www.cnblogs.com/whoknows/articles/2246974.html</p>
<p>&nbsp;</p>
<p>里面有他自己写的脚本转换工具，下面是具体的使用方法和下载地址：</p>
<p><strong>使用方法：</strong></p>
<ul type="1">
<li>在cnblogs选择备份数据，导出一个XML到本地；</li>
<li>下载附件中的插件，安装至\wp-content\plugins目录；</li>
<li>后台开启插件后，可以在&ldquo;工具&rdquo;中找到&ldquo;Cnblogs数据转换&rdquo;，进入；</li>
<li>选择刚才下载的XML文件，上传后系统会自动将数据转换并导入到wordpress中</li>
</ul>
<p><strong>下载地址：&nbsp;</strong><a href="http://files.cnblogs.com/aiyuchen/cnblog.rar" target="_blank">http://files.cnblogs.com/aiyuchen/cnblog.rar</a></p>
<p><a href="http://files.cnblogs.com/aiyuchen/cnblog.rar" target="_blank">&nbsp;</a></p>
<p>在这里先谢谢他了。</p>
<p>第四步</p>
<p>按照使用方法打开wordpress在工具这个选项里面导入从博客园备份的.xml文件，就会发现自己的博客已经很顺利地转入到wordpress里面了！！<img src="http://static.blog.csdn.net/xheditor/xheditor_emot/default/laugh.gif" alt="大笑" /></p>
<p>&nbsp;</p>
<p>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p>
<p>P.S.一开始的时候没看清楚，以为导入工具里面的wordpress可以把.xml文件给导入。（其实这个工具理论上来讲只能导入从wordpress导出的.xml文件）</p>
<p>然后没有经过数据转换就导了，发现下面这个错误(<span>下面这个错误适用于从wordpress导出的备份文件重新导入到wordpress,我目前使用的wordpress版本是3.3.1</span>)：</p>
<p>&nbsp;</p>
<p><strong>Sorry, there has been an error.</strong><br />This does not appear to be a WXR file, missing/invalid WXR version number.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>大意是说没有WXR的版本号吧。于是拼命地找错误，发现了2个可能因素</p>
<p>1.打开自己的.xml文件，发现没有下面这句话，于是加上。</p>
<p><code>&lt;wp:wxr_version&gt;1.1&lt;/wp:wxr_version&gt;</code></p>
<p>但是还是报上面的错误，于是接着找解决方案，再次发现了一个可能因素</p>
<p>2.下面这段话转自wordpress的官方讨论区&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http://wordpress.org/support/topic/xml-to-wxr-issue</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div class="threadpost col-7">
<div class="post">
<p>I got hit with a similar situation.</p>
<p>In my case, It turned out to be a file permission/ownership issue. It appears that the WP core functions the importer plugin uses to upload the file do not provide error reporting for an instance where the the uploads, latest year and month directories exist but WordPress doesn't have the ownership and permission to write the file to the latest month dir. In this particular case the error reporting falls back to the plugin and</p>
<blockquote>Sorry, there has been an error.<br />This does not appear to be a WXR file, missing/invalid WXR version number.</blockquote>


<span>is the resulting error.</span>
<p>So if it happens to you on a unix box... chown or chmod your latest month's directory and it may fix the import issue.</p>
<p>Hope that helps.</p>
<p>大意是说这个是因为服务器主机的权限问题，是新创建的文件夹权限没有写的权限，所以wordpress无法读入</p>
<p>如果主机是linux的，那么解决办法是这样的</p>
<p>修改下面这个目录的权限，一般改为775就可以了</p>
<p>wordpress\wp-content\uploads\2012\02</p>
<p>关于权限的修改，给出下面这个链接</p>
<p>http://codex.wordpress.org/Changing_File_Permissions#Permission_Scheme_for_WordPress</p>
<p>&nbsp;</p>


</div>


</div>
<div class="threadpost col-7"><a href="http://blog.csdn.net/gaoxin1076/article/details/7299148">http://blog.csdn.net/gaoxin1076/article/details/7299148</a></div>
<div class="threadpost col-7">&nbsp;</div>
<div class="threadpost col-7"><a href="http://blog.csdn.net/gaoxin1076/article/details/7332847">http://blog.csdn.net/gaoxin1076/article/details/7332847</a></div>
<div class="threadpost col-7">&nbsp;</div>
<div class="threadpost col-7"><a href="http://benhealey.info/">http://benhealey.info/</a></div>]]></description></item><item><title>django构建blog</title><link>http://www.cnblogs.com/isohybrid/archive/2013/08/16/django_blog.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 16 Aug 2013 08:05:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/08/16/django_blog.html</guid><description><![CDATA[<div>code online&nbsp;<a href="https://github.com/isohybrid/mysite/tree/master/blog">https://github.com/isohybrid/mysite/tree/master/blog</a></div>
<div>&nbsp;</div>
<div><br class="Apple-interchange-newline" />Django---》&ldquo;最适合开发有限期的完美web框架&rdquo;</div>
<div>&nbsp;</div>
<div>1、创建项目&nbsp;</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;~]</span><span class="comment">#&nbsp;django-admin.py&nbsp;startproject&nbsp;mysite </span><span>&nbsp;</span></span></li>
<li><span>[root@alibaba-taobao&nbsp;~]</span><span class="comment">#&nbsp;cd&nbsp;mysite&nbsp;&amp;&amp;&nbsp;ls </span><span>&nbsp;</span></li>
<li class="alt"><span>__init__.py&nbsp;manage.py&nbsp;settings.py&nbsp;urls.py &nbsp;</span></li>

</ol>
<div>2、运行开发服务器dev</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;python&nbsp;manage.py&nbsp;runserver&nbsp;0.0.0.0:8080 </span><span>&nbsp;</span></span></li>
<li><span>Validating&nbsp;models... &nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span class="number">0</span><span>&nbsp;errors&nbsp;found &nbsp;</span></li>
<li class="alt"><span>Django&nbsp;version&nbsp;</span><span class="number">1.3</span><span>,&nbsp;using&nbsp;settings&nbsp;</span><span class="string">'mysite.settings'</span><span>&nbsp;</span></li>
<li><span>Development&nbsp;server&nbsp;</span><span class="keyword">is</span><span>&nbsp;running&nbsp;at&nbsp;http://</span><span class="number">0.0</span><span>.</span><span class="number">0.0</span><span>:</span><span class="number">8080</span><span>/ &nbsp;</span></li>
<li class="alt"><span>Quit&nbsp;the&nbsp;server&nbsp;with&nbsp;CONTROL-C. &nbsp;</span></li>
<li><span>[</span><span class="number">10</span><span>/Nov/</span><span class="number">2011</span><span>&nbsp;</span><span class="number">02</span><span>:</span><span class="number">11</span><span>:</span><span class="number">59</span><span>]&nbsp;</span><span class="string">"GET&nbsp;/&nbsp;HTTP/1.1"</span><span>&nbsp;</span><span class="number">200</span><span>&nbsp;</span><span class="number">2051</span><span>&nbsp;</span></li>
<li class="alt"><span>[</span><span class="number">10</span><span>/Nov/</span><span class="number">2011</span><span>&nbsp;</span><span class="number">02</span><span>:</span><span class="number">12</span><span>:</span><span class="number">00</span><span>]&nbsp;</span><span class="string">"GET&nbsp;/&nbsp;HTTP/1.1"</span><span>&nbsp;</span><span class="number">200</span><span>&nbsp;</span><span class="number">2051</span><span>&nbsp;</span></li>

</ol>
<p><a href="http://img1.51cto.com/attachment/201111/163623121.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163623121.png" alt="" border="0" /></a></p>
<div>2.3、创建blog项目</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;python&nbsp;manage.py&nbsp;startapp&nbsp;blog </span><span>&nbsp;</span></span></li>
<li><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;ll&nbsp;blog/ </span><span>&nbsp;</span></li>
<li class="alt"><span>total&nbsp;</span><span class="number">12</span><span>&nbsp;</span></li>
<li><span>-rw-r--r--&nbsp;</span><span class="number">1</span><span>&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;</span><span class="number">0</span><span>&nbsp;Nov&nbsp;</span><span class="number">10</span><span>&nbsp;</span><span class="number">16</span><span>:</span><span class="number">14</span><span>&nbsp;__init__.py &nbsp;</span></li>
<li class="alt"><span>-rw-r--r--&nbsp;</span><span class="number">1</span><span>&nbsp;root&nbsp;root&nbsp;</span><span class="number">57</span><span>&nbsp;Nov&nbsp;</span><span class="number">10</span><span>&nbsp;</span><span class="number">16</span><span>:</span><span class="number">14</span><span>&nbsp;models.py &nbsp;</span></li>
<li><span>-rw-r--r--&nbsp;</span><span class="number">1</span><span>&nbsp;root&nbsp;root&nbsp;</span><span class="number">383</span><span>&nbsp;Nov&nbsp;</span><span class="number">10</span><span>&nbsp;</span><span class="number">16</span><span>:</span><span class="number">14</span><span>&nbsp;tests.py &nbsp;</span></li>
<li class="alt"><span>-rw-r--r--&nbsp;</span><span class="number">1</span><span>&nbsp;root&nbsp;root&nbsp;</span><span class="number">26</span><span>&nbsp;Nov&nbsp;</span><span class="number">10</span><span>&nbsp;</span><span class="number">16</span><span>:</span><span class="number">14</span><span>&nbsp;views.py &nbsp;</span></li>

</ol>
<div>把blog这个app以模块的形式添加到settings.py文件的INSTALLED_APPS元组中，声明使用该app</div>
<ol class="dp-py">
<li class="alt"><span>INSTALLED_APPS&nbsp;=&nbsp;( &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.auth'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.contenttypes'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.sessions'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.sites'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.messages'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.staticfiles'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'mysite.blog'</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">##注意有个逗号 </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;'django.contrib.admin', </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;admin&nbsp;documentation: </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;'django.contrib.admindocs', </span><span>&nbsp;</span></li>
<li class="alt"><span>) &nbsp;</span></li>

</ol>
<div>2.4、设计模型来定义blog数据结构（这是基于django的blog应用核心部分）</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;vim&nbsp;models.py </span><span>&nbsp;</span></span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="comment">#&nbsp;Create&nbsp;your&nbsp;views&nbsp;here. </span><span>&nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.db&nbsp;</span><span class="keyword">import</span><span>&nbsp;models &nbsp;</span></li>
<li class="alt"><span class="keyword">class</span><span>&nbsp;BlogPost(models.Model): &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;models.CharField(max_length=</span><span class="number">150</span><span>) &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;=&nbsp;models.TextField() &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp&nbsp;=&nbsp;models.DateTimeField() &nbsp;</span></li>

</ol>
<div>博客很简单：就标题、内容、时间三块</div>
<div>&nbsp;</div>
<div>2.5、设置连接数据库mysql</div>
<ol class="dp-sql">
<li class="alt"><span>[root@alibaba-taobao&nbsp;mysite]#&nbsp;/etc/init.d/mysqld&nbsp;start &nbsp;</span></li>
<li><span>Starting&nbsp;MySQL:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;OK&nbsp;] &nbsp;</span></li>
<li class="alt"><span>[root@alibaba-taobao&nbsp;mysite]#&nbsp;mysql&nbsp;-uroot&nbsp;-palibaba &nbsp;</span></li>
<li><span>mysql&gt;&nbsp;</span><span class="keyword">create</span><span>&nbsp;</span><span class="keyword">database</span><span>&nbsp;blog; &nbsp;</span></li>
<li class="alt"><span>Query&nbsp;OK,&nbsp;1&nbsp;row&nbsp;affected&nbsp;(0.00&nbsp;sec) &nbsp;</span></li>

</ol>
<div>设置settings.py连接数据库</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;vim&nbsp;settings.py </span><span>&nbsp;</span></span></li>
<li><span>。。。 &nbsp;</span></li>
<li class="alt"><span>DATABASES&nbsp;=&nbsp;{ &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'default'</span><span>:&nbsp;{ &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'ENGINE'</span><span>:&nbsp;</span><span class="string">'django.db.backends.mysql'</span><span>,&nbsp;</span><span class="comment">#&nbsp;Add&nbsp;'postgresql_psycopg2',&nbsp;'postgresql',&nbsp;'mysql',&nbsp;'sqlite3'&nbsp;or&nbsp;'oracle'. </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'NAME'</span><span>:&nbsp;</span><span class="string">'blog'</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Or&nbsp;path&nbsp;to&nbsp;database&nbsp;file&nbsp;if&nbsp;using&nbsp;sqlite3. </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'USER'</span><span>:&nbsp;</span><span class="string">'root'</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Not&nbsp;used&nbsp;with&nbsp;sqlite3. </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'PASSWORD'</span><span>:&nbsp;</span><span class="string">'alibaba'</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Not&nbsp;used&nbsp;with&nbsp;sqlite3. </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'HOST'</span><span>:&nbsp;</span><span class="string">''</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Set&nbsp;to&nbsp;empty&nbsp;string&nbsp;for&nbsp;localhost.&nbsp;Not&nbsp;used&nbsp;with&nbsp;sqlite3. </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'PORT'</span><span>:&nbsp;</span><span class="string">''</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Set&nbsp;to&nbsp;empty&nbsp;string&nbsp;for&nbsp;default.&nbsp;Not&nbsp;used&nbsp;with&nbsp;sqlite3. </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;</span></li>
<li><span>} &nbsp;</span></li>

</ol>
<div>通过定义好的数据结构来生成表数据，</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;python&nbsp;manage.py&nbsp;syncdb </span><span>&nbsp;</span></span></li>
<li><span>Creating&nbsp;tables&nbsp;... &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;auth_permission &nbsp;</span></li>
<li><span>Creating&nbsp;table&nbsp;auth_group_permissions &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;auth_group &nbsp;</span></li>
<li><span>Creating&nbsp;table&nbsp;auth_user_user_permissions &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;auth_user_groups &nbsp;</span></li>
<li><span>Creating&nbsp;table&nbsp;auth_user &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;auth_message &nbsp;</span></li>
<li><span>Creating&nbsp;table&nbsp;django_content_type &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;django_session &nbsp;</span></li>
<li><span>Creating&nbsp;table&nbsp;django_site &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;blog_blogpost &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>You&nbsp;just&nbsp;installed&nbsp;Django</span><span class="string">'s&nbsp;auth&nbsp;system,&nbsp;which&nbsp;means&nbsp;you&nbsp;don'</span><span>t&nbsp;have&nbsp;any&nbsp;superusers&nbsp;defined. &nbsp;</span></li>
<li><span>Would&nbsp;you&nbsp;like&nbsp;to&nbsp;create&nbsp;one&nbsp;now?&nbsp;(yes/no):&nbsp;yes &nbsp;</span></li>
<li class="alt"><span>Username&nbsp;(Leave&nbsp;blank&nbsp;to&nbsp;use&nbsp;</span><span class="string">'root'</span><span>):&nbsp;root &nbsp;</span></li>
<li><span>E-mail&nbsp;address:&nbsp;zhipeng.wangzp@alibaba-inc.com &nbsp;</span></li>
<li class="alt"><span>Password: &nbsp;</span></li>
<li><span>Password&nbsp;(again): &nbsp;</span></li>
<li class="alt"><span>Superuser&nbsp;created&nbsp;successfully. &nbsp;</span></li>
<li><span>Installing&nbsp;custom&nbsp;SQL&nbsp;... &nbsp;</span></li>
<li class="alt"><span>Installing&nbsp;indexes&nbsp;... &nbsp;</span></li>
<li><span>No&nbsp;fixtures&nbsp;found. &nbsp;</span></li>

</ol>
<div>由于在INSTALLED_APPS默认开启了django.contrib.auth，所以提示创建auth系统用户，反正下面</div>
<div>用到，所以提前创建好用户root:alibaba</div>
<ol class="dp-sql">
<li class="alt"><span>[root@alibaba-taobao&nbsp;mysite]#&nbsp;!mysql &nbsp;</span></li>
<li><span>mysql&nbsp;-uroot&nbsp;-palibaba &nbsp;</span></li>
<li class="alt"><span>Welcome&nbsp;</span><span class="keyword">to</span><span>&nbsp;the&nbsp;MySQL&nbsp;monitor.&nbsp;Commands&nbsp;</span><span class="keyword">end</span><span>&nbsp;</span><span class="keyword">with</span><span>&nbsp;;&nbsp;</span><span class="op">or</span><span>&nbsp;\g. &nbsp;</span></li>
<li><span>Your&nbsp;MySQL&nbsp;</span><span class="keyword">connection</span><span>&nbsp;id&nbsp;</span><span class="keyword">is</span><span>&nbsp;268 &nbsp;</span></li>
<li class="alt"><span>Server&nbsp;version:&nbsp;5.0.77&nbsp;Source&nbsp;distribution &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>Type&nbsp;</span><span class="string">'help;'</span><span>&nbsp;</span><span class="op">or</span><span>&nbsp;</span><span class="string">'\h'</span><span>&nbsp;</span><span class="keyword">for</span><span>&nbsp;help.&nbsp;Type&nbsp;</span><span class="string">'\c'</span><span>&nbsp;</span><span class="keyword">to</span><span>&nbsp;clear&nbsp;the&nbsp;buffer. &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>mysql&gt;&nbsp;use&nbsp;blog; &nbsp;</span></li>
<li><span>Reading&nbsp;</span><span class="keyword">table</span><span>&nbsp;information&nbsp;</span><span class="keyword">for</span><span>&nbsp;completion&nbsp;</span><span class="keyword">of</span><span>&nbsp;</span><span class="keyword">table</span><span>&nbsp;</span><span class="op">and</span><span>&nbsp;</span><span class="keyword">column</span><span>&nbsp;names &nbsp;</span></li>
<li class="alt"><span>You&nbsp;can&nbsp;turn&nbsp;</span><span class="keyword">off</span><span>&nbsp;this&nbsp;feature&nbsp;</span><span class="keyword">to</span><span>&nbsp;get&nbsp;a&nbsp;quicker&nbsp;startup&nbsp;</span><span class="keyword">with</span><span>&nbsp;-A &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">Database</span><span>&nbsp;changed &nbsp;</span></li>
<li><span>mysql&gt;&nbsp;show&nbsp;tables; &nbsp;</span></li>
<li class="alt"><span>+</span><span class="comment">----------------------------+ </span><span>&nbsp;</span></li>
<li><span>|&nbsp;Tables_in_blog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>+</span><span class="comment">----------------------------+ </span><span>&nbsp;</span></li>
<li><span>|&nbsp;auth_group&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;auth_group_permissions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;auth_message&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;auth_permission&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;auth_user&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;auth_user_groups&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;auth_user_user_permissions&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;blog_blogpost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;django_admin_log&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;django_content_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;django_session&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;django_site&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>+</span><span class="comment">----------------------------+ </span><span>&nbsp;</span></li>
<li class="alt"><span>12&nbsp;</span><span class="keyword">rows</span><span>&nbsp;</span><span class="op">in</span><span>&nbsp;</span><span class="keyword">set</span><span>&nbsp;(0.00&nbsp;sec) &nbsp;</span></li>
<li><span>mysql&gt;&nbsp;</span><span class="keyword">desc</span><span>&nbsp;blog_blogpost; &nbsp;</span></li>
<li class="alt"><span>+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+ </span><span>&nbsp;</span></li>
<li><span>|&nbsp;Field&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="op">Null</span><span>&nbsp;|&nbsp;</span><span class="keyword">Key</span><span>&nbsp;|&nbsp;</span><span class="keyword">Default</span><span>&nbsp;|&nbsp;Extra&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+ </span><span>&nbsp;</span></li>
<li><span>|&nbsp;id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="keyword">int</span><span>(11)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="keyword">NO</span><span>&nbsp;&nbsp;&nbsp;|&nbsp;PRI&nbsp;|&nbsp;</span><span class="op">NULL</span><span>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;auto_increment&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;title&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="keyword">varchar</span><span>(150)&nbsp;|&nbsp;</span><span class="keyword">NO</span><span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="op">NULL</span><span>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>|&nbsp;body&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;longtext&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="keyword">NO</span><span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="op">NULL</span><span>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li class="alt"><span>|&nbsp;</span><span class="keyword">timestamp</span><span>&nbsp;|&nbsp;datetime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="keyword">NO</span><span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;</span><span class="op">NULL</span><span>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &nbsp;</span></li>
<li><span>+</span><span class="comment">-----------+--------------+------+-----+---------+----------------+ </span><span>&nbsp;</span></li>
<li class="alt"><span>4&nbsp;</span><span class="keyword">rows</span><span>&nbsp;</span><span class="op">in</span><span>&nbsp;</span><span class="keyword">set</span><span>&nbsp;(0.01&nbsp;sec) &nbsp;</span></li>

</ol>
<div>可以看到通过定义的数据结构生成了数据表。这里的ID是自动生成的。</div>
<div>&nbsp;</div>
<div>2.6、设置admin应用（用于CRUD，即便于create read&nbsp;update&nbsp;delete）</div>
<div>首先在settings.py的INSTALLED_APPS元组中启用'django.contrib.auth'</div>
<ol class="dp-py">
<li class="alt"><span>INSTALLED_APPS&nbsp;=&nbsp;( &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.auth'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.contenttypes'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.sessions'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.sites'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.messages'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.staticfiles'</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'mysite.blog'</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="string">'django.contrib.admin'</span><span>,&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#注意逗号 </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;'django.contrib.admin', </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;admin&nbsp;documentation: </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;'django.contrib.admindocs', </span><span>&nbsp;</span></li>
<li><span>) &nbsp;</span></li>

</ol>
<div>运行syncdb把新添加的应用生成数据表</div>
<ol class="dp-c">
<li class="alt"><span>[root@alibaba-taobao&nbsp;mysite]#&nbsp;python&nbsp;manage.py&nbsp;syncdb &nbsp;</span></li>
<li><span>Creating&nbsp;tables&nbsp;... &nbsp;</span></li>
<li class="alt"><span>Creating&nbsp;table&nbsp;django_admin_log &nbsp;</span></li>
<li><span>Installing&nbsp;custom&nbsp;SQL&nbsp;... &nbsp;</span></li>
<li class="alt"><span>Installing&nbsp;indexes&nbsp;... &nbsp;</span></li>
<li><span>No&nbsp;fixtures&nbsp;found. &nbsp;</span></li>

</ol>
<div>再次去查看tables的话可以发现多了django_admin_log这张表</div>
<div>&nbsp;</div>
<div>到目前为止，数据表结构和admin应用的做好了，往下要设定一个URL来访问该应用</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;vim&nbsp;urls.py </span><span>&nbsp;</span></span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;django.conf.urls.defaults&nbsp;</span><span class="keyword">import</span><span>&nbsp;patterns,&nbsp;include,&nbsp;url &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;two&nbsp;lines&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.contrib&nbsp;</span><span class="keyword">import</span><span>&nbsp;admin &nbsp;</span></li>
<li class="alt"><span>admin.autodiscover() &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>urlpatterns&nbsp;=&nbsp;patterns(</span><span class="string">''</span><span>, &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Examples: </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^$',&nbsp;'mysite.views.home',&nbsp;name='home'), </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^mysite/',&nbsp;include('mysite.foo.urls')), </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;admin/doc&nbsp;line&nbsp;below&nbsp;to&nbsp;enable&nbsp;admin&nbsp;documentation: </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^admin/doc/',&nbsp;include('django.contrib.admindocs.urls')), </span><span>&nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url(r</span><span class="string">'^admin/'</span><span>,&nbsp;include(admin.site.urls)), &nbsp;</span></li>
<li class="alt"><span>) &nbsp;</span></li>

</ol>
<div>去掉蓝色部分前面的注释符号#，实现admin页面相应</div>
<div>访问<a href="http://192.168.199.129:8080/admin/">http://192.168.199.129:8080/admin/</a>&nbsp;测试，这里是我的主机IP</div>
<p><a href="http://img1.51cto.com/attachment/201111/163655665.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163655665.png" alt="" border="0" /></a></p>
<div>通过admin这个管理接口，还没看到blog应用，因为需要告诉django要在admin窗口显示上面</div>
<div>制定好的模型，这里只需要在modules.py中导入admin应用即可：</div>
<div>&nbsp;</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;pwd </span><span>&nbsp;</span></span></li>
<li><span>/root/mysite/blog &nbsp;</span></li>
<li class="alt"><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;vim&nbsp;models.py </span><span>&nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.db&nbsp;</span><span class="keyword">import</span><span>&nbsp;models &nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;django.contrib&nbsp;</span><span class="keyword">import</span><span>&nbsp;admin &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">class</span><span>&nbsp;BlogPost(models.Model): &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;models.CharField(max_length=</span><span class="number">150</span><span>) &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;=&nbsp;models.TextField() &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp&nbsp;=&nbsp;models.DateTimeField() &nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span>admin.site.register(BlogPost) &nbsp;</span></li>

</ol>
<div>好了，重新刷新页面即可。</div>
<p><a href="http://img1.51cto.com/attachment/201111/163717364.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163717364.png" alt="" border="0" /></a></p>
<div>点击进去，添加博客：</div>
<div>&nbsp;</div>
<p><a href="http://img1.51cto.com/attachment/201111/163734774.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163734774.png" alt="" border="0" /></a></p>
<p><a href="http://img1.51cto.com/attachment/201111/163748621.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163748621.png" alt="" border="0" /></a></p>
<div>&nbsp;</div>
<div>保存。</div>
<div>这里还可以对admin的视图列表改进一下，只需在models.py中添加BlogPostAdmin类：</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;vim&nbsp;models.py </span><span>&nbsp;</span></span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>admin.site.register(BlogPost) &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;django.db&nbsp;</span><span class="keyword">import</span><span>&nbsp;models &nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.contrib&nbsp;</span><span class="keyword">import</span><span>&nbsp;admin &nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span class="keyword">class</span><span>&nbsp;BlogPost(models.Model): &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title&nbsp;=&nbsp;models.CharField(max_length=</span><span class="number">150</span><span>) &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body&nbsp;=&nbsp;models.TextField() &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp&nbsp;=&nbsp;models.DateTimeField() &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">class</span><span>&nbsp;BlogPostAdmin(admin.ModelAdmin): &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_display&nbsp;=&nbsp;(</span><span class="string">'title'</span><span>,</span><span class="string">'body'</span><span>,</span><span class="string">'timestamp'</span><span>) &nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span>admin.site.register(BlogPost,BlogPostAdmin) &nbsp;</span></li>

</ol>
<div>刷新页面：</div>
<p><a href="http://img1.51cto.com/attachment/201111/163803670.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163803670.png" alt="" border="0" /></a></p>
<div>顺便我们还可以修改TIME_ZONE为亚洲上海和LANGUAGE_CODE为zh_CN，到settings.py里修改即可</div>
<div>&nbsp;</div>
<p><a href="http://img1.51cto.com/attachment/201111/163817657.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163817657.png" alt="" border="0" /></a></p>
<p>到这里，后台管理、数据库后台都搞定了，但是对于一个博客还需要一个前台页面！</p>
<div>这里不谈及前端设计，所以丑丑也罢。。但至少要有！！</div>
<div>&nbsp;</div>
<div>2.8、建立blog公共部分（即前端显示）</div>
<div>对于前端页面，从django角度讲，有三个典型的组件：</div>
<div>一个模板（template）：负责将传进来的信息显示出来，一般是Html页面</div>
<div>一个视图函数（view）：负责从数据库获取要显示的信息，替代了SQL语句。其实在上面把blog数据结构生成数据库表也是django底层处理的，替代了SQL语句。即为屏蔽的数据库层面，好处是数据库迁移之类的，便捷。</div>
<div>一个URL模式：定义好被访问的URL，可不是管理后台的URL哦！</div>
<div>2.8.1、创建模板</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;cat&nbsp;templates/archive.html </span><span>&nbsp;</span></span></li>
<li><span>{%&nbsp;block&nbsp;content&nbsp;%} &nbsp;</span></li>
<li class="alt"><span>{%&nbsp;</span><span class="keyword">for</span><span>&nbsp;post&nbsp;</span><span class="keyword">in</span><span>&nbsp;posts&nbsp;%} &nbsp;</span></li>
<li><span>&lt;h1&gt;{{&nbsp;post.title}}&lt;/h1&gt; &nbsp;</span></li>
<li class="alt"><span>&lt;p&gt;{{&nbsp;post.timestamp}}&lt;/p&gt; &nbsp;</span></li>
<li><span>&lt;p&gt;{{&nbsp;post.body&nbsp;}}&lt;/p&gt; &nbsp;</span></li>
<li class="alt"><span>{%&nbsp;endfor&nbsp;%} &nbsp;</span></li>

</ol>
<div>通过变量标签和块标签实现blog文章一篇篇显示，没涉及到翻页！</div>
<div>对于archive.html的命名随意，但是对于新创建的templates目录则强制设定的，因为</div>
<div>django在默认情况下会在搜索模板的时候查看应用程序下的每个templates目录。</div>
<div>&nbsp;</div>
<div>2.8.2、创建一个视图函数（应该说，这里头也就只有视图函数才见到python）</div>
<div>该视图函数用于从数据库读取所有blog文章，并用上面的模板显示出来</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;blog]</span><span class="comment">#&nbsp;vim&nbsp;views.py </span><span>&nbsp;</span></span></li>
<li><span class="comment">#&nbsp;Create&nbsp;your&nbsp;views&nbsp;here. </span><span>&nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;django.template&nbsp;</span><span class="keyword">import</span><span>&nbsp;loader,Context &nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.http&nbsp;</span><span class="keyword">import</span><span>&nbsp;HttpResponse &nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;mysite.blog.models&nbsp;</span><span class="keyword">import</span><span>&nbsp;BlogPost &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">def</span><span>&nbsp;archive(request): &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;posts&nbsp;=&nbsp;BlogPost.objects.all() &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t&nbsp;=&nbsp;loader.get_template(</span><span class="string">"archive.html"</span><span>) &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;Context({</span><span class="string">'posts'</span><span>:posts}) &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="keyword">return</span><span>&nbsp;HttpResponse(t.render(c)) &nbsp;</span></li>

</ol>
<div>2.8.3、创建URL</div>
<ol class="dp-py">
<li class="alt"><span><span>[root@alibaba-taobao&nbsp;mysite]</span><span class="comment">#&nbsp;vim&nbsp;urls.py </span><span>&nbsp;</span></span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="keyword">from</span><span>&nbsp;django.conf.urls.defaults&nbsp;</span><span class="keyword">import</span><span>&nbsp;patterns,&nbsp;include,&nbsp;url &nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;two&nbsp;lines&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;django.contrib&nbsp;</span><span class="keyword">import</span><span>&nbsp;admin &nbsp;</span></li>
<li class="alt"><span>admin.autodiscover() &nbsp;</span></li>
<li><span class="keyword">from</span><span>&nbsp;mysite.blog.views&nbsp;</span><span class="keyword">import</span><span>&nbsp;* &nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span>urlpatterns&nbsp;=&nbsp;patterns(</span><span class="string">''</span><span>, &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Examples: </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^$',&nbsp;'mysite.views.home',&nbsp;name='home'), </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^mysite/',&nbsp;include('mysite.foo.urls')), </span><span>&nbsp;</span></li>
<li><span>&nbsp; &nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;admin/doc&nbsp;line&nbsp;below&nbsp;to&nbsp;enable&nbsp;admin&nbsp;documentation: </span><span>&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;url(r'^admin/doc/',&nbsp;include('django.contrib.admindocs.urls')), </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp; &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="comment">#&nbsp;Uncomment&nbsp;the&nbsp;next&nbsp;line&nbsp;to&nbsp;enable&nbsp;the&nbsp;admin: </span><span>&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url(r</span><span class="string">'^admin/'</span><span>,&nbsp;include(admin.site.urls)), &nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url(r</span><span class="string">'^blog/$'</span><span>,&nbsp;archive), &nbsp;</span></li>
<li class="alt"><span>) &nbsp;</span></li>

</ol>
<p><a href="http://img1.51cto.com/attachment/201111/163842730.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163842730.png" alt="" border="0" /></a></p>
<div>这里的流程是这样的：</div>
<div>访问<a href="http://192.168.199.129:8080/blog/">http://192.168.199.129:8080/blog/</a>&nbsp;被指向archive函数，该函数在mysite.blog.views</div>
<div>下定义的，所以才在上面import的，通过views.py定义的内容从数据库获取内容并返回给client者。</div>
<div>至于这里python和正则定义的内容不多解释了，django开发指南讲述比较清楚。</div>
<div>到这里，这个blog就算是完成好了。如果说要把页面做个美化之类的，那是前端的事情咯。</div>
<div>继续添加文章：</div>
<p><a href="http://img1.51cto.com/attachment/201111/163905754.png" target="_blank"><img src="http://img1.51cto.com/attachment/201111/163905754.png" alt="" border="0" /></a></p>
<ol class="dp-py">
<li class="alt"><span><span>&nbsp;&nbsp;[root@alibaba-taobao&nbsp;~]</span><span class="comment">#&nbsp;tree&nbsp;mysite </span><span>&nbsp;</span></span></li>
<li><span>mysite &nbsp;</span></li>
<li class="alt"><span>|--&nbsp;__init__.py &nbsp;</span></li>
<li><span>|--&nbsp;__init__.pyc &nbsp;</span></li>
<li class="alt"><span>|--&nbsp;blog &nbsp;</span></li>
<li><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;__init__.py &nbsp;</span></li>
<li class="alt"><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;__init__.pyc &nbsp;</span></li>
<li><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;models.py &nbsp;</span></li>
<li class="alt"><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;models.pyc &nbsp;</span></li>
<li><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;templates &nbsp;</span></li>
<li class="alt"><span>|&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;`--&nbsp;archive.html &nbsp;</span></li>
<li><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;tests.py &nbsp;</span></li>
<li class="alt"><span>|&nbsp;&nbsp;&nbsp;|--&nbsp;views.py &nbsp;</span></li>
<li><span>|&nbsp;&nbsp;&nbsp;`--&nbsp;views.pyc &nbsp;</span></li>
<li class="alt"><span>|--&nbsp;manage.py &nbsp;</span></li>
<li><span>|--&nbsp;settings.py &nbsp;</span></li>
<li class="alt"><span>|--&nbsp;settings.pyc &nbsp;</span></li>
<li><span>|--&nbsp;urls.py &nbsp;</span></li>
<li class="alt"><span>`--&nbsp;urls.pyc &nbsp;</span></li>
<li><span class="number">2</span><span>&nbsp;directories,&nbsp;</span><span class="number">15</span><span>&nbsp;files &nbsp;</span></li>

</ol>
<p>说明：from 《django web开发指南》一书。。。有做过一些小改动。。</p>
<p>毕竟书有点旧了，因为django版本问题，会出现一些小问题。。。</p>
<p>不停的google就可以解决问题。。。</p>
<p>本文出自 &ldquo;<a href="http://twentyfour.blog.51cto.com/">twenty_four</a>&rdquo; 博客，请务必保留此出处<a href="http://twentyfour.blog.51cto.com/945260/711249">http://twentyfour.blog.51cto.com/945260/711249</a></p>]]></description></item><item><title>django常见错误</title><link>http://www.cnblogs.com/isohybrid/archive/2013/08/16/django_error.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 16 Aug 2013 07:37:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/08/16/django_error.html</guid><description><![CDATA[<p><span><strong>参考：</strong></span></p>
<p><a href="http://xiaozhen1900.blog.163.com/blog/static/174173257201271634537312"><span>http://xiaozhen1900.blog.163.com/blog/static/174173257201271634537312</span></a></p>
<p><a href="http://blog.163.com/wangkangming2008@126/blog/static/78277928201111189568653/">http://blog.163.com/wangkangming2008@126/blog/static/78277928201111189568653/</a></p>
<p>&nbsp;</p>
<p><a href="http://www.cnblogs.com/Phenix_Yang/archive/2010/06/11/1756401.html"><span>http://www.cnblogs.com/Phenix_Yang/archive/2010/06/11/1756401.html</span></a></p>
<p>注意：所有引用自己内容，都不需加项目名。</p>
<p>例如：from blog.views import archive&nbsp; 不用from mysite.blog.views import archive(这样会出错)</p>
<p>&nbsp;</p>
<p><span><strong><span>1.<span style="text-decoration: underline;">No module named blog</span></span></strong></span></p>
<p>Django版本的问题，我安装的是1.4版本，看了一下Django的doc就发现问题了。</p>
<p>原来在INSTALLED_APPS中只需要添加app名就可以了，即:</p>
<p>'blog',</p>
<p>&nbsp;</p>
<p>不愿要添加项目的名称</p>
<p>'mysite.blog',</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span><strong>2.django no model named mysqldb</strong></span></p>
<p><span>django 创建数据模型时 命令行提示出现错误&nbsp;&nbsp;&nbsp;</span></p>
<div id="blog_text"><span>&nbsp; ImprotError：no no module named MySQLdb。这是因为错误中提到的MySQLdb模块，</span></div>
<p><span>正位于MySQL中的，而Python和MySQL之间没有建立连接，因此Django找不到这个名为MySQLdb的模块。<br /><span>解决方法：</span>下载一个非常小的程序，安上就OK了。这个程序叫做<span>MySQL-python-1.2.2.win32-py2.7.exe</span></span></p>
<p>&nbsp;</p>
<p><span><strong>3.</strong></span><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/Phenix_Yang/archive/2010/06/11/1756401.html"><span><strong>NameError: name 'admin' is not defined</strong></span></a></p>
<p>步骤：</p>
<p>1、修改settings.py。在INSTALLED_APPS设置中添加&ldquo;django.contrib.admin&rdquo;。</p>
<p>2、运行python manage.py syncdb更新数据库</p>
<p>3、修改urls.py。改为：</p>
<p># Uncomment the next two lines to enable the admin:<br /><span>from django.contrib import admin<br />admin.autodiscover()</span></p>
<p>&nbsp;</p>
<p># Uncomment this for admin:<br /><span>(r'^admin/', include('django.contrib.admin.urls')),</span><br />去掉注释。</p>
<p>在运行时，遇到这种问题：<span>注意空格的问题</span></p>
<pre>Traceback (most recent call last): File "D:\python2.6\lib\site-packages\django\core\servers\basehttp.py", line 279, in run self.result = application(self.environ, self.start_response) File "D:\python2.6\lib\site-packages\django\core\servers\basehttp.py", line 651, in __call__ return self.application(environ, start_response) File "D:\python2.6\lib\site-packages\django\core\handlers\wsgi.py", line 241, in __call__ response = self.get_response(request) File "D:\python2.6\lib\site-packages\django\core\handlers\base.py", line 73, in get_response response = middleware_method(request) File "D:\python2.6\lib\site-packages\django\middleware\common.py", line 56, in process_request if (not _is_valid_path(request.path_info) and File "D:\python2.6\lib\site-packages\django\middleware\common.py", line 142, in _is_valid_path urlresolvers.resolve(path) File "D:\python2.6\lib\site-packages\django\core\urlresolvers.py", line 294, in resolve return get_resolver(urlconf).resolve(path) File "D:\python2.6\lib\site-packages\django\core\urlresolvers.py", line 216, in resolve for pattern in self.url_patterns: File "D:\python2.6\lib\site-packages\django\core\urlresolvers.py", line 245, in _get_url_patterns patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module) File "D:\python2.6\lib\site-packages\django\core\urlresolvers.py", line 240, in _get_urlconf_module self._urlconf_module = import_module(self.urlconf_name) File "D:\python2.6\lib\site-packages\django\utils\importlib.py", line 35, in import_module __import__(name) File "D:\python2.6\Scripts\newtest\..\newtest\urls.py", line 17, in &lt;module&gt; (r'^admin/', include(admin.site.urls)), NameError: name 'admin' is not defined 解决问题的方法：</pre>
<pre>在urls.py中添加：from django.contrib import admin</pre>
<pre>二、增加超级用户</pre>
<pre>manage.py shell</pre>
<pre>&gt;&gt;&gt;from django.contrib.auth.create_superuser import createsuperuser</pre>
<pre>&gt;&gt;&gt;createsuperuser()</pre>
<pre>以上语句可能不能执行，可以改为执行：&gt;&gt;&gt;python manage.py createsuperuser</pre>
<pre> 进入admin管理页面，想将英文显示中文化：</pre>
<pre>将settings.py中 <span><tt><span><span>LANGUAGE_CODE</span></span></tt> 由 <tt><span><span>'en-us'</span></span></tt> 改为 <tt><span><span>'zh-cn'</span></span></tt> ， <tt><span><span>TIME_ZONE</span></span></tt> 建议改为 <tt><span><span>'CCT'</span></span></tt></span></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span>4.AttributeError: 'module' object has no attribute</span></p>
<p>&nbsp;</p>
<p><span>5.unexpected indent</span></p>
<p>格式错误，缩进不对。</p>
<p>参考：<a href="http://hi.baidu.com/assslove/item/b7e65909dc2590364bc4a36c">http://hi.baidu.com/assslove/item/b7e65909dc2590364bc4a36c</a></p>
<p>&nbsp;</p>]]></description></item><item><title>git</title><link>http://www.cnblogs.com/isohybrid/archive/2013/08/12/git_base.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 11 Aug 2013 18:43:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/08/12/git_base.html</guid><description><![CDATA[<h4>1. 开始git</h4>
<p>1.1 开始一个新的项目，初始化新的代码仓库<br />要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<div>
<div id="highlighter_107220" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git init</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>会在当前目录下生成一个.git目录，包含了所有git需要的数据和资源</p>
<p>1.2 把服务端的项目拷贝到本地<br />git支持许多传输协议，如http、https、git、ssh等，下面例子使用git协议</p>
<div>
<div id="highlighter_167297" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git clone git:</code><code class="shell plain">//github</code><code class="shell plain">.com</code><code class="shell plain">/andymccurdy/redis-py</code><code class="shell plain">.git</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<h4>2.跟踪文件</h4>
<p>跟踪某个文件或者某个目录下所有文件，就是把需要跟踪的文件加入暂存区（stage），下面把当前目录下的所有文件加入到暂存区</p>
<div>
<div id="highlighter_915200" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git add ./</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<h4>3. 查看当前文件状态</h4>
<p>git status或者git status xx(指定目录或者文件的状态)<br />执行</p>
<div>
<div id="highlighter_733083" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git status</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<blockquote>
<p># On branch master<br />#<br /># Initial commit<br />#<br /># Changes to be committed:<br /># &nbsp; (use &ldquo;git rm &ndash;cached &hellip;&rdquo; to unstage)<br />#<br />#new file: &Acirc;&nbsp; c/file_operator/.file_cp.c.swp<br />#new file: &nbsp; c/file_operator/file_cp<br />#new file: &nbsp; c/file_operator/file_cp.c<br />#new file: &nbsp; c/file_operator/file_create<br />#new file: &nbsp; c/file_operator/file_create.c<br />#new file: &nbsp; c/file_operator/file_time<br />#new file: &nbsp; c/file_operator/file_time.cached可以看到，执行git add ./后，当前目录下这些文件已经被跟踪了，被添加到暂存区，同时&nbsp;(use &ldquo;git rm &ndash;cached&hellip;&rdquo; to unstage)提示你可以使用该命令取消跟踪。</p>

</blockquote>
<p>注：如果你git add xx后又修改了xx文件，此时应该重新执行git add xx，把最新的xx文件添加到暂存区</p>
<h4>4.取消跟踪文件</h4>
<p>与跟踪文件相反，取消跟踪就是把该文件或目录从暂存区（stage）移除</p>
<div>
<div id="highlighter_150158" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git </code><code class="shell functions">rm</code> <code class="shell plain">--cached&nbsp; c</code><code class="shell plain">/file_operator/</code><code class="shell plain">.file_cp.c.swp</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>ps：此时.file_cp.c.swp文件已经从暂存区域删除，但是仍在当前目录下，如果想把该文件也从工作目录中删除，执行</p>
<div>
<div id="highlighter_64390" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git </code><code class="shell functions">rm</code> <code class="shell plain">c</code><code class="shell plain">/file_operator/</code><code class="shell plain">.file_cp.c.swp</code></div>
<div class="line number2 index1 alt1"><code class="shell plain">git status</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<blockquote>
<p># On branch master<br />#<br /># Initial commit<br />#<br /># Changes to be committed:<br /># &nbsp; (use &ldquo;git rm &ndash;cached &hellip;&rdquo; to unstage)<br />#<br />#new file: &nbsp; c/file_operator/file_operatorle_cp<br />#new file: &nbsp; c/file_operator/file_cp.c<br />#new file: &nbsp; c/file_operatorle_cperator/file_create<br />#new file: &nbsp; c/file_operator/file_create.c<br />#new file_operatorile: &nbsp; c/file_operator/file_time<br />#new file: &nbsp; c/file_operator/file_timeime.c<br /># Untracked files:<br /># &nbsp; (use &ldquo;git add &hellip;&rdquo; to include in what will be committed)<br />#<br />#c/file_operator/.file_cp.c.swp</p>

</blockquote>
<p>可以看到&nbsp;c/file_operatorrator/.file_cp.c.swp 已经不在stage区了。可以通过git add重新添加到stage区</p>
<h4>5.忽略某些文件</h4>
<p>在实际项目中，有些文件不需要使用git进行管理，比如:.pyc文件，.class文件，.o文件，.swp文件的等，我们可以在项目根目录下创建一个名为 .gitignore的文件，列出要忽略的文件。git默认会读取项目目录下的.gitignore文件（跟.git同目录）</p>
<div>
<div id="highlighter_772364" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">vim .gitignore</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>#git进行管理时，忽略以下文件</p>
<blockquote>
<p>c/file_operator/*.swp<br />*.o</p>

</blockquote>
<p>所有空行或者以注释符号 # 开头的行都会被 Git 忽略，以上设置忽略所有.o文件，同时忽略c/file_operator/目录下的所有.swp文件<br />另外，还可以在配置项中通过core.excludesfile来指定ignore文件。</p>
<div>
<div id="highlighter_146370" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git config --system core.excludesfile ~/.gitignore_system</code></div>
<div class="line number2 index1 alt1"><code class="shell plain">git config --global core.excludesfile ~/.gitignore_global</code></div>
<div class="line number3 index2 alt2"><code class="shell plain">git config core.excludesfile .gitignore_local</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>注意：</p>
<blockquote>
<p>git config &ndash;system 设置系统配置<br />git config &ndash;global 设置用户配置<br />git config &nbsp;设置项目配置</p>

</blockquote>
<p>&nbsp;</p>
<h4>6.提交更新</h4>
<p>现在把暂存区域中的文件提交到仓库，每次准备提交之前，运行git status看看需要提交的文件是不是都已经暂存了。</p>
<div>
<div id="highlighter_345218" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git commit -m &ldquo;注释&rdquo;</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<blockquote>
<p>[master (root-commit) 264c7c4] cc<br />59 files changed, 1266 insertions(+), 0 deletions(-)<br />create mode 100755 c/file_operator/file_cp<br />create mode 100755 c/file_operator/file_cp.c<br />create mode 100755 c/file_operator/file_create<br />create mode 100755 c/file_operator/file_create.c<br />&hellip;..</p>

</blockquote>
<p>提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（&nbsp;264c7c4），以及在本次提交中，有多少文件修订过，多少行添改和删改过.<br />ps：在提交的时候，给&nbsp;git commit&nbsp;加上-a&nbsp;选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过&nbsp;git add&nbsp;步骤：git commit -a -m &lsquo;xxxx&rsquo;</p>
<h4>7. 移动文件</h4>
<div>
<div id="highlighter_762239" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git </code><code class="shell functions">mv</code> <code class="shell plain">test1.c test2.c</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>相当于执行了</p>
<div>
<div id="highlighter_573616" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell functions">mv</code> <code class="shell plain">test1.c test2.c</code></div>
<div class="line number2 index1 alt1"><code class="shell plain">git </code><code class="shell functions">rm</code> <code class="shell plain">test1.c</code></div>
<div class="line number3 index2 alt2"><code class="shell plain">git add test2.c</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>&nbsp;</p>
<h4>8.修改最后一次提交</h4>
<p>有些时候我们执行git commit -m &ldquo;cc&rdquo; 执行后，发现还有文件没有添加到暂存区，想撤销刚才的提交操作，可以使用git commit &ndash;amend修改最后一次提交，重新提交，否则就需要多一次提交。<br />如：</p>
<div>
<div id="highlighter_352621" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git commit -m </code><code class="shell string">'cc'</code></div>
<div class="line number2 index1 alt1"><code class="shell plain">git add forgotten_file</code></div>
<div class="line number3 index2 alt2"><code class="shell plain">git commit --amend</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p>&nbsp;</p>
<h4>9.浏览更新历史</h4>
<div>
<div id="highlighter_110939" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git log</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<blockquote>
<p>commit 264c7c4c56aa398123015da290b7d710d6560cb4<br />Author: alexzhou<br />Date: &nbsp; Sun Jun 17 20:14:42 2012 +0800</p>
<p>cc</p>

</blockquote>
<p>git log可以指定输出格式，具体可以参考网上其它资料</p>
<p>如：列出user.py的所有改动历史，每条记录显示在一行</p>
<div>
<div id="highlighter_868955" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git log --pretty=oneline user.py</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>查看具体的某次改动</p>
<div>
<div id="highlighter_696110" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git show 哈希值</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>&nbsp;</p>
<h4>10. 恢复单个文件历史版本</h4>
<p>查看文件历史记录：git log test.py<br />得到历史版本号，恢复该文件：<br />git reset 2e17053b4f5da3b378d6155a174523588d104338 test.py</p>
<p>&nbsp;</p>
<h4>11. 从服务端接收数据</h4>
<div>
<div id="highlighter_198535" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git pull</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>
<p>&nbsp;</p>
<h4>12.&nbsp;推送数据到服务端</h4>
<p>执行git commit后，只是把更新提交到本地仓库，执行git push后才把本地修改更新到服务端</p>
<div>
<div id="highlighter_855951" class="syntaxhighlighter  shell">
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>

</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="shell plain">git push</code></div>

</div>

</td>

</tr>

</tbody>

</table>

</div>

</div>]]></description></item><item><title>django调试</title><link>http://www.cnblogs.com/isohybrid/archive/2013/08/07/django.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 07 Aug 2013 05:22:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/08/07/django.html</guid><description><![CDATA[<p>安装pip的方法：</p>
<h4>Install pip and virtualenv for Ubuntu 10.10 Maverick and newer</h4>
<div class="console">
<div class="highlight">
<pre><span class="gp">$</span> sudo apt-get install python-pip python-dev build-essential 
<span class="gp">$</span> sudo pip install --upgrade pip 
$ sudo pip install django-pdb<br /><br /><br /></pre>
</div>
</div>
<p><span>之前在pycharm中可以直接下断点，运行调试，可以进行单步跟踪，步入，跳出等等操作。现在换到vim中了怎么来调试我们的python程序呢。</span><br /><br /><span>答案是用pdb，这是python内置的一个模块，具体看参考这里：http://docs.python.org/2/library/pdb.html</span><br /><br /><span>具体怎么使用呢，举个简单的例子吧。</span><br /><br /><span>一个简单的场景，我想跟踪下django的启动过程，那就用pdb来演示下。</span><br /><br /><span>当然，你得现有个django的项目，在你的manage.py的程序入口处，也就是if __name__ == '__main__':下面插一句代码：</span></p>
<pre><br />import pdb;pdb.set_trace()</pre>
<p><br /><br /><span>然后你就运行你的程序吧，python manage.py runserver</span></p>]]></description></item><item><title>删除某个时间之前的某些文件：date_marker</title><link>http://www.cnblogs.com/isohybrid/archive/2013/07/09/date_marker.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Tue, 09 Jul 2013 04:49:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/07/09/date_marker.html</guid><description><![CDATA[<p>删除某个时间之前的某些文件：<br /><br />1。创建时间戳<br />&nbsp;&nbsp; touch -d "3 Feb 2009 00:00:00" date_marker<br />2。查找某个时间点之前的文件--&gt;grep 某些文件--&gt;执行rm<br />&nbsp;&nbsp; find . /! -cnewer date_marker | grep zsdownload |xargs rm</p>
<p>&nbsp;</p>
<p>3.查找某个时间点之后的某些文件：<br />&nbsp; find . -cnewer date_marker | grep zsdownload</p>
<p>&nbsp;</p>
<p>4.列出时间点之后的文件：</p>
<p>&nbsp;find . -cnewer date_marker | xargs ls -ltr</p>
<p>&nbsp;find . -cnewer date_marker -exec ls -ltr '{}' /;</p>
<p>&nbsp;</p>
<p><code>5. 今天之前的2天内的文件列表<br />find . -mtime -2 -type f -exec ls -l '{}' /;&nbsp;</code> </p>
<pre><span style="font-size: small;"><code><span style="color: black;" lang="EN-US"><span style="font-size: x-small;"><br />

</span></span></code></span></pre>]]></description></item><item><title>網絡流量監控</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/31/iftop.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 31 May 2013 04:59:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/31/iftop.html</guid><description><![CDATA[<p>在工作中发现，经常因为业务的原因，需要即时了解某台服务器网卡的流量，虽然公司也部署了cacti软件，但cacti是五分钟统计的，没有即时性，并且有时候打开监控页面不方便，个人喜欢随手在某台服务器上输入一个命令，查看网卡即时流量。百度了一下，发现有这么几种方法，现对此类软件进行了一个总结。<br /><strong><span><br />一、iptraf软件</span></strong><br />&nbsp;&nbsp; rhel的iso里有包含，我公司的系统，并没有默认安装，它功能强大，可以按照协议，网卡等进行分析。<br /><span>1.1 iptraf安装</span><br />源码安装<br />wget ftp://iptraf.seul.org/pub/iptraf/iptraf-3.0.0.tar.gz<br />tar zxvf iptraf-3.0.0.tar.gz<br />cd iptraf-3.0.0<br />./Setup<br />yum方式安装<br />yum install -y iptraf<br /><span>1.2 iptraf使用</span><br />[root@kaifa opt]# iptraf<br />按任意键继续<br /><a href="http://img1.51cto.com/attachment/201203/134124722.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134124722.jpg" alt="" border="0" /></a><br />第一项：IP流量监控<br />第二项：常规查看网卡流量状态。只查看各网卡的总流量<br />第三项：详细查看网卡流量状态。比如按TCP，UDP，ARP等协议查看<br /><a href="http://img1.51cto.com/attachment/201203/134140353.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134140353.jpg" alt="" border="0" /></a><br />选all interfaces，查看所有网卡接口<br />&nbsp;<a href="http://img1.51cto.com/attachment/201203/134156623.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134156623.jpg" alt="" border="0" /></a></p>
<p>&nbsp;&nbsp; 界面分上下两部分，上部分可详细显示哪个与之相连的IP，发了多少包，即时流量是多少，下部分，可以显示udp等信息。<br /><a href="http://img1.51cto.com/attachment/201203/134218744.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134218744.jpg" alt="" border="0" /></a></p>
<p>按Q退出监控界面，然后选择&ldquo;Exit&rdquo;退出iptraf。<br /><br /><span><strong>第二、nload软件</strong></span><br />&nbsp;&nbsp;&nbsp; rhel iso不带，需要去第三方网站下载源码包。功能相对单一，只能查看总的流量，不能像上款的iptraf那样，可看总流量，可细分查看其它协议点的流量。nload默认分为上下两块，每部分都有当前流量（Curr），平均流量(Min)，最大流量(Max)，总流量(Ttl)，看起来还是比较直观的。<br /><span>2.1 nload安装</span><br />wget http://www.roland-riegel.de/nload/nload-0.7.2.tar.gz<br />tar zxvf nload-0.7.2.tar.gz<br />cd nload-0.7.2<br />./configure &ndash;prefix=/usr/local/nload<br />make<br />make install<br /><span>2.2 nload使用</span><br />[root@kaifa opt]# /usr/local/nload/bin/nload eth0<br />&nbsp;<br /><a href="http://img1.51cto.com/attachment/201203/134258487.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134258487.jpg" alt="" border="0" /></a></p>
<p><br /><span><strong>第三、ifstat软件</strong></span><br />&nbsp;&nbsp;&nbsp; rhel iso不自带，虽然到第三方网站下载源码包，编译安装。这个软件还有windows版，它可以报告网卡接口流量状态，能查看网卡的流出和流入的字节，是按每秒生产一次数据。<br /><span>3.1 ifstat安装</span><br />wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gz<br />tar -zxvf ifstat-1.1.tar.gz&nbsp;<br />cd ifstat-1.1<br />./configure&nbsp; --prefix=/usr/local/ifstat<br />make&nbsp;<br />make&nbsp; install<br /><span>3.2 ifstat使用</span><br />&nbsp;<a href="http://img1.51cto.com/attachment/201203/134450854.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134450854.jpg" alt="" border="0" /></a></p>
<p><span>3.3相关参数</span><br />-l&nbsp;&nbsp;&nbsp; 监测环路网络接口（lo）。缺省情况下，ifstat监测活动的所有非环路网络接口。经使用发现，加上-l参数能监测所有的网络接口的信息，而不是只监测 lo的接口信息，也就是说，加上-l参数比不加-l参数会多一个lo接口的状态信息。<br />-a&nbsp; 监测能检测到的所有网络接口的状态信息。使用发现，比加上-l参数还多一个plip0的接口信息，搜索一下发现这是并口（网络设备中有一 个叫PLIP (Parallel Line Internet Protocol). 它提供了并口...）<br />-z&nbsp; 隐藏流量是无的接口，例如那些接口虽然启动了但是未用的<br />-i&nbsp; 指定要监测的接口,后面跟网络接口名<br />-s&nbsp; 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过SNMP查询一个远程主机<br />-h 显示简短的帮助信息<br />-n 关闭显示周期性出现的头部信息（也就是说，不加-n参数运行ifstat时最顶部会出现网络接口的名称，当一屏显示不下时，会再一次出现接口的名称，提示 我们显示的流量信息具体是哪个网络接口的。加上-n参数把周期性的显示接口名称关闭，只显示一次）<br />-t 在每一行的开头加一个时间 戳（能告诉我们具体的时间）<br />-T 报告所有监测接口的全部带宽（最后一列有个total，显示所有的接口的in流量和所有接口的out流量，简单的把所有接口的in流量相加,out流量相 加）<br />-w&nbsp; 用指定的列宽，而不是为了适应接口名称的长度而去自动放大列宽<br />-W 如果内容比终端窗口的宽度还要宽就自动换行<br />-S 在同一行保持状态更新（不滚动不换行）注：如果不喜欢屏幕滚动则此项非常方便，与bmon的显示方式类似<br />-b 用kbits/s显示带宽而不是kbytes/s(bit和byte有何区别应该都知道吧)<br />-q 安静模式，警告信息不出现<br />-v 显示版本信息<br />-d 指定一个驱动来收集状态信息<br /><strong><span><br />第四、sar软件</span></strong><br />&nbsp;&nbsp;&nbsp; 这个工具RHEL iso里包含，它是一个优秀的性能监控工具，不仅仅监控网络，它可以显示cpu，运行队列，磁盘i/o，分页(交换区)，内存，CPU中断等性能数据。Sar命令在sysstat包中，我公司系统没有安装此包，所以要安装它，才有sar命令。<br /><br /><span>4.1 sar安装</span><br />Yum install sysstat<br /><span>4.2 sar使用</span><br />&nbsp;<a href="http://img1.51cto.com/attachment/201203/134336395.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134336395.jpg" alt="" border="0" /></a></p>
<p>命令后面 5 2 意思是：每5秒钟取一次值，取2次。<br />IFACE：LAN接口<br />rxpck/s：每秒钟接收的数据包<br />txpck/s：每秒钟发送的数据包<br />rxbyt/s：每秒钟接收的字节数<br />txbyt/s：每秒钟发送的字节数<br />rxcmp/s：每秒钟接收的压缩数据包<br />txcmp/s：每秒钟发送的压缩数据包<br />rxmcst/s：每秒钟接收的多播数据包<br /><br /><strong><span>第五、iftop软件</span></strong><br />&nbsp;&nbsp;&nbsp; RHEL iso不自带，iftop可以用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等<br /><br /><span>5.1 iftop安装</span><br />wget http://www.ex-parrot.com/pdw/iftop/download/iftop-0.17.tar.gz<br />tar zxvf iftop-0.17.tar.gz<br />cd iftop-0.17<br />./configure &ndash;prefix=/usr/local/iftop<br />make<br />make install<br /><span>5.2 iftop使用</span><br />[root@nfstest opt]# /usr/local/iftop/sbin/iftop<br />&nbsp;<a href="http://img1.51cto.com/attachment/201203/134356475.jpg" target="_blank"><img src="http://img1.51cto.com/attachment/201203/134356475.jpg" alt="" border="0" /></a></p>
<p><span>5.3、界面相关说明</span><br />界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。<br />中间的&lt;= =&gt;这两个左右箭头，表示的是流量的方向。<br />TX：发送流量<br />RX：接收流量<br />TOTAL：总流量<br />Cumm：运行iftop到目前时间的总流量<br />peak：流量峰值<br />rates：分别表示过去 2s 10s 40s 的平均流量<br /><span>5.4、相关参数</span><br />常用的参数<br />-i设定监测的网卡，如：# iftop -i eth1<br />-B 以bytes为单位显示流量(默认是bits)，如：# iftop -B<br />-n使host信息默认直接都显示IP，如：# iftop -n<br />-N使端口信息默认直接都显示端口号，如: # iftop -N<br />-F显示特定网段的进出流量，如# iftop -F 10.10.1.0/24或# iftop -F 10.10.1.0/255.255.255.0<br />-h（display this message），帮助，显示参数信息<br />-p使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息;<br />-b使流量图形条默认就显示;<br />-f这个暂时还不太会用，过滤计算包用的;<br />-P使host信息及端口信息默认就都显示;<br />-m设置界面最上边的刻度的最大值，刻度分五个大段显示，例：# iftop -m 100M</p>
<p>本文出自 &ldquo;<a href="http://369369.blog.51cto.com/">系统网络运维</a>&rdquo; 博客，请务必保留此出处<a href="http://369369.blog.51cto.com/319630/805726">http://369369.blog.51cto.com/319630/805726</a></p>]]></description></item><item><title>IP命令</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/29/ip.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 29 May 2013 08:02:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/29/ip.html</guid><description><![CDATA[<p><span><a href="http://doc.linuxpk.com/40384.html">http://doc.linuxpk.com/40384.html</a></span></p>
<p>&nbsp;</p>
<p><span>ip是iproute2软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route等。这个手册将分章节介绍ip命令及其选项。本文的原文在http://defiant.coinet.com/iproute2/ip-cref/(2002-10-15 18:40:46)</span><br /><br /><span>作者：Alexey N.Kuznetsov</span><br /><br /><span>编译：nixe0n</span><br /><br /><span>1.关于这篇文档</span><br /><br /><span>2.ip命令的语法</span><br /><br /><span>3.ip的错误信息</span><br /><br /><span>4.ip link--配置网络设备</span><br /><br /><span>4.1.ip link set--改变设备的属性</span><br /><br /><span>4.2.ip link show--显示设备属性</span><br /><br /><span>5.ip address--协议地址管理</span><br /><br /><span>5.1.ip address add--添加一个新的协议地址</span><br /><br /><span>5.2.ip address delete--删除一个协议地址</span><br /><br /><span>5.3.ip address show--显示协议地址</span><br /><br /><span>5.4.ip address flush--清除协议地址</span><br /><br /><span>6.ip neighbour--neighbour/arp表管理命令</span><br /><br /><span>6.1.ip neighbour add -- 添加一个新的邻接条目</span><br /><br /><span>ip neighbour change--修改一个现有的条目</span><br /><br /><span>ip neighbour replace--替换一个已有的条目</span><br /><br /><span>6.2.ip neighbour delete--删除一个邻接条目</span><br /><br /><span>6.3.ip neighbour show--显示网络邻居的信息</span><br /><br /><span>6.4.ip neighbour flush--清除邻接条目</span><br /><br /><span>1.关于这篇文档</span><br /><br /><span>ip是iproute2软件包里面的一个强大的网络配置工具，本文将分章节介绍ip命令及其选项。为了便于理解，作者在本文中列举了很多示例。但是，正如作者所说，这不是一个教程，而是一个使用手册。</span><br /><br /><span>2.ip命令的语法</span><br /><br /><span>ip命令的用法如下：</span><br /><br /><span>ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]</span><br /><br /><span>其中，OPTIONS是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式。目前，ip支持如下选项：</span><br /><br /><span>-V,-Version 打印ip的版本并退出。</span><br /><br /><span>-s,-stats,-statistics 输出更为详尽的信息。如果这个选项出现两次或者多次，输出的信息将更为详尽。</span><br /><br /><span>-f,-family 这个选项后面接协议种类，包括：inet、inet6或者link，强调使用的协议种类。如果没有足够的信息告诉ip使用的协议种类，ip就会使用默认值inet或者any。link比较特殊，它表示不涉及任何网络协议。</span><br /><br /><span>-4 是-family inet的简写。</span><br /><br /><span>-6 是-family inet6的简写。</span><br /><br /><span>-0 是-family link的简写。</span><br /><br /><span>-o,-oneline 对每行记录都使用单行输出，回行用字符代替。如果你需要使用wc、grep等工具处理ip的输出，会用到这个选项。</span><br /><br /><span>-r,-resolve 查询域名解析系统，用获得的主机名代替主机IP地址。</span><br /><br /><span>OBJECT是你要管理或者获取信息的对象。目前ip认识的对象包括：</span><br /><br /><span>link 网络设备</span><br /><br /><span>address 一个设备的协议（IP或者IPV6）地址</span><br /><br /><span>neighbour ARP或者NDISC缓冲区条目</span><br /><br /><span>route 路由表条目</span><br /><br /><span>rule 路由策略数据库中的规则</span><br /><br /><span>maddress 多播地址</span><br /><br /><span>mroute 多播路由缓冲区条目</span><br /><br /><span>tunnel IP上的通道</span><br /><br /><span>另外，所有的对象名都可以简写，例如：address可以简写为addr，甚至是a。</span><br /><br /><span>COMMAND设置针对指定对象执行的操作，它和对象的类型有关。一般情况下，ip支持对象的增加(add)、删除(delete)和展示(show或者list)。有些对象不支持所有这些操作，或者有其它的一些命令。对于所有的对象，用户可以使用help命令获得帮助。这个命令会列出这个对象支持的命令和参数的语法。如果没有指定对象的操作命令，ip会使用默认的命令。一般情况下，默认命令是list，如果对象不能列出，就会执行help命令。</span><br /><br /><span>ARGUMENTS是命令的一些参数，它们倚赖于对象和命令。ip支持两种类型的参数：flag和parameter。flag由一个关键词组成；parameter由一个关键词加一个数值组成。为了方便，每个命令都有一个可以忽略的默认参数。例如，参数dev是ip link命令的默认参数，因此ip link ls eth0等于ip link ls dev eth0。我们将在后面的章节详细介绍每个命令的使用，命令的默认参数将使用default标出。</span><br /><br /><span>几乎所有的关键词都可以简写为前几个字母。在交互工作时，简写的方式非常方便，但是我们不建议在脚本中使用简写形式。另外，在讲述过程中，所有的"官方"简写方式都会在文章中列出。</span><br /><br /><span>3.ip的错误信息</span><br /><br /><span>由于以下原因，ip可能会操作失败：</span><br /><br /><span>命令行语法错误：一个未知的关键词(an unknown keyword)；错误的IP地址格式(incorrectly formated IP address)。在这种情况下，ip会打印出错误信息然后退出，在错误信息中会包含失败的原因。有时ip也会打印帮助信息。参数不能通过一致性校验。由于用户没有提供足够的信息，造成ip无法从参数中编译出内核请求。内核返回某些系统调用的错误。ip使用perror(3)输出错误信息，因此输出的错误信息包含一段注释以及系统调用号。内核返回RTNETLINK请求错误。这类错误信息以"RTNETLIK answers"开头。</span><br /><br /><span>ip的所有操作都是原子操作。例如，如果ip执行失败，它不会系统的任何东西，ip link command例外，它会修改某些设备参数。</span><br /><br /><span>我们无法列出所有的错误信息，尤其是语法错误。不过，错误信息的意思都非常明确。下面，我们列举一些经常出现的错误信息：</span><br /><br /><span>内核不支持netlink(netlink用于在内核模块和用户之间传递信息)，会出现以下错误信息：Cannot open netlink socket: Invalid value 内核不支持RTNETLINK，会出现以下错误信息：Cannot talk to rtnetlink: Connect refusedCannot send dump request: Connect refused 如果在编译内核时没有配置CONFIG_IP_MULTIPLE_TABLES选项。在使用ip规则时会出现和下面的信息类似的错误信息：kuznet@kaise $ ip rule listRTNETLINK error: Invalid argumentdump terminated</span><br /><br /><span>4.ip link--配置网络设备</span><br /><br /><span>对象 link由网络设备，对应的命令显示以及设备的状态变化组成。</span><br /><br /><span>命令 set和show(或者list)</span><br /><br /><span>4.1.ip link set--改变设备的属性</span><br /><br /><span>缩写：set、s</span><br /><br /><span>参数：</span><br /><br /><span>dev NAME(default) 指定进行操作的网络设备</span><br /><br /><span>up/down 起动／关闭设备。</span><br /><br /><span>例如：ip link set dev eth0 up</span><br /><br /><span>arp on/off 改变网络设备的NOARP选项。</span><br /><br /><span>如果设备处于UP状态，不允许进行这个操作。不过，内核和ip都不会对在这种情况下的这个操作进行检查。在设备处于运行状态下改变这个选项会造成无法预料的后果。</span><br /><br /><span>multicast on/off 改变网络设备的MULTICAST选项。</span><br /><br /><span>dynamic on/off 改变网络设备的DYNAMIC选项。</span><br /><br /><span>name NAME 把设备的名字改为NAME(例如：eth0)。如果设备处于运行状态或者已经配置了地址，建议不要进行这个操作。</span><br /><br /><span>txqueuelen NUMBER或者txqlen NUMBER 改变设备传输队列的长度。</span><br /><br /><span>例如：ip link set dev eth0 txqueuelen 100</span><br /><br /><span>mtu NUMBER 改变网络设备MTU(最大传输单元)的值。</span><br /><br /><span>例如：ip link set dev eth0 mtu 1500</span><br /><br /><span>address LLADDRESS 修改网络设备的MAC地址。</span><br /><br /><span>例如：ip link set dev eth0 address 00:01:4f:00:15:f1</span><br /><br /><span>broadcat LLADDRESS或者brd LLADDRESS 修改数据链路层广播地址。</span><br /><br /><span>注意：对于大多数的网络设备(例如：以太网)，修改链路层广播地址会对网络造成破坏。因此，如果对此没有很深的理解，最好不要使用这个操作。</span><br /><br /><span>peer LLADDRESS 当使用点对点连接时，使用这个操作可以修改对端的数据链路层地址。</span><br /><br /><span>注意：ip不能修改PROMISC或者ALLMULTI选项。这两个选项已经比较陈旧，而且也不应该随便修改。</span><br /><br /><span>注意：如果同时修改多个参数，任何一个修改失败，ip都会立即取消操作。这种情况可能使系统进入无法预料的状态。为了避免出现这种情况，尽量不要使用ip link set同时修改多个参数，例如：ip link set dev eth0 mtu 1500 txqueuelen 100。</span><br /><br /><span>4.2.ip link show--显示设备属性</span><br /><br /><span>缩写：show、list、lst、sh、ls、l</span><br /><br /><span>参数</span><br /><br /><span>dev NAME(default) NAME指定网络设备名称，例如：eth0。如果省略了这个参数，所有的设备属性就都会被列出。</span><br /><br /><span>up 只显示处于活动状态网络接口的信息。</span><br /><br /><span>输出格式</span><br /><br /><span>kuznet@alisa:~ $ ip link ls eth03: eth0: mtu 1500 qdisc cbq qlen 100 link/ether 00:a0:cc:66:18:78 brd ff:ff:ff:ff:ff:ff:kuznet@alisa:~ $ ip link ls sit05: sit0@NOME: mtu 1480 qdisc noqueue link/sit 0.0.0.0 brd 0.0.0.0kuznet@alisa:~ $ ip link ls dummy2: dummy: mtu 1500 qdisc noop link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ffkuznet@alisa:~ $</span><br /><br /><span>在显示的信息中，每个引号之前的数字是一个接口索引，用于识别网络接口。这个数字后面是网络接口的名字(例如：eth0、dummy等)，它也和网络接口一一对应。不过，在某些情况下，例如：驱动模块被卸载，对应的接口名就会从列表中消失，而其它新创建的接口就会使用相同的名字。系统管理员可以ip link set name修改接口的名字。</span><br /><br /><span>接口名可以是别的,或者??#199;@NONE。这意味着这个设备被绑定到其它的设备，例如数据包被发送到这个设备，由这个设备封装，并从master设备发出。如果设备名字是NONE</span></p>
<p><span><span>7.路由表管理</span><br /><br /><span>7.1.缩写</span><br /><br /><span>route、ro、r</span><br /><br /><span>7.2.对象</span><br /><br /><span>路由条目保存在内核的路由表中，它们包含寻找到其它网络节点的路径信息。路由表条目都包括一对网络地址/掩码长度以及可选的TOS值等信息。如果数据包目的地址位于属于路由条目的的范围，以及路由的TOS等于0或者等于数据包的TOS，它就匹配路由条目。如果一个数据包匹配多个路由条目，系统内核将按照以下规则决定选择哪个路由：</span><br /><br /><span>注：作者在文中把地址被子网掩码屏蔽后的部分/掩码长度这种表达方式叫做前缀（prefix）。例如：10/8表示网络10.0.0.0，子网掩码长度是8位；10.1/16表示网络10.1.0.0，子网掩码长度是16位；</span><br /><br /><span>范围最小的优先匹配，较大的放弃；路由TOS等于数据包TOS的匹配，不等于的放弃；如果经过上面两步的选择，还有数个路由，就选择优先值最高的路由；如果还有数个路由可供选择，就重复进行第一步。</span><br /><br /><span>为了简化，我们使用{prefix,tos,preference}来标记每个路由。</span><br /><br /><span>7.3.路由属性</span><br /><br /><span>路由条目提供IP数据包投递所需的路由信息、数据(例如：输出设备、下一跳的路由器)和一些可选属性(例如：路径的最大传输单元MTU或者源地址等)。这些属性将在后面的章节详细介绍。</span><br /><br /><span>7.4.路由类型</span><br /><br /><span>路由的设置以及其它的可选属性都依赖于路由类型。最重要的路由类型是unicast路由，这种类型的路由表示到另外主机的真实路由。一般情况下，通常的路由表只有这种类型的路由条目。不过，还存在其它类型的路由，使用的语法也不相同。Linux-2.2理解以下几种类型的路由：</span><br /><br /><span>unicast 这种类型的路由描述到目的地址的真实路径。</span><br /><br /><span>unreachable 这些目的地址是不可达的。如果发过去的数据包都被丢弃并且收到ICMP信息host unreachable，目的地址就会被标记为不可达。在这种情况下，本地发送者将返回EHOSTUNREACH错误。</span><br /><br /><span>blackhole 这些目的地址不可达，而且发过去的数据包都被丢弃。在这种情况下，本地发送者将返回EINVAL错误。</span><br /><br /><span>prohibit 这些路由是不可达的。发过去的数据包都被丢弃，而且产生ICMP信息communication administratively prohibited 。本地发送者会返回EACCESS错误。</span><br /><br /><span>local 目的地址被分配给本机。数据包通过回环被投递到本地。</span><br /><br /><span>broadcast 目的地址是广播地址，数据包作为链路广播发送。</span><br /><br /><span>throw 和策略规则(policy rule)一块使用的控制路由。如果选择了这种路由，就会认为没有发现路由，在这个表中的查询就会被终止。没有找到策略路由就相当于在路由表中没有找到路由，数据包会被丢弃，并产生ICMP信息net unreachable。本地发送者会返回ENETUNREACH错误。</span><br /><br /><span>nat 特定的NAT路由。目标地址属于哑地址（或者称为外部地址），在转发前需要进行地址转换。</span><br /><br /><span>anycast 目标是anycast地址，被分配给本机。这类地址和本地地址大同小异，不同的是这类地址不能用于任何数据包的源地址。</span><br /><br /><span>multicast 使用多播路由。在普通的路由表中，这种路由并不存在。</span><br /><br /><span>7.5.路由表</span><br /><br /><span>从Linux-2.2开始，内核把路由归纳到许多路由表中，这些表都进行了编号，编号数字的范围是1到255。另外，为了方便，还可以在/etc/iproute2/rt_tables中为路由表命名。默认情况下，所有的路由都会被插入到表main(编号254)中。在进行路由查询时，内核只使用路由表main。</span><br /><br /><span>实际上，还有另外一个路由表也一直存在，这个表是不可见的，而且极为重要。这就是表local。这个表保存本地和广播路由。内核会自动维护这个路由表，通常系统管理员没有必要对它进行修改，甚至不必看到。</span><br /><br /><span>在使用策略路由（policy routing）时，我们将使用多个路由。在这种情况下，表识别符有很多参数，因此需要使用{prefix,tos,preference}的形式唯一地识别每个路由。</span><br /><br /><span>7.6.ip route add -- 添加新路由</span><br /><br /><span>ip route change -- 修改路由</span><br /><br /><span>ip route replace -- 替换已有的路由</span><br /><br /><span>缩写：add、a；change、chg；replace、repl</span><br /><br /><span>参数</span><br /><br /><span>to PREFIX或者to TYPE PREFIX(default) 路由的目标前缀(prefix)。如果TYPE被忽略，ip命令就会使用默认的类型unicast。其它的类型在上一节都有介绍。PREFIX是一个IP或者IPv6地址，也可以跟着一个斜杠和掩码长度。如果没有掩码长度，ip命令就假定是一个单一ip地址。另外，还有一个特殊的PREFIX--default（缺省路由），它等于IPv4的0/0，或者IPv6的::/0。</span><br /><br /><span>tos TOS 或者defield TOS 定义服务类型关键词。在进行路由匹配时，内核首先比较数据包的TOS和route的TOS，如果没有和数据包TOS相同的路由，还可以选择TOS等于0的路由。TOS或者是一个十六进制的数字，或者是一个由/etc/iproute2/rt_dsfield文件定义的识别符。</span><br /><br /><span>metric NUMBER或者preference NUMBER 定义路由的优先值，NUMBER时一个任意的32位数字。</span><br /><br /><span>table TABLEID 路由要加入的表。TABLEID或者是一个数字或者是/etc/iproute2/rt_tables文件定义的一个字符串。如果没有这个参数，ip命令就会把路由加入到表main中，本地(local)、广播(broadcast)和网络地址转换(nat)路由除外。在默认情况下，这些类型的路由都会被加入表local中。</span><br /><br /><span>dev NAME 输出设备的名字</span><br /><br /><span>via ADDRESS 指定下一跳路由器的地址。实际上，这个域的可靠性取决于路由类型。对于通常的unicast路由，它或者是真正的下一跳路由器地址，或者如果它是BSD兼容模式安装的直接路由，它可以是一个网络接口的本地地址。对于NAT路由，它是转换后的地址。</span><br /><br /><span>src ADDRESS 在向目的prefix发送数据包时选择的源地址。</span><br /><br /><span>realm REALMID 指定路由分配的realm。REALM可以是一个数字或者/etc/iproute2/rt_realms文件定义的一个字符串。有关realm更为详细的信息请看附录（Route realms and policy propagation, rtacct）。</span><br /><br /><span>mtu MTU或者mtu lock MTU 设置到达目的路径的最大传输单元(MTU)。如果没有使用修饰符lock，内核会通过路径最大传输单元发现（Path MTU Discovery）机制更新MTU；如果使用了修饰符lock，内核就不会测试路径的最大传输单元。在这种情况下，发出的所有IPv4数据包DF域都会被设置为0（允许分片），对于IPv6数据包也允许分片。</span><br /><br /><span>window NUMBER 设置到目的地址TCP连接的最大窗口值，以字节为单位。使用这个参数可以限制对端发送数据的速率。</span><br /><br /><span>rtt NUMBER 估算初始往返时间（Round Trip Time）</span><br /><br /><span>rttvar NUMBER 估算初始往返时间偏差(RTT variance)</span><br /><br /><span>ssthresh NUMBER 估算慢启动阀值(slow start threshould)</span><br /><br /><span>cwnd NUMBER 把拥挤窗口(congestion window)值锁定为NUMBER。如果没有lock标记，这个值会被忽略。</span><br /><br /><span>advmss NUMBER 设置在建立TCP连接时，向目的地址声明的最大报文段大小(Maximal Segment Size,MSS)。如果没有设置，Linux内核会使用计算第一跳的最大传输单元得到的数值。</span><br /><br /><span>nexthop NEXTHOP 设置多路径路由的下一跳地址。NEXTHOP比较复杂，它的语法和以下高层参数类似：</span><br /><br /><span>via ADDRESS--表示下一跳路由器；dev NAME--表示输出设备；weight NUMBER--在多路由路径中，这个元素的权重。表示相对带宽或者服务质量。</span><br /><br /><span>scope SCOPE_VAL 路由前缀(prefix)覆盖的范围。SCOPE_VAL可以是一个数字，也可以是/etc/iproute2/rt_scope文件定义的一个字符串。如果没有这个参数，ip命令就会根据具体情况猜测：对于经过网关的unicast路由，就设置为global；对于直连的unicast路由和广播路由，就设置为link；对于本地路由，就设置为host。</span><br /><br /><span>protocol RTPROTO 本条路由得路由协议识别符。RTPROTO可以是一个数字，也可以是/etc/iproute2/rt_protos文件定义的一个字符串。如果使用时没有提供这个参数，ip命令就使用默认值boot(也就是说，ip命令认为添加路由的人不知道自己做了些什么)。有些协议值有其固定的解释：</span><br /><br /><span>redirect--路由是由ICMP重定向加入的；kernel--路由是由内核在自动配置期间加入的；boot--路由是启动过程中加入的。如果一个路由监控程序将要启动，这些路由都会被清除；static--为了覆盖动态路由，由系统管理员手工添加的路由。路由监控程序也会优先考虑这类路由，甚至可能通告给其对端；ra--路由是通过路由发现协议加入的(Router Discovery Protocol)。</span><br /><br /><span>其它的值没有保留，系统管理员可以自由分配(或者不分配)给协议标记。至少，路由监控程序应该注意对一些唯一协议值的设置，这些协议值在rtnetlink.h文件或者rt_protos数据库中分配。</span><br /><br /><span>onlink 假装和下一跳路由器是直接相连的，即使它没有匹配任何接口前缀(prefix)。</span><br /><br /><span>equalize 允许把数据包随机从多个路由发出。如果没有这个路由修饰符，内核就会冻结下一跳路由的地址。</span><br /><br /><span>示例</span><br /><br /><span>设置到网络10.0.0/24的路由经过网关193.233.7.65ip route add 10.0.0/24 via 193.233.7.65修改到网络10.0.0/24的直接路由，使其经过设备dummyip route chg 10.0.0/24 dev dummy加入缺省多路径路由，让ppp0和ppp1分担负载(注意：scope值并非必需，它只不过是告诉内核，这个路由要经过网关而不是直连的。实际上，如果你知道远程端点的地址，使用via参数来设置就更好了)。ip route add default scope global nexthop dev ppp0 nexthop dev ppp1设置NAT路由。在转发来自192.203.80.144的数据包之前，先进行网络地址转换，把这个地址转换为193.233.7.83（回来的转换</span></span></p>
<p>&nbsp;</p>
<p><span>10.ip mroute -- 多播路由缓存管理</span><br /><br /><span>10.1.缩写</span><br /><br /><span>mroute、mr</span><br /><br /><span>10.2.对象</span><br /><br /><span>这个命令的操作对象是多播路由缓存条目，这个缓存是由一个用户空间的多播路由监控进程(例如pimd或者mrouted)建立的。</span><br /><br /><span>目前，由于受和多播路由引擎接口的限制，还不能通过ip命令修改多播路由对象，因此我们只能查看。</span><br /><br /><span>10.3.命令</span><br /><br /><span>show或者list</span><br /><br /><span>10.?畲笤TL是32netadm@amber:~ # ip tunnel add Cisco mode sit remote 192.31.7.104 local 192.203.80.1 ttl 32</span><br /><br /><span>11.4.ip tunnel show -- 列出现有的通道</span><br /><br /><span>缩写：show、list、sh、ls、l</span><br /><br /><span>参数</span><br /><br /><span>无</span><br /><br /><span>输出格式</span><br /><br /><span>kuznet@amber:~ $ ip tunnel ls CiscoCisco: ipv6/ip remote 192.31.7.104 local 192.203.80.142 ttl 32 kuznet@amber:~ $</span><br /><br /><span>输出的第一部分是通道的设备名，接着是通道模式。下面就是设置通道时的各个参数。</span><br /><br /><span>统计信息</span><br /><br /><span>kuznet@amber:~ $ ip -s tunl ls CiscoCisco: ipv6/ip remote 192.31.7.104 local 192.203.80.142 ttl 32 RX: Packets Bytes Errors CsumErrs OutOfSeq Mcasts 12566 1707516 0 0 0 0 TX: Packets Bytes Errors DeadLoop NoRoute NoBufs 13445 1879677 0 0 0 0 kuznet@amber:~ $</span><br /><br /><span>以上输出结果里面的数字和使用ip -s link show的输出是一样的，但是每个标志都是特定于通道的。</span><br /><br /><span>CsumErrs 对于打开校验和检验的GRE通道，这个数字是由于校验和错误而丢弃的数据包数量。</span><br /><br /><span>OutOfSeg 在打开顺序功能的GRE通道内，由于顺序错误而丢弃的数据包数量。</span><br /><br /><span>Mcasts 在GRE通道上接收到的多播数据包的数量。</span><br /><br /><span>DeadLoop 由于通道是回环到自己而没有传输的数据包数目。</span><br /><br /><span>NoRoute 由于到对端没有路由而没有被传输的数据包数目。</span><br /><br /><span>NoBufs 由于内核不能分配缓冲区而没有被传输的数据包数目。</span><br /><br /><span>12.ip monitor和rtmon -- 状态监视</span><br /><br /><span>ip命令可以用于连续地监视设备、地址和路由的状态。这个命令选项的格式有点不同，命令选项的名字叫做monitor，接着是操作对象：</span><br /><br /><span>ip monitor [ file FILE ] [ all | OBJECT-LIST ]</span><br /><br /><span>OBJECT-LIST是一些被监控的对象，它可以包括link、address和route。如果没有给出file参数，ip命令就打开RTNETLINK，在上面监听，并把状态的变化输出到标准输出设备。</span><br /><br /><span>如果使用了file参数，ip命令就不是在RTNETLINK上监听，而是打开由file参数指定的包含RTNETLINK信息的二进制文件，把解析的结果显示出来。这种历史文件可以有工具产生。这个工具具有和ip monitor命令的语法类似的命令行。理想的情况是，在网络配置命令起动之前运行rtmon命令(当然，你可以在任意的时间起动rtmon，它会记录从起动开始的状态变化)。你可以在起动脚本中插入以下命令行：</span><br /><br /><span>rtmon file /var/log/rtmon.log</span><br /><br /><span>如果我们执行如下命令：</span><br /><br /><span>[root@nixe0n root]ip route add dev eth0 to 61.133.4.7 via 211.99.114.65[root@nixe0n root]ip route del dev eth0 to 61.133.4.7</span><br /><br /><span>然后，我们使用ip monitor命令分析/var/log/rtmon.log会得到如下输出结果：</span><br /><br /><span>[root@nixe0n root]ip monitor file /var/log/rtmon.log rTimestamp: Wed Nov 6 20:25:54 2002 733331 us1: lo:&nbsp;</span>&lt;loopback,up&gt;mtu 16436 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0:&nbsp;&lt;broadcast,multicast,up&gt;mtu 1500 qdisc pfifo_fast link/ether 00:01:4f:00:15:f1 brd ff:ff:ff:ff:ff:ffTimestamp: Wed Nov 6 20:25:58 2002 33700 us61.133.4.7 via 211.99.114.65 dev eth0 Timestamp: Wed Nov 6 20:25:59 2002 924124 usDeleted 61.133.4.7 via 211.99.114.65 dev eth0 [root@nixe0n root]<br /><br />13.rtacct -- 路由范围和策略传播<br /><br />在使用OSPF或者BGP协议的路由器上，其路由表可能会很大。如果我们需要对其进行归类或者计算通过每条路由的数据包，就需要保留很多信息。更糟糕的是，如果我们需要区别的不止是数据包的目的地址，还要包括它们的源地址，这个任务就更为复杂了，几乎无法解决。<br /><br />对于这个问题，Cisco IOS Release 12.0 Quality of Service Solutions Configuration Guide: Configuring QoS Policy Propagation via Border Gateway Protocol提出了一个解决方案，就是把策略从路由协议迁移到转发引擎。基本上，通过BGP的Cisco策略迁移(Cisco Policy Propagation via BGP)就是基于此种方式，它使路由器保留所有和转发引擎关系紧密的RIB(Routing Information Base，路由信息库)，以便策略路由规则能够监查所有的路由属性，包括ASPATH的信息和团体(community)字符串。<br /><br />而Linux把这分为由用户空间监控维护的路由信息库(Routing Infomation Base,RIB)，和内核层的转发信息库(Forwarding Infomation Base,FIB)。<br /><br />这是我们的幸运，因为还有另外的解决方案，而这个方案允许更为灵活的策略和更为丰富的语义。<br /><br />换句话说，可以在用户空间根据路由的属性把它们归类，例如：BGP路由的ASPATH、团体(community)；OSPF路由的标记和它们的范围。而管理员手工添加路由时，也知道它们的属性。按照这个标准划分的集合(我们把它们叫做realm)数量就很少了，因此按照路由的源地址和目的地址进行完全的分类就可以管理了。<br /><br />因此，每个路由都可以被分配到一个范围(realm)中。一般这是有路由监控进程作的，不过对于静态路由，也可以使用ip route命令手工处理。<br /><br />在某些情况下（例如路由监控进程不理解realm）为了方便，漏掉的realm可以由路由策略规则补齐。<br /><br />内核使用如下算法计算每个数据包的源范围(realm)和目的范围(realm)：<br /><br />If route has a realm, destination realm of the packet is set to it. If rule has a source realm, source realm of the packet is set to it. If destination realm was not get from route and rule has destination realm, it is also set. If at least one of realms is still unknown, kernel finds reversed route to the source of the packet. If source realm is still unknown, get it from reversed route. If one of realms is still unknown, swap realms of reversed routes and apply step 2 again.<br /><br />这个过程完成后，我们就知道了数据包的源范围和目的范围。如果某些还是未知，它就会被设置为0(realm unknown)<br /><br />范围(realm)主要还是由TC(Traffic Control)的路由类别(route classifier)使用，我们可以使用路由类别把数据包分配到给不同的流量类(trafffic class)，为数据包计数，以及为它们制定调度策略。<br /><br />相对于TC，使用realm为进入的数据包计数就简单多了，但这是一个非常有用的应用。内核可以根据realm收集总结数据包统计信息。在用户空间，我们可以使用工具rtacct查看这些信息。例如：<br /><br />kuznet@amber:~ $ rtacct russiaRealm BytesTo PktsTo BytesFrom PktsFrom russia 20576778 169176 47080168 153805 kuznet@amber:~ $<br /><br />结果表示，这个路由器收到153805个来自russia地区的数据包，并且向russia转发了169176个数据包。russia范围由ASPATH(路径自治系统)在俄罗斯的路由组成。<br /><br />15.参考<br /><br />T. Narten, E. Nordmark, W. Simpson. ``Neighbor Discovery for IP Version 6 (IPv6)'', RFC-2461.S. Thomson, T. Narten. ``IPv6 Stateless Address Autoconfiguration'', RFC-2462.F. Baker. ``Requirements for IP Version 4 Routers'', RFC-1812.R. T. Braden. ``Requirements for Internet hosts -- communication layers'', RFC-1122.``Cisco IOS Release 12.0 Network Protocols Command Reference, Part 1'' and ``Cisco IOS Release 12.0 Quality of Service Solutions Configuration Guide: Configuring Policy-Based Routing'',http://www.cisco.com/univercd/cc/td/doc/product/software/ios120.A. N. Kuznetsov. ``Tunnels over IP in Linux-2.2'',在：ftp://ftp.inr.ac.ru/ip-routing/iproute2-current.tar.gz.A. N. Kuznetsov. ``TC Command Reference'',在：ftp://ftp.inr.ac.ru/ip-routing/iproute2-current.tar.gz.``Cisco IOS Release 12.0 Quality of Service Solutions Configuration Guide: Configuring QoS Policy Propagation via Border Gateway Protocol'',http://www.cisco.com/univercd/cc/td/doc/product/software/ios120.R. Droms. ``Dynamic Host Configuration Protocol.'', RFC-2131</p>]]></description></item><item><title>nginx</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/23/nginxsetting.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Thu, 23 May 2013 11:32:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/23/nginxsetting.html</guid><description><![CDATA[<p>第一步，安装nginx<br /><br />apt-get update<br />apt-get install nginx<br />即可完成安装<br /><br />启动nginx：<br />/etc/init.d/nginx start<br />然后就可以访问了，http://localhost/ ， 一切正常！如果不能访问，先不要继续，看看是什么原因，解决之后再继续。<br /><br />第二步，安装Php和mysql<br />安装php和MySQL:<br />apt-get install php5-cli php5-cgi mysql-server-5.0 php5-mysql<br /><br />第三步，安装FastCgi和配置<br />我们需要/usr/bin/spawn-fcgi这个文件，而它是属于lighttpd这个包里面的，所以我们安装lighttpd然后把它设置为开机不启动：<br /><br />apt-get install lighttpd #我们只要/usr/bin/spawn-fcgi<br />rcconf #去掉lighttpd开机自启动--------------------------------------------强烈推荐<br />修改nginx的配置文件：/etc/nginx/sites-available/default<br />修改 server_name 192.168.200.100;<br />修改index的一行修改为：<br />index index.php index.html index.htm;<br /><br />去掉下面部分的注释并修改为：<br />location ~ \.php$ {<br />fastcgi_pass&nbsp;&nbsp; 127.0.0.1:9000;<br />fastcgi_index&nbsp; index.php;<br />fastcgi_param&nbsp; SCRIPT_FILENAME /var/www/nginx-default$fastcgi_script_name;<br />include /etc/nginx/fastcgi_params;<br /><br />}</p>
<p><span>&nbsp;</span></p>
<p><span>在server{}内定义日志文件的位置和相应的格式：<br />access_log /var/log/nginx/localhost_access.log combined;</span></p>
<p>&nbsp;</p>
<p>access_log off;//表示关闭</p>
<p>&nbsp;</p>
<p><br />重新启动nginx:<br />/etc/init.d/nginx stop<br />/etc/init.d/nginx start<br /><br /><br />启动fastcgi php:<br />spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi<br /><br />&nbsp;<br />以下步骤我直接运行rcconf设置php-cgi为开机自启动即可，所以跳过<br />---------------------------------------为了让php-cgi开机自启动：<br />cd /etc/init.d<br />cp nginx php-cgi<br />vim php-cgi<br /><br />替换nginx为php-cgi<br /><br />并修改相应部分为：<br />DAEMON=/usr/bin/spawn-fcgi<br />DAEMON_OPTS="-a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi"<br />...<br />stop)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo -n "Stopping $DESC: "<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pkill -9 php-cgi<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo "$NAME."<br /><br />-------------------------------------------------<br /><br />在/var/www/nginx-default/目录下创建一个文件：&nbsp; /var/www/nginx-default/index.php<br />文件内容是：<br /><br />&lt; ?php phpinfo();?&gt;<br /><br />然后浏览器访问nginx就可以看到一切正常了</p>
<p>&nbsp;</p>
<p>------------------------------------------------------------END 安装成功</p>
<p>&nbsp;</p>
<p>配置文件目录 /etc/nginx/&nbsp;&nbsp;&nbsp; nginx.conf&nbsp;&nbsp;&nbsp;&nbsp; /sites-available/default</p>
<p>www目录 /var/www/nginx-default/</p>
<p>&nbsp;</p>
<p>启动fastcgi php:<br />spawn-fcgi -a 127.0.0.1 -p 9000 -C 10 -u www-data -f /usr/bin/php-cgi</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>日志文件：</p>
<p>localhost.access.log&nbsp; /var/log/nginx/localhost.access.log</p>
<p>access.log&nbsp; /var/log/nginx/access.log</p>
<p>error.log&nbsp;&nbsp;&nbsp; /var/log/nginx/error.log</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>---------------<strong>重定向nginx错误页面的方法</strong></p>
<p><span>error_page 404&nbsp; /404.html;</span></p>
<p><span>这个404.html保证在nginx主目录下的html目录中即可，如果需要在出现404错误后直接跳转到另外一个地址，可以直接设置如下：</span></p>
<p><span><br />error_page 404&nbsp;</span><span>http://www.***.net</span>&nbsp;<span>;</span></p>
<p><br /><span>同样的方式可以定义常见的403、500等错误。</span></p>
<p><br /><span>特别注意的是404.html文件页面大小要超过512k，不然会被ie浏览器替换为ie默认的错误页面。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>------------------------------<strong>虚拟主机配置</strong></p>
<p>server {<br />&nbsp;&nbsp;&nbsp; listen&nbsp;&nbsp; 80;<br />&nbsp;&nbsp;&nbsp;&nbsp;<strong>server_name&nbsp; localhost;</strong>&nbsp;<br />&nbsp;&nbsp;&nbsp; access_log&nbsp; /var/log/nginx/localhost.access.log;<br /><br />&nbsp;&nbsp;&nbsp; location / {<br />&nbsp;&nbsp;&nbsp; &nbsp;<strong>&nbsp;&nbsp; root&nbsp;&nbsp; /var/www/nginx-default;</strong>&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index index.php index.html index.htm;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; location /doc {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; /usr/share;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoindex on;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; allow 127.0.0.1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; deny all;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; location /images {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; /usr/share;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoindex on;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; location ~ \.php$ {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_pass&nbsp;&nbsp; 127.0.0.1:9000;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_index&nbsp; index.php;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_param&nbsp; SCRIPT_FILENAME&nbsp; /var/www/nginx-default$fastcgi_script_name;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; include /etc/nginx/fastcgi_params;<br />&nbsp;&nbsp;&nbsp; }<br />}<br /><br /><br />server {<br />&nbsp;&nbsp;&nbsp; listen&nbsp;&nbsp; 80;<br />&nbsp;&nbsp;&nbsp;<strong>&nbsp;server_name&nbsp; sdsssdf.localhost.com;</strong>&nbsp;<br />&nbsp;&nbsp;&nbsp; access_log&nbsp; /var/log/nginx/localhost.access.log;<br /><br />&nbsp;&nbsp;&nbsp; location / {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<strong>&nbsp; root&nbsp;&nbsp; /var/www/nginx-default/console;</strong>&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; index index.php index.html index.htm;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; location /doc {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; /usr/share;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoindex on;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; allow 127.0.0.1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; deny all;<br />&nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; location /images {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; /usr/share;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; autoindex on;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; location ~ \.php$ {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_pass&nbsp;&nbsp; 127.0.0.1:9000;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_index&nbsp; index.php;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; fastcgi_param&nbsp; SCRIPT_FILENAME&nbsp; /var/www/nginx-default$fastcgi_script_name;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; include /etc/nginx/fastcgi_params;<br />&nbsp;&nbsp;&nbsp; }<br />}</p>
<p>&nbsp;</p>
<p>---------------------<strong>-监控 &nbsp;</strong></p>
<p>&nbsp;</p>
<p>location ~ ^/NginxStatus/ {&nbsp;<br /><br />stub_status on; #Nginx 状态监控配置&nbsp;&nbsp;&nbsp; &nbsp;<br />}&nbsp;<br /><br /><br /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>这样通过&nbsp;<span>http://localhost/NginxStatus/(最后的/不能掉)</span>&nbsp;监控到 Nginx 的运行信息:</p>
<p>&nbsp;</p>
<p>Active connections: 1&nbsp;<br />server accepts handled requests<br />&nbsp;1 1 5&nbsp;<br />Reading: 0 Writing: 1 Waiting: 0</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>NginxStatus 显示的内容意思如下：</p>
<ul>
<li>active connections &ndash; 当前 Nginx 正处理的活动连接数。</li>
<li>server accepts handled requests -- 总共处理了 14553819 个连接 , 成功创建 14553819 次握手 ( 证明中间没有失败的 ), 总共处理了 19239266 个请求 ( 平均每次握手处理了 1.3 个数据请求 )。</li>
<li>reading -- nginx 读取到客户端的 Header 信息数。</li>
<li>writing -- nginx 返回给客户端的 Header 信息数。</li>
<li>waiting -- 开启 keep-alive 的情况下，这个值等于 active - (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接。</li>

</ul>
<p>&nbsp;</p>
<p>-------------------------------<strong>静态文件处理</strong></p>
<p>通过正则表达式，我们可让 Nginx 识别出各种静态文件</p>
<p>&nbsp;</p>
<p>location ~ \.(htm|html|gif|jpg|jpeg|png|bmp|ico|css|js|txt)$ {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root /var/www/nginx-default/html;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expires 24h;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p><strong>对于例如图片、静态 HTML 文件、js 脚本文件和 css 样式文件等，我们希望 Nginx 直接处理并返回给浏览器，这样可以大大的加快网页浏览时的速度。因此对于这类文件我们需要通过 root 指令来指定文件的存放路径，同时因为这类文件并不常修改，通过&nbsp;<code>expires</code>&nbsp;指令来控制其在浏览器的缓存，以减少不必要的请求。&nbsp;<code>expires</code>&nbsp;指令可以控制 HTTP 应答中的&ldquo; Expires &rdquo;和&ldquo; Cache-Control &rdquo;的头标（起到控制页面缓存的作用）。您可以使用例如以下的格式来书写 Expires：</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>expires 1 January, 1970, 00:00:01 GMT;<br />expires 60s;<br />expires 30m;<br />expires 24h;<br />expires 1d;<br />expires max;<br />expires off;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>这样当你输入http://192.168.200.100/1.html的时候会自动跳转到var/www/nginx-default/html/1.html</p>
<p>&nbsp;</p>
<p><strong>例如 images 路径下的所有请求可以写为：</strong></p>
<table style="width: 100%;" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code-outline">&nbsp;</td>

</tr>

</tbody>

</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>location ~ ^/images/ {<br />&nbsp;&nbsp;&nbsp; root /opt/webapp/images;<br />}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>------------------------<strong>动态页面请求处理[集群]</strong></p>
<p>Nginx 本身并不支持现在流行的 JSP、ASP、PHP、PERL 等动态页面，但是它可以通过反向代理将请求发送到后端的服务器，例如 Tomcat、Apache、IIS 等来完成动态页面的请求处理。<span>前面的配置示例中，我们首先定义了由 Nginx 直接处理的一些静态文件请求后，其他所有的请求通过 proxy_pass 指令传送给后端的服务器</span>&nbsp;（在上述例子中是 Tomcat）。最简单的&nbsp;<code>proxy_pass</code>&nbsp;用法如下：</p>
<p>&nbsp;</p>
<p>location / {<br />&nbsp;&nbsp;&nbsp; proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http://localhost:8080;<br />&nbsp;&nbsp;&nbsp; proxy_set_header&nbsp; X-Real-IP&nbsp; $remote_addr;<br />}</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>这里我们没有使用到集群，而是将请求直接送到运行在 8080 端口的 Tomcat 服务上来完成类似 JSP 和 Servlet 的请求处理。</p>
<p>当页面的访问量非常大的时候，往往需要多个应用服务器来共同承担动态页面的执行操作，这时我们就需要使用集群的架构。 Nginx 通过&nbsp;<code>upstream</code>&nbsp;指令来定义一个服务器的集群，最前面那个完整的例子中我们定义了一个名为 tomcats 的集群，这个集群中包括了三台服务器共 6 个 Tomcat 服务。而 proxy_pass 指令的写法变成了：</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p># 集群中的所有后台服务器的配置信息<br />&nbsp;&nbsp;&nbsp; upstream tomcats {&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.11:8080 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.11:8081 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.12:8080 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.12:8081 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.13:8080 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;server 192.168.0.13:8081 weight=10;&nbsp;<br />&nbsp;&nbsp;&nbsp; }&nbsp;<br />&nbsp;&nbsp;&nbsp; location / {&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_pass http://tomcats;# 反向代理<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; include proxy.conf;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>---------------------<strong>-压力测试</strong></p>
<p>wget http://blog.s135.com/soft/linux/webbench/webbench-1.5.tar.gz&nbsp;&nbsp;&nbsp;<br />tar zxvf webbench-1.5.tar.gz&nbsp;&nbsp;&nbsp;<br />cd webbench-1.5&nbsp;&nbsp;&nbsp;<br />make &amp;&amp; make install</p>
<p>#webbench -c 100 -t 10 http://192.168.200.100/info.php</p>
<p>参数说明：-c表示并发数，-t表示持续时间(秒)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>root@ubuntu-desktop:/etc/nginx/sites-available# webbench -c 100 -t 10 http://192.168.200.100/info.php<br />Webbench - Simple Web Benchmark 1.5<br />Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.<br /><br />Benchmarking: GET http://192.168.200.100/info.php<br />100 clients, running 10 sec.<br /><br />Speed=19032 pages/min, 18074373 bytes/sec.<br />Requests: 3172 susceed, 0 failed.</p>]]></description></item><item><title>ubuntu error log</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/16/errorlog.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Thu, 16 May 2013 10:43:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/16/errorlog.html</guid><description><![CDATA[<p>~# munin-node --debug<br />perl: warning: Setting locale failed.<br />perl: warning: Please check that your locale settings:<br />	LANGUAGE = (unset),<br />	LC_ALL = (unset),<br />	LC_PAPER = "zh_CN.UTF-8",<br />	LC_ADDRESS = "zh_CN.UTF-8",<br />	LC_MONETARY = "zh_CN.UTF-8",<br />	LC_NUMERIC = "zh_CN.UTF-8",<br />	LC_TELEPHONE = "zh_CN.UTF-8",<br />	LC_IDENTIFICATION = "zh_CN.UTF-8",<br />	LC_MEASUREMENT = "zh_CN.UTF-8",<br />	LC_TIME = "zh_CN.UTF-8",<br />	LC_NAME = "zh_CN.UTF-8",<br />	LANG = "en_US.UTF-8"<br />    are supported and installed on your system.<br />perl: warning: Falling back to the standard locale ("C").<br />Pid_file already exists for running process (6563)... aborting</p>
<p>-------------------------------------------------------------------------</p>
<p>Add the following lines to your bashrc or bash_profile on the host machine:</p>
<pre class="lang-perl prettyprint prettyprinted"><code><span class="com"># Setting for the new UTF-8 terminal support in Lion</span><span class="pln">
export LC_CTYPE</span><span class="pun">=</span><span class="pln">en_US</span><span class="pun">.</span><span class="pln">UTF</span><span class="pun">-</span><span class="lit">8</span><span class="pln">
export LC_ALL</span><span class="pun">=</span><span class="pln">en_US</span><span class="pun">.</span><span class="pln">UTF</span><span class="pun">-</span><span class="lit">8<br />-------------------------------------------------------</span></code></pre>]]></description></item><item><title>vim分屏</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/15/vim_split.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 15 May 2013 03:27:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/15/vim_split.html</guid><description><![CDATA[<h4>分屏启动Vim</h4>
<ol>
<li>使用大写的O参数来垂直分屏。
<pre><code>vim -On file1 file2 ...</code></pre>
</li>
<li>使用小写的o参数来水平分屏。
<pre><code>vim -on file1 file2 ...</code></pre>
</li>
</ol>
<p><strong>注释:</strong>&nbsp;n是数字，表示分成几个屏。</p>
<h4>关闭分屏&nbsp;</h4>
<ol>
<li>关闭当前窗口。
<pre><code>Ctrl+W c</code></pre>
</li>
<li>关闭当前窗口，如果只剩最后一个了，则退出Vim。
<pre><code>Ctrl+W q</code></pre>
</li>
</ol>
<h3>分屏</h3>
<ol>
<li>上下分割当前打开的文件。
<pre><code>Ctrl+W s</code></pre>
</li>
<li>上下分割，并打开一个新的文件。
<pre><code>:sp filename</code></pre>
</li>
<li>左右分割当前打开的文件。&nbsp;
<pre><code>Ctrl+W v</code></pre>
</li>
<li>左右分割，并打开一个新的文件。
<pre>:vsp filename</pre>
</li>
</ol>
<h4>移动光标</h4>
<p>Vi中的光标键是h, j, k, l，要在各个屏间切换，只需要先按一下Ctrl+W</p>
<ol>
<li>把光标移到<strong>右边</strong>的屏。
<pre><code>Ctrl+W l</code></pre>
</li>
<li>把光标移到<strong>左边</strong>的屏中。
<pre><code>Ctrl+W h</code></pre>
</li>
<li>把光标移到<strong>上边</strong>的屏中。
<pre><code>Ctrl+W k</code></pre>
</li>
<li>把光标移到<strong>下边</strong>的屏中。
<pre><code>Ctrl+W j</code></pre>
</li>
<li>把光标移到<strong>下一个</strong>的屏中。.
<pre>Ctrl+W w</pre>
</li>
</ol>
<h4>移动分屏</h4>
<p>这个功能还是使用了Vim的光标键，只不过都是大写。当然了，如果你的分屏很乱很复杂的话，这个功能可能会出现一些非常奇怪的症状。</p>
<ol>
<li>向右移动。
<pre><code>Ctrl+W L</code></pre>
</li>
<li>向左移动&nbsp;
<pre><code>Ctrl+W H</code></pre>
</li>
<li>向上移动&nbsp;
<pre><code>Ctrl+W K</code></pre>
</li>
<li>向下移动&nbsp;
<pre><code>Ctrl+W J</code></pre>
</li>
</ol>
<h4>屏幕尺寸</h4>
<p>下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用Ctrl+W &lt;或是&gt;，但这可能需要最新的版本才支持。</p>
<ol>
<li>让所有的屏都有一样的高度。
<pre><code>Ctrl+W =</code></pre>
</li>
<li>增加高度。
<pre><code>Ctrl+W +</code></pre>
</li>
<li>减少高度。
<pre><code>Ctrl+W -</code></pre>
</li>
</ol>
<p><code>也许还有其它我不知道的，欢迎你补充。</code></p>
<p>&nbsp;</p>
<p><span>有各个分屏之间移动光标，可以简单的使用：</span><br /><span>Ctrl+h</span><br /><span>Ctrl+j</span><br /><span>Ctrl+k</span><br /><span>Ctrl+l</span></p>
<p><span>-----------------------------------------------------------------</span></p>
<p>Inconsolata 是一款看起来很漂亮的 monospace font（等宽字体），尤其适合在终端下和写代码的朋友使用。</p>
<p><img src="http://www.oschina.net/uploads/img/200912/24224359_9t6p.png" alt="" /></p>]]></description></item><item><title>uwsgi+nginx+django+python</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/13/uwsgi.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Mon, 13 May 2013 08:26:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/13/uwsgi.html</guid><description><![CDATA[<p><span style="color: #ff0000;"><code class="csharp plain">wget http:</code><code class="csharp comments">//projects.unbit.it/downloads/uwsgi-latest.tar.gz-------------<span>python uwsgiconfig.py --build</span></code></span></p>
<p><span style="color: #ff0000;">Django------------python setup.py install</span></p>
<p><span style="color: #0000ff;"><span style="color: #ff0000;">django-admin createproject oursite</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #ff0000;">-----------------------------------------------</span></span></p>
<p><span style="color: #0000ff;"><span style="color: #ff0000;">cd /path/to/uwsgi<br /></span></span></p>
<p><span style="color: #0000ff;"><span style="color: #ff0000;">uwsgi.xml</span></span></p>
<p>&nbsp;</p>
<table style="height: 192px; width: 1301px;" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="csharp plain">&lt;uwsgi&gt;&nbsp; </code></div>
<div class="line number2 index1 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;socket&gt;0.0.0.0:8000&lt;/socket&gt;&nbsp; </code></div>
<div class="line number3 index2 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;listen&gt;20&lt;/listen&gt;&nbsp; </code></div>
<div class="line number4 index3 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;master&gt;</code><code class="csharp keyword">true</code><code class="csharp plain">&lt;/master&gt;&nbsp; </code></div>
<div class="line number5 index4 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;pidfile&gt;/usr/local/nginx/uwsgi.pid&lt;/pidfile&gt;&nbsp; </code></div>
<div class="line number6 index5 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;processes&gt;2&lt;/processes&gt;&nbsp; </code></div>
<div class="line number7 index6 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;module&gt;django_wsgi&lt;/module&gt;&nbsp; #这个文件下面要建立</code></div>
<div class="line number8 index7 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;pythonpath&gt;/root/my_django&lt;/pythonpath&gt;&nbsp;&nbsp; #刚才建立项目的路径</code></div>
<div class="line number9 index8 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;profiler&gt;</code><code class="csharp keyword">true</code><code class="csharp plain">&lt;/profiler&gt;&nbsp; </code></div>
<div class="line number10 index9 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;memory-report&gt;</code><code class="csharp keyword">true</code><code class="csharp plain">&lt;/memory-report&gt;&nbsp; </code></div>
<div class="line number11 index10 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;enable-threads&gt;</code><code class="csharp keyword">true</code><code class="csharp plain">&lt;/enable-threads&gt;&nbsp; </code></div>
<div class="line number12 index11 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;logdate&gt;</code><code class="csharp keyword">true</code><code class="csharp plain">&lt;/logdate&gt;&nbsp; </code></div>
<div class="line number13 index12 alt2"><code class="csharp spaces">&nbsp;&nbsp;</code><code class="csharp plain">&lt;limit-</code><code class="csharp keyword">as</code><code class="csharp plain">&gt;6048&lt;/limit-</code><code class="csharp keyword">as</code><code class="csharp plain">&gt;&nbsp; </code></div>
<div class="line number14 index13 alt1"><code class="csharp plain">&lt;/uwsgi&gt; </code></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>nginx</p>
<div class="cnblogs_Highlighter">
<div>
<div id="highlighter_265615" class="syntaxhighlighter nogutter  csharp">
<div class="toolbar"><span><a class="toolbar_item command_help help" href="http://www.cnblogs.com/txwsqk/archive/2011/03/15/1984792.html">?</a></span></div>
<table border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="csharp plain">server {&nbsp; </code></div>
<div class="line number2 index1 alt1"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">listen&nbsp; 80;&nbsp; </code></div>
<div class="line number3 index2 alt2"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">server_name 192.168.0.100;&nbsp; </code></div>
<div class="line number4 index3 alt1"><code class="csharp spaces">&nbsp;&nbsp;</code>&nbsp;</div>
<div class="line number5 index4 alt2"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">location / {&nbsp; </code></div>
<div class="line number6 index5 alt1"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">root /root/my_django;</code></div>
<div class="line number7 index6 alt2"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">uwsgi_pass&nbsp;&nbsp; 127.0.0.1:8000;&nbsp; </code></div>
<div class="line number8 index7 alt1"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">include&nbsp;&nbsp;&nbsp;&nbsp; uwsgi_params;&nbsp; </code></div>
<div class="line number9 index8 alt2"><code class="csharp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="csharp plain">access_log&nbsp; off;&nbsp; }</code></div>
<div class="line number10 index9 alt1">&nbsp;</div>
<div class="line number11 index10 alt2"><code class="csharp plain">}&nbsp; </code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>启动uwsgi和nginx</p>
<div class="cnblogs_Highlighter">
<div id="highlighter_278226" class="syntaxhighlighter nogutter  csharp">
<div class="toolbar"><span><a class="toolbar_item command_help help" href="http://www.cnblogs.com/txwsqk/archive/2011/03/15/1984792.html">&nbsp;</a></span></div>
<table style="height: 89px; width: 1329px;" border="0" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="csharp plain">/usr/local/nginx/sbin/nginx</code></div>
<div class="line number2 index1 alt1"><code class="csharp plain">uwsgi -x /root/my_django/uwsgi.xml &amp;</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span style="color: #ff0000;"><span>&nbsp;</span></span></p>]]></description></item><item><title>git随笔</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/13/git.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Mon, 13 May 2013 03:30:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/13/git.html</guid><description><![CDATA[<p><span style="color: #ff0000;">回滚</span></p>
<blockquote>
<p><span style="color: #000000;">有时候使用Git工作得小心翼翼，特别是涉及到一些高级操作，例如 reset, rebase 和 merge。甚至一些很小的操作，例如删除一个分支，我都担心数据丢失。</span><br /><br /><span style="color: #000000;">不久之前，我在做一些大动作（rebasing）之前，我总是备份整个版本库，以防万一。直到最近我才发现git的历史记录是不可修改的，也就是说你不能更改任何已经发生的事情。你做的任何操作都只是在原来的操作上修改。也就是说，即使你删除了一个分支，修改了一个提交，或者强制重置，你仍然可以回滚这些操作。</span><br /><br /><span style="color: #000000;">让我们来看一些例子：</span><br /><br /><span style="color: #000000;">$ git init</span><br /><span style="color: #000000;">$ touch foo.txt</span><br /><span style="color: #000000;">$ git add foo.txt</span><br /><span style="color: #000000;">$ git commit -m "initial commit"</span><br /><br /><span style="color: #000000;">$ echo 'new data' &gt;&gt; foo.txt</span><br /><span style="color: #000000;">$ git commit -a -m "more stuff added to foo"</span><br /><br /><span style="color: #000000;">你现在看git的历史记录，你可以看到两次提交：</span><br /><span style="color: #000000;">$ git log</span><br /><span style="color: #000000;">* 98abc5a (HEAD, master) more stuff added to foo</span><br /><span style="color: #000000;">* b7057a9 initial commit</span><br /><br /><span style="color: #000000;">现在让我们来重置回第一次提交的状态：</span><br /><span style="color: #000000;">$ git reset --hard b7057a9</span><br /><span style="color: #000000;">$ git log</span><br /><span style="color: #000000;">* b7057a9 (HEAD, master) initial commit</span><br /><br /><span style="color: #000000;">这看起来我们是丢掉了我们第二次的提交，没有办法找回来了。但是 reflog 就是用来解决这个问题的。简单的说，它会记录所有HEAD的历史，也就是说当你做 reset，checkout等操作的时候，这些操作会被记录在reflog中。</span><br /><br /><span style="color: #000000;">$ git reflog</span><br /><span style="color: #000000;">b7057a9 HEAD@{0}: reset: moving to b7057a9</span><br /><span style="color: #000000;">98abc5a HEAD@{1}: commit: more stuff added to foo</span><br /><span style="color: #000000;">b7057a9 HEAD@{2}: commit (initial): initial commit</span><br /><br /><span style="color: #000000;">所以，我们要找回我们第二commit，只需要做如下操作：</span><br /><span style="color: #000000;">$ git reset --hard 98abc5a</span><br /><br /><span style="color: #000000;">再来看一下 git 记录：</span><br /><span style="color: #000000;">$ git log</span><br /><span style="color: #000000;">* 98abc5a (HEAD, master) more stuff added to foo</span><br /><span style="color: #000000;">* b7057a9 initial commit</span><br /><br /><span style="color: #000000;">所以，如果你因为reset等操作丢失一个提交的时候，你总是可以把它找回来。除非你的操作已经被git当做垃圾处理掉了，一般是30天以后</span></p>

</blockquote>]]></description></item><item><title>监控工具</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/12/monitoring.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 12 May 2013 09:19:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/12/monitoring.html</guid><description><![CDATA[<p><strong>1.&nbsp;<a href="http://munin-monitoring.org/" target="_blank">&nbsp;Munin</a></strong></p>
<p>Munin是一款开源网络资源监控工具，可以分析资源趋势、&ldquo;刚刚是什么让性能死掉&rdquo;方面的问题。可监控核心系统资源，包括内存、磁盘、CPU 占用、服务器应用如MySQL、Apache和Squid等。它使用起来非常方便，是一款即插即用型工具，并且提供了许多丰富的图表。</p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695901.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695901.jpg" alt="" border="0" /></a></p>
<p>Munin是一款通过客户端&mdash;&mdash;服务器架构收集数据并将其图形化的工具。Munin允许你跟踪主机的运行记录，就是所谓的节点，然后将它们发送到中央服务器，随后就能以图像形式展示它们。</p>
<p>目前，Munin的最新版本是Munin 2.0.11.1，大家可以从<a href="https://github.com/munin-monitoring/munin/tree/2.0.11.1" target="_blank">GitHub</a>或<a href="http://sourceforge.net/projects/munin/files/stable/2.0.11/" target="_blank">SourceForge</a>上下载该版本。</p>
<p><strong>2.<a href="https://www.pingdom.com/" target="_blank">Pingdom</a></strong></p>
<p>Pingdom是一家知名的监控服务提供公司，由Sam Nurmi创立，而Sam Nurmi曾是瑞典最大的网络托管公司Loopia的CEO。</p>
<p>使用Pingdom可以监控互联网上多个地方的网站和服务器，确保它们运行正常。除了提供网页加载速度、DNS、Ping和路由、FTP服务器、电子邮件等检查，也提供在线时间监控。Pingdom的检查和监控有收费也有免费的。只要注册就可以享受免费版监控，其缺点是只能监测1个站。</p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695902.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695902.jpg" alt="" border="0" /></a></p>
<p><strong>3.<a href="http://graphite.wikidot.com/start" target="_blank">Graphite</a></strong></p>
<p>Graphite是一个企业级的监控工具，使用Python编写，采用django框架。最初由Chris Davis在Orbitz工作时，作为一个辅助项目开发的，最终成一个基本的监控工具。</p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695903.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695903.jpg" alt="" border="0" /></a></p>
<p>Graphite可用来收集服务器所有的及时状态、用户请求信息、Memcached命中率、RabbitMQ消息服务器的状态、Unix操作系统的负载状态。Graphite服务器大约每分钟需要有4800次更新操作，简单的文本协议和强大的绘图功能可以方便地扩展到任何需要监控的系统上。</p>
<p>Graphite将数据以图形的形式展现出来。它主要做两件事：存储时间序列数据、根据需要呈现数据的图形。目前，Graphite的最新版本是0.9.10，源码托管在<a href="https://launchpad.net/graphite">launchpad.net</a>上。</p>
<p><strong>4.<a href="http://ganglia.sourceforge.net/" target="_blank">Ganglia</a></strong></p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695904.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695904.jpg" alt="" border="0" /></a></p>
<p><span>&nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<p>Ganglia是UC（University of California）Berkeley发起的一个开源集群监视项目，Ganglia是一个跨平台可扩展的，高性能计算系统下的分布式监控系统。它已被广泛地移植到各种操作系统和处理器架构上，目前在世界各地成千上万的集群中应用。</p>
<p>Ganglia Web 3.5.7版已经发布，托管在<a href="http://sourceforge.net/projects/ganglia/files/ganglia-web/3.5.7/">Sourceforge</a>上。Ganglia的核心包含了gmond、gmetad以及一个Web前端。</p>
<p>Ganglia主要是用来监控系统性能，如：CPU、内存、硬盘利用率、I/O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。</p>
<p><strong>5.<a href="http://www.nagios.org/" target="_blank">Nagios</a></strong></p>
<p>Nagios原名为NetSaint，由Ethan Galstad开发并维护至今。Nagios是企业级的监控系统，能有效监控Windows、Linux和Unix的主机状态以及交换机路由器等网络设置，打印机等。</p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695905.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695905.jpg" alt="" border="0" />&nbsp;</a></p>
<p>Nagios最大的特点就是能在系统或服务状态异常时发出邮件或短信报警，第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。&nbsp;</p>
<p><strong>6.<a href="http://www.oschina.net/p/collectd" target="_blank">collectd</a></strong></p>
<p>collectd是一款用C语言开发的开源的性能监测工具，无需系统cron支持、简单易用。collectd是插件式架构，主要分为输入、输出类型插件。</p>
<p><a href="http://www.thebigdata.cn/upload/2013-03/130319125695906.jpg" target="_blank"><img src="http://www.thebigdata.cn/upload/2013-03/130319125695906.jpg" alt="" border="0" /></a></p>
<p>当系统运行和存储信息的时候，collectd会周期性地统计系统相关信息。那些信息可以用来找到当前系统性能瓶颈。与其他监测工具相比，collectd它完全是由C语言编写，性能很高、可移植性好，它允许运行在系统没有脚本语言支持或者cron daemon的系统上，比如嵌入式系统。同时，它包含优化以及处理成百上千种数据集的新特性。</p>
<p>collectd包含有超过70多种插件，同时，collectd提供强大的网络联网特性，它能以多种方式来扩充。</p>
<p>而collectd不足之处则是不能直接生成图片。虽然它能写RRD文件，但是它不能从这些文件生成图形。目前collectd的最新版本为5.2.1，源码托管在<a href="https://github.com/collectd/collectd" target="_blank">GitHub</a>上。</p>
<p>以上这些产品大部分是开源的，对于中小型公司来说，利用开源产品能大大提高团队的开发效率。而且这些产品都拥有非常活跃的社区，遇到问题后能得到很好的解决。</p>]]></description></item><item><title>开源软件</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/12/opensource.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 12 May 2013 04:24:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/12/opensource.html</guid><description><![CDATA[<p><span>下面是在linux网站运维方向最近几年常用的免费的开源软件<br />linux的世界真的很精彩，还没入门的朋友赶紧进来吧！</span></p>
<p><span>操作系统：Centos<span>※,</span>Freebsd,Ubuntu<br />网站服务：apache<span>※,</span>nginx<span>※</span>,lighttpd,php<span>※,</span>tomcat<span>※,</span>resin<span>※<br /></span>数据&nbsp;&nbsp; 库：Mysql<span>※,</span>PostgreSQL,Mysql-proxy<br />代理相关：lvs,keepalived,haproxy,nginx,apache,heartbeat（此行都是<span>※）<br /></span>网站缓存：squid<span>※,</span>nginx<span>※,</span>varnish<br />内存缓存：memcache<span>※,</span>memcached,TokyoTyrant<span>※,</span>MongoDB,Cassandra<span>※,</span>redis※,tair,CouchDB<br />存储相关：Nfs<span>※,</span>Moosefs<span>※,</span>Hadoop<span>※,</span>gfs<span>※,</span>lustre,FastDFS<br />版本管理：cvs,svn<span>※,</span>git<span>※<br /></span>监控报警：mboy,mrtg,nagios<span>※</span>,cacti<span>※</span>,zbbix,munin<span>※</span>,hyperic<span>※<br /></span>域名解析：bind<span>※</span>,powerdns,dnsmq<span>※<br /></span>同步软件：rsync,inotify,sersync,drbd,csync2+lsyncd（此行都是※）<br />分发工具：Secboy<span>※</span>,expect<span>※,</span>puppet<span>※,</span>cfengine<span>※,</span>ssh+rsync+sersync<span>※<br /></span>虚拟软件：xen<span>※</span>,kvm<br />内网软件：iptables<span>※</span>,zebra<span>※</span>,iftraf,ntop<span>※</span>,tc<span>※</span>,iftop<br />邮件软件：qmail<span>※,</span>posfix<span>※,</span>sendmail<br />远程拨号：openvpn<span>※</span>,pptp,openswan<span>※</span>,ipip<span>※<br /></span>统一认证：ldap<span>※<br /></span>队列工具：ActiveMQ<span>※,</span>RabbitMQ<br />打包发布：mvn<span>※</span>,ants<span>※</span>,jenkins<span>※<br /></span>测试软件：apache&nbsp; ab,smokeping,siege,JMeter,Webbench,LoadRunner（此行都是<span>※</span>）&nbsp;<br />日志相关：syslog,rsyslog,Awstats<br />DB代理&nbsp;&nbsp; ：mysql-proxy,amoeba<br /></span><span><br />提示：<br />1）以上所有软件都是老男孩用过或测试过的。<br />2）带<strong><span>※</span></strong>的为老男孩最近几年用的比较多，可信任使用的。也是近年来linux运维的大众。<br />3）有了功能分类和软件名，大家有需求，可以按功能找软件直接G就知道了。</span><br /><span>4）&nbsp; 学习要有舍有得，什么都抓必然短时间都不会精，希望大家能抓重点，抓精髓，大众软件（带<span>※</span>）先熟练了，这是基础加提高，在研究小众软件（不带<span>※</span>），这是高手之路，最后在研究偏门的，世外高手之路，当然前提是先掌握前面的大众和小众。<br />5）当然还有一些没有大众开源的有一些也很棒，如审计堡垒机程序。</span></p>
<p><span>&nbsp;</span></p>]]></description></item><item><title>ubuntu install phabricator with nginx</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/11/phabricator.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sat, 11 May 2013 06:11:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/11/phabricator.html</guid><description><![CDATA[<h2>Installing Required Components</h2>
<p>If you are installing on Ubuntu or an RedHat derivative, there are install scripts available which should handle most of the things discussed in this document for you:</p>
<ul>
<li><strong>RedHat Derivatives</strong>:&nbsp;<a href="http://www.phabricator.com/rsrc/install/install_rhel-derivs.sh" target="_blank">http://www.phabricator.com/rsrc/install/install_rhel-derivs.sh</a></li>
<li><strong>Ubuntu</strong>:&nbsp;<a href="http://www.phabricator.com/rsrc/install/install_ubuntu.sh" target="_blank">http://www.phabricator.com/rsrc/install/install_ubuntu.sh</a></li>
</ul>
<p>&nbsp;here's a general description of what you need to install:</p>
<ul>
<li>git (usually called "git" in package management systems)</li>
<li>Apache (usually "httpd" or "apache2") (or nginx)</li>
<li>MySQL Server (usually "mysqld" or "mysql-server")</li>
<li>PHP (usually "php")</li>
<li>Required PHP extensions: mbstring, iconv, mysql (or mysqli), curl, pcntl (these might be something like "php-mysql" or "php5-mysql")</li>
<li>Optional PHP extensions: gd, apc (special instructions for APC are available below if you have difficulty installing it), xhprof (instructions below, you only need this if you are developing Phabricator)</li>
</ul>
<p>Now that you have all that stuff installed, grab Phabricator and its dependencies:</p>
<div class="remarkup-code-block" data-code-lang="console">
<div class="cnblogs_code">
<pre>$ cd somewhere/ # pick some <span style="color: #0000ff;">install</span><span style="color: #000000;"> directory
somewhere</span>/ $ git clone git:<span style="color: #008000;">//</span><span style="color: #008000;">github.com/facebook/libphutil.git</span>
somewhere/ $ git clone git:<span style="color: #008000;">//</span><span style="color: #008000;">github.com/facebook/arcanist.git</span>
somewhere/ $ git clone git:<span style="color: #008000;">//</span><span style="color: #008000;">github.com/facebook/phabricator.git</span></pre>
</div>
<pre class="remarkup-code"><span class="gp"><br /><br /><span style="color: #ff0000;">from <span style="color: #ff0000;"><a href="http://www.phabricator.com/docs/phabricator/article/Installation_Guide.html">http://www.phabricator.com/docs/phabricator/article/Installation_Guide.html<br /><br /><br /></a></span></span></span></pre>
<pre class="remarkup-code"><span class="gp"><span>mysql:<br />     cd /path/to/phabrichator/bin<br /></span></span></pre>
<div class="cnblogs_code">
<pre>:/usr/development/facebook/phabricator/bin$ ./config list | <span style="color: #0000ff;">grep</span> <span style="color: #800000;">"</span><span style="color: #800000;">mysql</span><span style="color: #800000;">"</span><span style="color: #000000;">
mysql.configuration</span>-<span style="color: #000000;">provider
mysql.host
mysql.implementation
mysql.pass
mysql.user
storage.mysql</span>-engine.max-size</pre>
</div>
<div class="cnblogs_code">
<pre>./<span style="color: #000000;">configure set mysql.user root
.</span>/configure set mysql.pass <span style="color: #0000ff;">passwd</span><span style="color: #000000;">
.</span>/conffgure set mysql.host localhost</pre>
</div>
<p>&nbsp;</p>
<pre class="remarkup-code"><span class="gp"><span style="color: #ff0000;"><span style="color: #ff0000;"><a href="http://www.phabricator.com/docs/phabricator/article/Installation_Guide.html"><br /></a>nginx:<br />     502 bad gateway<br /><br /></span></span></span></pre>
<div class="cnblogs_code">
<pre>netstat -an|<span style="color: #0000ff;">grep</span> <span style="color: #800080;">9000</span>-------------------to see <span style="color: #0000ff;">if</span> php5-<span style="color: #000000;">fpm is using this port

ortherwise,
</span><span style="color: #0000ff;">sudo</span> apt-get <span style="color: #0000ff;">install</span> php5-<span style="color: #000000;">fpm

</span><span style="color: #0000ff;">then</span><span style="color: #000000;">,
</span><span style="color: #0000ff;">sudo</span> <span style="color: #0000ff;">vi</span> /etc/php5/fpm/php.ini---------set&gt;&gt; cgi.fix_pathinfo=<span style="color: #800080;">0</span>
<span style="color: #0000ff;">sudo</span> <span style="color: #0000ff;">vi</span> /etc/php5/fpm/pool.d/www.conf---------------set&gt;&gt; listen = <span style="color: #800080;">127.0</span>.<span style="color: #800080;">0.1</span>:<span style="color: #800080;">9000</span></pre>
</div>
<pre class="remarkup-code"></pre>
<pre class="remarkup-code"><span class="gp"><span style="color: #ff0000;"><span style="color: #ff0000;"><span>nginx.conf<br /></span></span></span></span></pre>
<div class="cnblogs_code">
<pre><span style="color: #000000;">    server {
        listen       </span><span style="color: #800080;">520</span><span style="color: #000000;">;
        server_name phabricator.example.com;

        root      </span>/usr/development/facebook/phabricator/<span style="color: #000000;">webroot;
        try_files $uri $uri</span>/ /<span style="color: #000000;">index.php;

        location </span>/<span style="color: #000000;"> {
            index   index.php;

            </span><span style="color: #0000ff;">if</span> ( !-<span style="color: #000000;">f $request_filename )
            {
               rewrite </span>^/(.*)$ /index.php?__path__=/$<span style="color: #800080;">1</span> <span style="color: #0000ff;">last</span><span style="color: #000000;">;
               break;
            }
         }

         location </span>/<span style="color: #000000;">index.php {
            fastcgi_pass   localhost:</span><span style="color: #800080;">9000</span><span style="color: #000000;">;
            fastcgi_index   index.php;

            #required </span><span style="color: #0000ff;">if</span> PHP was built with --enable-force-cgi-<span style="color: #000000;">redirect
            #fastcgi_param  REDIRECT_STATUS    </span><span style="color: #800080;">200</span><span style="color: #000000;">;

            #variables to </span><span style="color: #0000ff;">make</span> the $_SERVER populate <span style="color: #0000ff;">in</span><span style="color: #000000;"> PHP
            fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;
            fastcgi_param  QUERY_STRING       $query_string;
            fastcgi_param  REQUEST_METHOD     $request_method;
            fastcgi_param  CONTENT_TYPE       $content_type;
            fastcgi_param  CONTENT_LENGTH     $content_length;

            fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;

            fastcgi_param  GATEWAY_INTERFACE  CGI</span>/<span style="color: #800080;">1.1</span><span style="color: #000000;">;
            fastcgi_param  SERVER_SOFTWARE    nginx</span>/<span style="color: #000000;">$nginx_version;

            fastcgi_param  REMOTE_ADDR        $remote_addr;
         }
    }</span></pre>
</div>
<pre class="remarkup-code"></pre>
<p>so,visit via 127.0.0.1:520</p>
<p>&nbsp;</p>
<pre class="remarkup-code"><span class="gp"><span style="color: #ff0000;"><span style="color: #ff0000;"><span>notes:<br />1,<a href="http://www.phabricator.com/docs/phabricator/article/Installation_Guide.html">http://www.phabricator.com/docs/phabricator/article/Installation_Guide.html</a><br />2,<a href="http://waynemay.com/using-phabricator-on-nginx/">http://waynemay.com/using-phabricator-on-nginx/<br /></a>3,<a href="http://www.nginx.cn/76.html">http://www.nginx.cn/76.html</a>                         <br /></span><br /><br /><br /></span></span></span></pre>
</div>]]></description></item><item><title>ssl</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/10/ssl.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 10 May 2013 03:51:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/10/ssl.html</guid><description><![CDATA[<p><span>当前 SSL 协议有着广泛的运用，在 SSL 服务器的身份认证出现问题时，怎样才能有效快速的找出问题的根源呢？本文结合 openssl 提供的命令行工具 s_client，罗列了多种认证失败的情况，并给出了问题诊断的方法。</span><br /><span>&nbsp;&nbsp;&nbsp;</span><strong>&nbsp;SSL 握手协议</strong></p>
<p>&nbsp;&nbsp;&nbsp; 首先简单的介绍一下 SSL 协议建立连接的过程。如图 1 所示，主要有如下几个过程：</p>
<p>&nbsp;&nbsp;&nbsp; 图 1. SSL 身份认证及协商密钥的过程</p>
<p>&nbsp;&nbsp;</p>
<p align="center"><img src="http://linux.chinaitlab.com/UploadFiles_7565/200904/20090417120655443.gif" alt="SSL 身份认证及协商密钥的过程" width="534" height="482" /></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; ●客户端发起请求，包含一个hello消息，并附上客户端支持的密码算法和 SSL 协议的版本消息以及用于生成密钥的随机数。<br />&nbsp;&nbsp;&nbsp; ●服务器收到消息后，服务器端选择加密压缩算法并生成服务器端的随机数，将该信息反馈给客户端；接着服务器端将自身的数字证书（在图 1 中使用了一个 X.509 数字证书）发送到客户端；完成上述动作后后服务器端会发送&ldquo;hello done&rdquo;消息给客户端。此外如果服务器需要对客户端进行身份认证，服务器端还会发送一个请求客户端证书的消息。<br />&nbsp;&nbsp;&nbsp; ●一旦客户端收到&rdquo;hello done&rdquo; , 就开始对服务器端的数字证书进行认证并检查服务器端选中的算法是可行的。如果服务器要求认证客户端身份，客户端还会发送自己的公钥证书。<br />&nbsp;&nbsp;&nbsp; ●如果对服务器的身份认证通过，客户端会发起密钥交换的请求。<br />&nbsp;&nbsp;&nbsp; ●服务器端和客户端根据先前协商的算法和交换随机数生成对称密钥进行后续的通信。</p>
<p>&nbsp;&nbsp;&nbsp;<strong>&nbsp;s_client 简介</strong></p>
<p>&nbsp;&nbsp;&nbsp; openssl 提供了 SSL 协议的一个开放源代码的实现，包含三部分：ssl 库，加解密库和命令行工具。在命令行工具中 s_client 是一个以 SSL 协议连接远程服务器的客户端程序，该工具可以用于测试诊断。虽然 s_client 只提供了一些基础功能，但是其内部具体实现中使用了 ssl 库的大部分接口。</p>
<p>&nbsp;&nbsp;&nbsp; s_client命令行的语法为：</p>
<p>&nbsp;&nbsp;&nbsp; 清单 1. s_client 参数</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">openssl s_client [-connect host:port&gt;] [-verify depth]<br /> [-cert filename] [-key filename] 
 [-CApath directory] [-CAfile filename][-reconnect] [-pause]<br /> [-showcerts] [-debug] [-msg] 
 [-nbio_test] [-state] [-nbio] [-crlf] [-ign_eof] [-quiet]</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 常用参数的具体用途如下：</p>
<p>&nbsp;&nbsp;&nbsp; ●-connect host:port ：指定远程服务器的地址和端口，如果没有该参数，默认值为 localhost:443 ；<br />&nbsp;&nbsp;&nbsp; ●-cert filename：若服务器端需要验证客户端的身份，通过 -cert 指定客户端的证书文件。<br />&nbsp;&nbsp;&nbsp; ●-key filename：指定私钥文件；<br />&nbsp;&nbsp;&nbsp; ●-verify depth：打开服务器证书验证并定义证书验证过程中的最大深度。<br />&nbsp;&nbsp;&nbsp; ●-showcerts：显示服务器证书链；<br />&nbsp;&nbsp;&nbsp; ●-CAfile filename：指定用于验证服务器证书的根证书；<br />&nbsp;&nbsp;&nbsp; ●-state：打印出 SSL 会话的状态。<br /><strong>&nbsp;s_client 在 SSL 握手协议中的应用</strong></p>
<p>&nbsp;&nbsp;&nbsp; 在连接 SSL 服务器时最常见的问题就是客户端认证服务器端身份失败，有多种原因造成这些失败，以下列举了常见的错误并解析了如何应用 s_client 进行确诊。</p>
<p>●服务器的证书在传输过程中被篡改<br />&nbsp;&nbsp;&nbsp; 1.提取服务器的证书：<br />&nbsp;&nbsp;&nbsp; 在 linux 平台下创建脚本 retrieve-cert.sh 并存入一下清单 2 中的内容。该脚本的输出内容就是服务器端的 X509 证书经过 Base64 编码后的内容，执行脚本并将脚本输出存入文件 server.pem 中。</p>
<p>&nbsp;&nbsp;&nbsp; 清单 2. 提取证书</p>
<p>&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">###usage: retrieve-cert.sh remote.host.name [port] 
 SSLHOST=$1 
 SSLPORT=${2:-443} 
 echo | 
 openssl s_client -connect ${SSLHOST}:${SSLPORT} 2&gt;&amp;1 | 
 sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 1.验证获取的证书，在命令行下执行&rdquo;openss verify server.pem&rdquo;。<br />&nbsp;&nbsp;&nbsp; 如果证书内容被篡改，那么执行后的结果如清单 4 所示：</p>
<p>&nbsp;&nbsp;&nbsp; 清单 4. 证书验证失败</p>
<p>&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wks547385wss openssl]# openssl verify server.pem 
 unable to load certificate 
 19280:error:0D0680A8:asn1 encoding routines:<br />ASN1_CHECK_TLEN:wrong tag:tasn_dec.c:947: 
 19280:error:0D07803A:asn1 encoding routines:<br />ASN1_ITEM_EX_D2I:nested asn1 
 error:tasn_dec.c:304:Type=X509 
 19280:error:0906700D:PEM routines:PEM_ASN1_read_bio:<br />ASN1 lib:pem_oth.c:82:</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 否则的话，我们就能得到认证通过，结果如下：</p>
<p>&nbsp;&nbsp;&nbsp; 清单 5. 证书验证成功</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wks547385wss openssl]# openssl verify server.pem 
 server.pem: OK</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; ●客户端没有保存认证服务器端的证书的根证书；<br />&nbsp;&nbsp;&nbsp; 1. 使用参数-state检查是否在握手协议的证书认证时失败</p>
<p>&nbsp;&nbsp;&nbsp; 清单 6. 显示 SSL 握手协议状态</p>
<p>&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wks547385wss openssl]# openssl s_client <br /> -connect www6.software.ibm.com:443 -state 
 CONNECTED(00000003) 
 SSL_connect:before/connect initialization 
 SSL_connect:SSLv2/v3 write client hello A 
 SSL_connect:SSLv3 read server hello A 
 depth=1 /C=US/O=Equifax/OU=Equifax Secure Certificate Authority 
 verify error:num=19:self signed certificate in certificate chain 
 verify return:0 
 SSL_connect:SSLv3 read server certificate A 
 SSL_connect:SSLv3 read server done A 
 SSL_connect:SSLv3 write client key exchange A 
 SSL_connect:SSLv3 write change cipher spec A 
 SSL_connect:SSLv3 write finished A 
 SSL_connect:SSLv3 flush data 
 SSL_connect:SSLv3 read finished A</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span>2. 运用 s_client 参数-showcerts获取服务器端的根证书，服务器端的证书链将会全部显示出来，在证书链的末端就是根证书，保存证书文件为serverCA.pem 。</span></p>
<p>&nbsp;&nbsp;&nbsp; 清单 7. 获取服务器端的根证书</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wkswss openssl]# openssl s_client -connect <br />www6.software.ibm.com:443 &ndash; showcerts 
&hellip;
 s:/C=US/O=Equifax/OU=Equifax Secure Certificate Authority 
 i:/C=US/O=Equifax/OU=Equifax Secure Certificate Authority 
 -----BEGIN CERTIFICATE----- 
 MIIDIDCCAomgAwIBAgIENd70zzANBgkqhkiG9w0BAQUFADBOMQswCQYDVQQGEwJV 
 UzEQMA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2Vy 
 dGlmaWNhdGUgQXV0aG9yaXR5MB4XDTk4MDgyMjE2NDE1MVoXDTE4MDgyMjE2NDE1 
 MVowTjELMAkGA1UEBhMCVVMxEDAOBgNVBAoTB0VxdWlmYXgxLTArBgNVBAsTJEVx 
 dWlmYXggU2VjdXJlIENlcnRpZmljYXRlIEF1dGhvcml0eTCBnzANBgkqhkiG9w0B 
 AQEFAAOBjQAwgYkCgYEAwV2xWGcIYu6gmi0fCG2RFGiYCh7+2gRvE4RiIcPRfM6f 
 BeC4AfBONOziipUEZKzxa1NfBbPLZ4C/QgKO/t0BCezhABRP/PvwDN1Dulsr4R+A 
 cJkVV5MW8Q+XarfCaCMczE1ZMKxRHjuvK9buY0V7xdlfUNLjUA86iOe/FP3gx7kC 
 AwEAAaOCAQkwggEFMHAGA1UdHwRpMGcwZaBjoGGkXzBdMQswCQYDVQQGEwJVUzEQ 
 MA4GA1UEChMHRXF1aWZheDEtMCsGA1UECxMkRXF1aWZheCBTZWN1cmUgQ2VydGlm 
 aWNhdGUgQXV0aG9yaXR5MQ0wCwYDVQQDEwRDUkwxMBoGA1UdEAQTMBGBDzIwMTgw 
 ODIyMTY0MTUxWjALBgNVHQ8EBAMCAQYwHwYDVR0jBBgwFoAUSOZo+SvSspXXR9gj 
 IBBPM5iQn9QwHQYDVR0OBBYEFEjmaPkr0rKV10fYIyAQTzOYkJ/UMAwGA1UdEwQF 
 MAMBAf8wGgYJKoZIhvZ9B0EABA0wCxsFVjMuMGMDAgbAMA0GCSqGSIb3DQEBBQUA 
 A4GBAFjOKer89961zgK5F7WF0bnj4JXMJTENAKaSbn+2kmOeUJXRmm/kEd5jhW6Y 
 7qj/WsjTVbJmcVfewCHrPSqnI0kBBIZCe/zuf6IWUrVnZ9NA2zsmWLIodz2uFHdh 
 1voqZiegDfqnc1zqcPGUIWVEX/r87yloqaKHee9570+sB3c4 
 -----END CERTIFICATE-----</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 3. 运用 s_client 参数-CAfile CA.pem再次连接服务器</p>
<p>&nbsp;&nbsp;&nbsp; 清单 8. 设定服务器证书文件建立 SSL 连接</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wkswss openssl]# openssl s_client -CAfile serverCA.pem <br />-connect 
 www6.software.ibm.com:443 -state 
 CONNECTED(00000003) 
 SSL_connect:before/connect initialization 
 SSL_connect:SSLv2/v3 write client hello A 
 SSL_connect:SSLv3 read server hello A 
 depth=1 /C=US/O=Equifax/OU=Equifax Secure Certificate Authority 
 verify return:1 
 depth=0 /C=US/O=IBM/CN=www6.software.ibm.com 
 verify return:1 
 SSL_connect:SSLv3 read server certificate A 
 SSL_connect:SSLv3 read server done A 
 SSL_connect:SSLv3 write client key exchange A 
 SSL_connect:SSLv3 write change cipher spec A 
 SSL_connect:SSLv3 write finished A 
 SSL_connect:SSLv3 flush data 
 SSL_connect:SSLv3 read finished A 
&hellip;&hellip;
 SSL-Session: 
    Protocol  : TLSv1 
    Cipher    : DES-CBC3-SHA 
    Session-ID: 00365044871540E334826<br />923BF9C531CE659274858585858499C14380000000C 
    Session-ID-ctx: 
    Master-Key: 
 D065F1F2297560F1CD4CCC0D7A58E647<br />CC9F596BCEC545CF90DD54659CB36C53CDAC977E5784C6 
 A273BA28B486E578B9 
    Key-Arg   : None 
    Krb5 Principal: None 
    Start Time: 1234986898 
    Timeout   : 300 (sec) 
    Verify return code: 0 (ok)</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; ●客户端拥有认证服务器证书的根证书，但是服务器被防火墙隔离，防火墙在收到来自客户端的 SSL 连接请求时返回防火墙的证书。这种情况下的症状跟服务器证书被篡改非常相似，但是区别在于应用上述提及的方法仍然不能定位错误。<br />&nbsp;&nbsp;&nbsp; 1. 客户端已经拥有服务器 build.rchland.ibm.com 的根证书rochCA.pem，当客户端试图连接服务器客户时，对服务器的证书认证却不能通过。</p>
<p>&nbsp;&nbsp;&nbsp; 清单 9. 认证失败</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wks547385wss openssl]# openssl s_client<br /> -CAfile roch.pem -state -connect 
 build.rchland.ibm.com:443 
 CONNECTED(00000003) 
 SSL_connect:before/connect initialization 
 SSL_connect:SSLv2/v3 write client hello A 
 SSL_connect:SSLv3 read server hello A 
 depth=0 /serialNumber=93e352/CN=<br />rch-fw-1a.rchland.ibm.com/unstructuredName= 
 rch-fw-1a.rchland.ibm.com 
 verify error:num=18:self signed certificate 
 verify return:1 
 depth=0 /serialNumber=93e352/CN=<br />rch-fw-1a.rchland.ibm.com/unstructuredName= 
 rch-fw-1a.rchland.ibm.com 
 verify return:1 
 SSL_connect:SSLv3 read server certificate A 
 SSL_connect:SSLv3 read server done A 
 SSL_connect:SSLv3 write client key exchange A 
 SSL_connect:SSLv3 write change cipher spec A 
 SSL_connect:SSLv3 write finished A 
 SSL_connect:SSLv3 flush data 
 SSL_connect:SSLv3 read finished A 
&hellip;</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 2. 使用x509工具，查看根证书的具体内容，特别是证书签发者和持有者的身份，如清单 10 所示。</p>
<p>&nbsp;&nbsp;&nbsp; 清单 10. 解码根证书</p>
<p>&nbsp;&nbsp;&nbsp;</p>
<table style="width: 80%;" border="1" cellspacing="0" cellpadding="1" align="center" bgcolor="#ffffff">
<tbody>
<tr>
<td>
<pre class="displaycode">[root@wks547385wss openssl]# openssl x509 -text -in roch.pem 
 Certificate: 
    Data: 
        Version: 3 (0x2) 
        Serial Number: 903804111 (0x35def4cf) 
        Signature Algorithm: sha1WithRSAEncryption 
        Issuer: C=US, O=Equifax, OU=Equifax Secure<br /> Certificate Authority 
        Validity 
            Not Before: Aug 22 16:41:51 1998 GMT 
            Not After : Aug 22 16:41:51 2018 GMT 
        Subject: C=US, O=Equifax, OU=Equifax<br /> Secure Certificate Authority 
        Subject Public Key Info: 
            Public Key Algorithm: rsaEncryption 
            RSA Public Key: (1024 bit)</pre>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; 有了上述的证书签发者信息后，我们的问题就迎刃而解了，客户端收到了来自防火墙的证书，该证书和防火墙后面的服务器的数字证书来自不同的签发者。</p>
<p><strong>&nbsp;&nbsp;&nbsp; 结束语</strong></p>
<p>&nbsp;&nbsp;&nbsp; openssl 提供的 ssl 库被广泛的运用的同时，也增加了程序员在诊断通讯故障的难度。巧妙的运用 s_client 无疑给程序员带来了一把利刃，特别是缺乏调试工具的环境下，如嵌入式系统。</p>]]></description></item><item><title>nginx cocos2dx and so on</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/09/nginx.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Thu, 09 May 2013 10:25:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/09/nginx.html</guid><description><![CDATA[<p>===================================================</p>
<p>ubuntu&nbsp;</p>
<p>1.到nginx官网下载源码包。最好下载稳定版本，nginx官网http://www.nginx.org/</p>
<p>2.安装nginx依赖包运行命令：</p>
<p>sudo apt-get install libssl-dev<br />sudo apt-get install libpcre3 libpcre3-dev</p>
<p>3.解压下载的nginx源码包。检查编译环境 ./configure --prefix=/usr/local/nginx</p>
<p>4.编译安装 make &amp;&amp; make install</p>
<p>5.到nginx安装目录执行启动命令：/usr/local/nginx/sbin/nginx</p>
<p>关闭命令：/usr/local/sbin/nginx -s stop (停止)<br />重启命令：/usr/local/sbin/nginx -s reload (重启)</p>
<p>启动之后浏览器中http://localhost/查看是否成功。</p>
<p>&nbsp;</p>
<p>6.nginx配置文件所在目录/usr/local/nginx/conf/nginx.conf</p>
<p>配置文件详解如下：</p>
<p>#运行用户&nbsp;<br />#user&nbsp; nobody;<br />#启动进程&nbsp;<br />worker_processes&nbsp; 1;<br /><br />#全局错误日志及PID文件&nbsp;<br />#error_log&nbsp; logs/error.log;<br />#error_log&nbsp; logs/error.log&nbsp; notice;<br />#error_log&nbsp; logs/error.log&nbsp; info;<br /><br />#pid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; logs/nginx.pid;<br /><br />#工作模式及连接数上限&nbsp;<br />events {<br />&nbsp;&nbsp;&nbsp; use epoll;&nbsp;<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; worker_connections&nbsp; 1024;<br />}<br /><br />#设定http服务器，利用它的反向代理功能提供负载均衡支持&nbsp;<br />http {<br />&nbsp;&nbsp;&nbsp; #设定mime类型&nbsp;<br />&nbsp;&nbsp;&nbsp; include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mime.types;<br />&nbsp;&nbsp;&nbsp; default_type&nbsp; application/octet-stream;<br />&nbsp;&nbsp;&nbsp; #设定日志格式<br />&nbsp;&nbsp;&nbsp;&nbsp; #log_format&nbsp; main&nbsp; '$remote_addr - $remote_user [$time_local] "$request" '<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '$status $body_bytes_sent "$http_referer" '<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '"$http_user_agent" "$http_x_forwarded_for"';<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #access_log&nbsp; logs/access.log&nbsp; main;<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; sendfile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #tcp_nopush&nbsp;&nbsp;&nbsp;&nbsp; on;<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #keepalive_timeout&nbsp; 0;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #客户端和nginx之间空闲链接超时时间<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; keepalive_timeout&nbsp; 120;<br /><br />&nbsp;&nbsp;&nbsp; #设定负载均衡的服务器列表<br />&nbsp;&nbsp;&nbsp; upstream mysvr {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #weigth参数表示权值，权值越高被分配到的几率越大<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #本机上的Squid开启3128端口<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; server 127.0.0.1:8080 weight=1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #server 119.254.82.237:8080&nbsp; weight=1;<br />&nbsp;&nbsp;&nbsp; }&nbsp;<br />&nbsp;&nbsp;&nbsp; #是否开启gzip模块&nbsp;<br />&nbsp;&nbsp;&nbsp; #gzip&nbsp; on;<br />&nbsp;&nbsp;&nbsp; #gzip_min_length&nbsp; 1100;<br />&nbsp;&nbsp;&nbsp; #gzip_buffers&nbsp;&nbsp;&nbsp; 4 8k;<br />&nbsp;&nbsp;&nbsp; #gzip_types&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text/plain;&nbsp;<br />&nbsp;&nbsp;&nbsp; #设定虚拟主机&nbsp;<br />&nbsp;&nbsp;&nbsp; server {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; server_name&nbsp; localhost;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #charset koi8-r;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #设定本虚拟主机的访问日志&nbsp;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #access_log&nbsp; logs/host.access.log&nbsp; main;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #location / {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; html;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; index&nbsp; index.html index.htm;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;# }<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #error_page&nbsp; 404&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /404.html;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # redirect server error pages to the static page /50x.html<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; error_page&nbsp;&nbsp; 500 502 503 504&nbsp; /50x.html;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; location = /50x.html {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; html;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # proxy the PHP scripts to Apache listening on 127.0.0.1:80<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #location ~ \.php$ {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; proxy_pass&nbsp;&nbsp; http://127.0.0.1;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #}<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #location ~ \.php$ {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; html;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; fastcgi_pass&nbsp;&nbsp; 127.0.0.1:9000;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; fastcgi_index&nbsp; index.php;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; fastcgi_param&nbsp; SCRIPT_FILENAME&nbsp; /scripts$fastcgi_script_name;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; include&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fastcgi_params;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #}<br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # deny access to .htaccess files, if Apache's document root<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # concurs with nginx's one<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #location ~ /\.ht {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; deny&nbsp; all;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #}<br /><br /><br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #对 "/" 启用负载均衡<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; location / {<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_pass&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; http://mysvr;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_redirect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; off;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_set_header&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Host $host;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_set_header&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X-Real-IP $remote_addr;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_set_header&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X-Forwarded-For $proxy_add_x_forwarded_for;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; #客户端body中最大数据量<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; client_max_body_size&nbsp;&nbsp;&nbsp; 10m;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; client_body_buffer_size 128k;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # 链接到主机超时时间<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_connect_timeout&nbsp; 90;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # 向主机发送数据超时时间<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_send_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; # 从主机读取数据超时时间<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_read_timeout&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 90;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_buffer_size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4k;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4 32k;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_busy_buffers_size 64k;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; proxy_temp_file_write_size 64k;<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }&nbsp;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; # another virtual host using mix of IP-, name-, and port-based configuration<br />&nbsp;&nbsp;&nbsp; #server {<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8000;<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; listen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; somename:8080;<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; server_name&nbsp; somename&nbsp; alias&nbsp; another.alias;<br /><br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; location / {<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp; html;<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; index&nbsp; index.html index.htm;<br />&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; #}<br />}</p>]]></description></item><item><title>windows ssh client-----------PuTTY</title><link>http://www.cnblogs.com/isohybrid/archive/2013/05/01/PuTTY.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Tue, 30 Apr 2013 17:08:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/05/01/PuTTY.html</guid><description><![CDATA[<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html">http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html</a></p>
<p>&nbsp;</p>
<p>PuTTY</p>]]></description></item><item><title>有趣的linux命令</title><link>http://www.cnblogs.com/isohybrid/archive/2013/04/23/linux_fun.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Mon, 22 Apr 2013 16:53:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/04/23/linux_fun.html</guid><description><![CDATA[<p><span>1.<span>sl</span>&nbsp;命令</span><br /><span>　首先，安装&nbsp;&nbsp;&nbsp; $ sudo apt-get install sl</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><br /><span>&nbsp;&nbsp;&nbsp;</span><span>然后，输入&nbsp;&nbsp;&nbsp; $ sl</span><br /><span>　我们看到了动画蒸汽机机头从屏幕右边开往左边。这个火车头是用ASCLL字符绘制。</span><br /><span>&nbsp;&nbsp;&nbsp;</span><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_13665292334oFT.png" alt="" width="462" height="253" /><span>&nbsp;</span><br /><span>提供特定的选项如下：（详细命令参考：</span><a href="http://man.cx/sl%286%29" target="_blank"><span>http://man.cx/sl%286%29</span></a><span>）</span><br /><span>SYNOPSIS</span><br /><span>sl [ -alFe ]</span><br /><br /><span>DESCRIPTION</span><br /><span>sl Displays animations aimed to correct users who accidentally enter sl instead of ls. SL stands for Steam Locomotive.</span><br /><br /><span>OPTIONS</span><br /><span>-a An accident seems to happen. You'll feel pity for people who cry for help.</span><br /><br /><span>-l shows little one.</span><br /><br /><span>-F It flies.</span><br /><br /><span>-e Allow interrupt by Ctrl+C.</span><br /><br /><span>2.&nbsp;<span>rev</span>&nbsp;命令</span><span>（</span><span>reverse</span><span>）</span><br /><span>　它会颠倒所输入的字符串。</span><br /><span>&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;$rev</span><br /><span>　终端会提示我们通过标准输入提供一个字符串。那么在每行后面我们就可以同时看到输出。</span><br /><span>　比如，我们输入"mylinuxbook"然后按回车。</span><br /><span>&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;mylinuxbook</span><br /><span>&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;koobxunilym</span><br /><span>　</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$ cat strings.txt</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>MyLinuxBook</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Linux is so much fun!</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>Happy Birthday</span><br /><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$ rev strings.txt</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>kooBxuniLyM</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>!nuf hcum os si xuniL</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>yadhtriB yppaH</span><br /><br /><span>3.<span>&nbsp;fortune</span>&nbsp; 命令</span><br /><span>　</span><span>我们运行这个命令的时候随机找了一条谚语或信息。</span><br /><span>　首先要对其进行安装：</span><span>$sudo apt-get install fortune</span><br /><span>　运行这个命令：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ fortune</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>You have the power to influence all with whom you come in contact.</span><br /><br /><span>4.&nbsp;<span>figlet&nbsp;</span>命令</span><br /><span>　　这个命令会用大写方式把我们输入的字符串显示在标题栏，显示效果由ASCII字符组成。</span><br /><span>　　先安装：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;$sudo apt-get install figlet</span><br /><span>　　输入：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ figlet mylinuxbook</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549319kkKl.png" alt="" width="456" height="98" /><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>你可以试着用"figlet"在脚本标头或源代码中添加标题栏。</span><br /><br /><span>5.<span>toilet&nbsp;</span>命令</span><br /><span>　　它是个五颜六色的命令。与figlet一样，它会把文本显示称标题栏，但是效果更好。</span><br /><span>　&nbsp;&nbsp;&nbsp;&nbsp;安装：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$sudo apt-get install toilet</span><br /><span>　　 输入：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;$toilet mylinuxbook</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549503oR3L.png" alt="" width="469" height="99" /><br /><span>　　它比figlet命令的效果更有艺术感。</span><br /><span>　　不过，它还可以添加颜色。我们可以运行下列命令看到颜色：</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;$toilet -f mono12 -F metal mylinuxbook</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549596mA07.png" alt="" width="477" height="220" /><br /><br /><span>6.&nbsp;<span>cowsay</span>&nbsp;&nbsp;</span><span>命令</span><br /><span>　　</span><span>它会用ASCII字符描绘牛，羊和许多其他动物。但是不是每个Linux发行版都带有这个命令。</span><br /><span>　　使用下面的命令安装此命令：</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$sudo apt-get install cowsay</span><br /><span>　　现在，运行命令，并在命令中给出一个信息字符串。</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$cowsay &ldquo;Linux is fun&rdquo;</span><br /><span>　　我们看到了一个有趣的图像：</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549677NgGV.png" alt="" width="338" height="178" /><br /><span>　　基本上，我们会看到一头牛告诉我们所输入的信息。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 尽管这个命令中只出现了cow，但其实它还可以有羊的效果。</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$cowsay -f sheep &ldquo;I too love linux&rdquo;</span><br /><span>　　效果如图：</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549732aVJ5.png" alt="" width="341" height="241" /><span>　　</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>只需用 '-l 就能看到它能提供的所有动物。输入：</span><br /><span>$cowsay -l</span><br /><span>　系统会弹出下列信息：</span><br /><span>Cow files in /usr/share/cowsay/cows:</span><br /><span>apt beavis.zen bong bud-frogs bunny calvin cheese cock cower daemon default</span><br /><span>dragon dragon-and-cow duck elephant elephant-in-snake eyes flaming-sheep</span><br /><span>ghostbusters gnu head-in hellokitty kiss kitty koala kosh luke-koala</span><br /><span>mech-and-cow meow milk moofasa moose mutilated pony pony-smaller ren sheep</span><br /><span>skeleton snowman sodomized-sheep stegosaurus stimpy suse three-eyes turkey</span><br /><span>turtle tux unipony unipony-smaller vader vader-koala www</span><br /><span>　　因此，我们可以用 '-f' 输入以上信息中的任何动物。</span><br /><span><br />如：</span><span>cowsay -f milk "Do you want to drink?"</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549883Lzc7.png" alt="" width="286" height="437" /><br /><span>　　<br />为了使之更有趣，你可以让cowsay说出fortune信息，如输入：</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>$fortune | cowsay</span><br /><span>　　则出现下面的效果：</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_1366549956J6I0.png" alt="" width="425" height="194" /><br /><br /><span>7．<span>cmatrix</span>&nbsp;命令</span><br /><span>　　这个命令会在终端生成ASCII字符组成的矩阵风格的动画效果。</span><br /><span>　　先安装：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ sudo apt-get install cmatrix</span><br /><span>　　现在运行：</span><span>&nbsp;&nbsp;&nbsp; $&nbsp;</span><span>cmatrix</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_13665500508VJy.png" alt="" width="561" height="320" /><br /><span>　　用"ctrl+c" 结束，生成动画。</span><br /><br /><span>8.&nbsp;<span>oneko&nbsp;</span>&nbsp;</span><span>命令</span><br /><span>　&nbsp;&nbsp;</span><span>我们都知道"猫和老鼠"的动画，这个命令会让我们想起他们的追逐游戏。</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;</span><span>有了这行命令，我们可以看到一只猫在追老鼠（鼠标指示器）的效果。</span><br /><span>　　先安装：</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $sudo apt-get install oneko</span><br /><span>　　运行这个命令：</span><span>&nbsp;&nbsp;&nbsp; $&nbsp;</span><span>oneko</span><br /><span>　　然后你就可以看到不管鼠标指示器放到哪里，Tom猫都会追着跑。下面是截图，不过不足以显示动态的效果：</span><br /><img src="http://blog.chinaunix.net/attachment/201304/21/27004869_136655018129Pl.png" alt="" width="366" height="256" /><br /><br /><span>　　即便我们切换应用，猫也不会离开老鼠。它甚至没有局限于终端。</span><br /><span>　　想关掉这个的时候，只需在终端里用ctrl+c 结束进程即可。</span></p>
<p>&nbsp;</p>
<p><span>转自<a href="http://blog.chinaunix.net/uid-27004869-id-3608539.html">http://blog.chinaunix.net/uid-27004869-id-3608539.html</a></span></p>]]></description></item><item><title>MapReduce</title><link>http://www.cnblogs.com/isohybrid/archive/2013/04/08/MapReduce.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Mon, 08 Apr 2013 09:00:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/04/08/MapReduce.html</guid><description><![CDATA[<p><a href="http://blog.csdn.net/OpenNaive/article/details/7514146#comments">http://blog.csdn.net/OpenNaive/article/details/7514146#comments</a></p>
<h2><span>1. MapReduce是干啥的</span></h2>
<div><span>因为没找到谷歌的示意图，所以我想借用一张Hadoop项目的结构图来说明下MapReduce所处的位置，如下图。</span></div>
<div><span><img src="http://my.csdn.net/uploads/201204/26/1335439249_7691.jpg" alt="" /><br /></span></div>
<div><span>Hadoop实际上就是谷歌三宝的开源实现，Hadoop MapReduce对应Google MapReduce，HBase对应BigTable，HDFS对应GFS。HDFS（或GFS）为上层提供高效的非结构化存储服务，HBase（或BigTable）是提供结构化数据服务的分布式数据库，Hadoop MapReduce（或Google MapReduce）是一种并行计算的编程模型，用于作业调度。</span></div>
<p><span>GFS和BigTable已经为我们提供了高性能、高并发的服务，但是并行编程可不是所有程序员都玩得转的活儿，如果我们的应用本身不能并发，那GFS、BigTable也都是没有意义的。MapReduce的伟大之处就在于让不熟悉并行编程的程序员也能充分发挥分布式系统的威力。</span></p>
<p><span>简单概括的说，MapReduce是将一个大作业拆分为多个小作业的框架（大作业和小作业应该本质是一样的，只是规模不同），用户需要做的就是决定拆成多少份，以及定义作业本身。</span></p>
<p><span>下面用一个贯穿全文的例子来解释MapReduce是如何工作的。</span></p>
<h2><a name="t1"></a><span>2. 例子：统计词频</span></h2>
<p><span>如果我想统计下过去10年计算机论文出现最多的几个单词，看看大家都在研究些什么，那我收集好论文后，该怎么办呢？</span></p>
<p><span>方法一：我可以写一个小程序，把所有论文按顺序遍历一遍，统计每一个遇到的单词的出现次数，最后就可以知道哪几个单词最热门了。</span></p>
<p><span>这种方法在数据集比较小时，是非常有效的，而且实现最简单，用来解决这个问题很合适。</span></p>
<p><span>方法二：写一个多线程程序，并发遍历论文。</span></p>
<p><span>这个问题理论上是可以高度并发的，因为统计一个文件时不会影响统计另一个文件。当我们的机器是多核或者多处理器，方法二肯定比方法一高效。但是写一个多线程程序要比方法一困难多了，我们必须自己同步共享数据，比如要防止两个线程重复统计文件。</span></p>
<p><span>方法三：把作业交给多个计算机去完成。</span></p>
<p><span>我们可以使用方法一的程序，部署到N台机器上去，然后把论文集分成N份，一台机器跑一个作业。这个方法跑得足够快，但是部署起来很麻烦，我们要人工把程序copy到别的机器，要人工把论文集分开，最痛苦的是还要把N个运行结果进行整合（当然我们也可以再写一个程序）。</span></p>
<p><span>方法四：让MapReduce来帮帮我们吧！</span></p>
<p><span>MapReduce本质上就是方法三，但是如何拆分文件集，如何copy程序，如何整合结果这些都是框架定义好的。我们只要定义好这个任务（用户程序），其它都交给MapReduce。</span></p>
<p><span>在介绍MapReduce如何工作之前，先讲讲两个核心函数map和reduce以及MapReduce的伪代码。</span></p>
<h2><a name="t2"></a><span>3. map函数和reduce函数</span></h2>
<p><span>map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</span></p>
<p>&nbsp;</p>
<ul>
<li><span>map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</span></li>
<li><span>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</span></li>

</ul>
<p><span>统计词频的MapReduce函数的核心代码非常简短，主要就是实现这两个函数。</span></p>
<p>&nbsp;</p>
<div class="dp-highlighter bg_plain">
<div class="bar">
<div class="tools"><strong>[plain]</strong>&nbsp;<a class="ViewSource" title="view plain" href="http://blog.csdn.net/OpenNaive/article/details/7514146">view plain</a><a class="CopyToClipboard" title="copy" href="http://blog.csdn.net/OpenNaive/article/details/7514146">copy</a><a class="PrintSource" title="print" href="http://blog.csdn.net/OpenNaive/article/details/7514146">print</a><a class="About" title="?" href="http://blog.csdn.net/OpenNaive/article/details/7514146">?</a>
<div>&nbsp;</div>

</div>

</div>
<ol start="1">
<li class="alt"><span><span>map(String&nbsp;key,&nbsp;String&nbsp;value):&nbsp;&nbsp;</span></span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;key:&nbsp;document&nbsp;name&nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;value:&nbsp;document&nbsp;contents&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;each&nbsp;word&nbsp;w&nbsp;in&nbsp;value:&nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EmitIntermediate(w,&nbsp;"1");&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
<li class="alt"><span>reduce(String&nbsp;key,&nbsp;Iterator&nbsp;values):&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;key:&nbsp;a&nbsp;word&nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;values:&nbsp;a&nbsp;list&nbsp;of&nbsp;counts&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;&nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;each&nbsp;v&nbsp;in&nbsp;values:&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;+=&nbsp;ParseInt(v);&nbsp;&nbsp;</span></li>
<li class="alt"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Emit(AsString(result));&nbsp;&nbsp;</span></li>

</ol></div>
<p>&nbsp;</p>
<p>
<span>在统计词频的例子里，map函数接受的键是文件名，值是文件的内容，map逐个遍历单词，每遇到一个单词w，就产生一个中间键值对&lt;w, "1"&gt;，这表示单词w咱又找到了一个；MapReduce将键相同（都是单词w）的键值对传给reduce函数，这样reduce函数接受的键就是单词w，值是一串"1"（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些&ldquo;1&rdquo;累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统（GFS或HDFS）。<br /></span></p>
<h2><a name="t3"></a><span>4. MapReduce是如何工作的</span></h2>
<div><span><img src="http://img.my.csdn.net/uploads/201204/26/1335443612_8438.jpg" alt="" width="600" height="400" /><br /></span></div>
<p>&nbsp;</p>
<p><span>上图是论文里给出的流程图。一切都是从最上方的user program开始的，user program链接了MapReduce库，实现了最基本的Map函数和Reduce函数。图中执行的顺序都用数字标记了。</span></p>
<ol>
<li><span>MapReduce库先把user program的输入文件划分为M份（M为用户定义），每一份通常有16MB到64MB，如图左方所示分成了split0~4；然后使用fork将用户进程拷贝到集群内其它机器上。</span></li>
<li><span>user program的副本中有一个称为master，其余称为worker，master是负责调度的，为空闲worker分配作业（Map作业或者Reduce作业），worker的数量也是可以由用户指定的。</span></li>
<li><span>被分配了Map作业的worker，开始读取对应分片的输入数据，Map作业数量是由M决定的，和split一一对应；Map作业从输入数据中抽取出键值对，每一个键值对都作为参数传递给map函数，map函数产生的中间键值对被缓存在内存中。</span></li>
<li><span>缓存的中间键值对会被定期写入本地磁盘，而且被分为R个区，R的大小是由用户定义的，将来每个区会对应一个Reduce作业；这些中间键值对的位置会被通报给master，master负责将信息转发给Reduce worker。</span></li>
<li><span>master通知分配了Reduce作业的worker它负责的分区在什么位置（肯定不止一个地方，每个Map作业产生的中间键值对都可能映射到所有R个不同分区），当Reduce worker把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是同一个Reduce作业（谁让分区少呢），所以排序是必须的。</span></li>
<li><span>reduce worker遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce函数，reduce函数产生的输出会添加到这个分区的输出文件中。</span></li>
<li><span>当所有的Map和Reduce作业都完成了，master唤醒正版的user program，MapReduce函数调用返回user program的代码。</span></li>

</ol>
<p>所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一个MapReduce程序处理。整个过程中，输入数据是来自底层分布式文件系统（GFS）的，中间数据是放在本地文件系统的，最终输出数据是写入底层分布式文件系统（GFS）的。而且我们要注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。</p>
<p>我更喜欢把流程分为三个阶段。第一阶段是准备阶段，包括1、2，主角是MapReduce库，完成拆分作业和拷贝用户程序等任务；第二阶段是运行阶段，包括3、4、5、6，主角是用户定义的map和reduce函数，每个小作业都独立运行着；第三阶段是扫尾阶段，这时作业已经完成，作业结果被放在输出文件里，就看用户想怎么处理这些输出了。</p>
<h2><a name="t4"></a>5. 词频是怎么统计出来的</h2>
<p>结合第四节，我们就可以知道第三节的代码是如何工作的了。假设咱们定义M=5，R=3，并且有6台机器，一台master。</p>
<p><img src="http://my.csdn.net/uploads/201204/26/1335448208_7308.jpg" alt="" /></p>
<p>这幅图描述了MapReduce如何处理词频统计。由于map worker数量不够，首先处理了分片1、3、4，并产生中间键值对；当所有中间值都准备好了，Reduce作业就开始读取对应分区，并输出统计结果。</p>
<h2><a name="t5"></a>6. 用户的权利</h2>
<div>用户最主要的任务是实现map和reduce接口，但还有一些有用的接口是向用户开放的。</div>
<div>
<ul>
<li><span>an input reader。这个函数会将输入分为M个部分，并且定义了如何从数据中抽取最初的键值对，比如词频的例子中定义文件名和文件内容是键值对。</span></li>
<li><span>a partition function。这个函数用于将map函数产生的中间键值对映射到一个分区里去，最简单的实现就是将键求哈希再对R取模。</span></li>
<li><span>a compare function。这个函数用于Reduce作业排序，这个函数定义了键的大小关系。</span></li>
<li><span>an output writer。负责将结果写入底层分布式文件系统。</span></li>
<li><span>a combiner function。实际就是reduce函数，这是用于前面提到的优化的，比如统计词频时，如果每个&lt;w, "1"&gt;要读一次，因为reduce和map通常不在一台机器，非常浪费时间，所以可以在map执行的地方先运行一次combiner，这样reduce只需要读一次&lt;w, "n"&gt;了。</span></li>
<li><span>map和reduce函数就不多说了。</span></li>

</ul>
<h2><a name="t6"></a><span>7. MapReduce的实现</span></h2>

</div>
<div><span>目前MapReduce已经有多种实现，除了谷歌自己的实现外，还有著名的hadoop，区别是谷歌是c++，而hadoop是用java。另外斯坦福大学实现了一个在多核/多处理器、共享内存环境内运行的MapReduce，称为Phoenix（<a href="http://www.fumin.me/?p=110">介绍</a>），相关的论文发表在07年的HPCA，是当年的最佳论文哦！</span></div>
<h2><a name="t7"></a><span>参考文献</span></h2>
<div><span>[1]&nbsp;MapReduce : Simplified Data Processing on Large Clusters. In proceedings of OSDI'04.</span></div>
<div><span>[2] Wikipedia.&nbsp;<a href="http://en.wikipedia.org/wiki/Mapreduce">http://en.wikipedia.org/wiki/Mapreduce</a></span></div>
<div>[3] Phoenix.&nbsp;<a href="http://mapreduce.stanford.edu/">http://mapreduce.stanford.edu/</a></div>
<div>[4]&nbsp;Evaluating MapReduce for Multi-core and Multiprocessor Systems. In proceedings of HPCA'07.</div>]]></description></item><item><title>HADOOP</title><link>http://www.cnblogs.com/isohybrid/archive/2013/04/03/hadoop.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 03 Apr 2013 08:19:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/04/03/hadoop.html</guid><description><![CDATA[<p>THE FIRST STEP</p>
<p>==============JAVA INSTALL=====================</p>
<p>wget -c &nbsp;http://download.oracle.com/otn-pub/java/jdk/7u17-b02/jdk-7u17-linux-i586.tar.gz</p>
<p>wget -c&nbsp;http://download.oracle.com/otn-pub/java/jdk/7u17-b02/jre-7u17-linux-i586.tar.gz</p>
<p>tar zxvf jdk&amp;&amp;jre</p>
<p>chmod a+x /usr/local/java</p>
<p>==============ATTATCH TO /etc/profile=============</p>
<p>JAVA_HOME=/usr/local/java/jdk1.7.0_12<br />PATH=$PATH:$HOME/bin:$JAVA_HOME/bin<br />JRE_HOME=/usr/local/java/jre1.7.0_12<br />PATH=$PATH:$HOME/bin:$JRE_HOME/bin</p>
<p>==============source .profile======================</p>
<p>==============java -version to verify================</p>
<p><span style="color: #ff0000;">suma@vm12:~$ java -version</span><br /><span style="color: #ff0000;">-bash: /usr/local/java/jdk1.7.0_12/bin/java: No such file or directory</span></p>
<p>&nbsp;This message is shown because some 32 bit libraries are absent in Ubuntu 64 bit. Run:</p>
<pre><code>apt-get install libc6-i386
</code></pre>
<p>See&nbsp;&nbsp;<a href="http://stackoverflow.com/questions/9081962/java-is-installed-in-listing-but-execution-produces-java-no-such-file-or-d/9082947#9082947">http://stackoverflow.com/questions/9081962/java-is-installed-in-listing-but-execution-produces-java-no-such-file-or-d/9082947#9082947</a>&nbsp;for more details</p>
<p><a href="http://askubuntu.com/questions/207552/no-such-file-or-directory-when-invoking-java">http://askubuntu.com/questions/207552/no-such-file-or-directory-when-invoking-java</a></p>
<p>================================================</p>]]></description></item><item><title>kvm之ubuntu</title><link>http://www.cnblogs.com/isohybrid/archive/2013/03/31/kvm.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 31 Mar 2013 12:31:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/03/31/kvm.html</guid><description><![CDATA[<p align="left"><strong><span style="font-family: 'Times New Roman';">1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></strong><strong>首页附注</strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p>我在本文中使用主机名为<span style="font-family: 'Times New Roman';">server1.example.com</span>和<span style="font-family: 'Times New Roman';">IP</span>地址为<span style="font-family: 'Times New Roman';">192.168.0.100</span>的机器作为<span style="font-family: 'Times New Roman';">KVM</span>主机。</p>
<p>由于我们将以根用户权限（<span style="font-family: 'Times New Roman';">root privilege</span>）运行本文介绍的所有步骤，所以可以用字符串<span style="font-family: 'Times New Roman';">sudo</span>为本教程中的所有命令加上前缀，或者只需输入下面这个命令，立即成为根用户。</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';">sudo su</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p align="center"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">2.&nbsp;</span></strong><strong>安装<span style="font-family: 'Times New Roman';">KVM</span></strong><strong>和<span style="font-family: 'Times New Roman';">vmbuilder</span></strong></p>
<p>首先检查你的处理器是否支持硬件虚拟化；如果支持，下面这个命令</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';">egrep '(vmx|svm)' --color=always /proc/cpuinfo</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>应该会显示这样的内容：</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# egrep '(vmx|svm)' --color=always /proc/cpuinfo</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm 3dnowext 3dnow rep_good nopl extd_apicid</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">pni cx16 lahf_lm cmp_legacy svm extapic cr8_legacy 3dnowprefetch lbrv</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">flags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm 3dnowext 3dnow rep_good nopl extd_apicid</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">pni cx16 lahf_lm cmp_legacy svm extapic cr8_legacy 3dnowprefetch lbrv</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:~#</em></span></p>
<p>要是什么都没显示，那么你的处理器不支持硬件虚拟化，你必须在此停住。</p>
<p>想安装<span style="font-family: 'Times New Roman';">KVM</span>和<span style="font-family: 'Times New Roman';">vmbuilder</span>（创建基于<span style="font-family: 'Times New Roman';">Ubuntu</span>的虚拟机的一个脚本），我们运行：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>apt-get install ubuntu-virt-server python-vm-builder kvm-ipxe</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>然后运行该命令，确保它准备好运行KVM：<br />$ kvm-ok<br />INFO: /dev/kvm exists<br />KVM acceleration can be used</p>
<p>要是缺漏了什么，它会告诉你KVM加速无法使用。在采用根权限的情况下运行，获得让它正常运行的暗示信息（hint），就像这样：</p>
<p>$ sudo kvm-ok<br /><span>[sudo] password for carla:&nbsp;<br />INFO: /dev/kvm does not exist（/dev/kvm不存在）<br />HINT: sudo modprobe kvm_intel<br />INFO: Your CPU supports KVM extensions（你的处理器支持KVM扩展）<br />INFO: KVM (vmx) is disabled by your BIOS（KVM [vmx]被你的BIOS禁用）<br />HINT: Enter your BIOS setup and enable Virtualization Technology (VT),&nbsp;<br />（进入你的BIOS设置界面，启用虚拟化技术[VT]，）<br />and then hard poweroff/poweron your system<br />（然后对你的系统执行硬关机/开机操作）<br />KVM acceleration can NOT be used（KVM加速无法使用）</span></p>
<p>之后，我们必须将用户作为目前登录的用户（根用户）添加到群组<span style="font-family: 'Times New Roman';">libvirtd</span>：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><em><span style="font-family: 'Times New Roman';">adduser `id -un` libvirtd</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>adduser `id -un` kvm</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>你需要退出，重新登录，那样新的群组成员资格才生效。</p>
<p>想检查<span style="font-family: 'Times New Roman';">KVM</span>是否已成功安装，运行</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>virsh -c qemu:///system list</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>它显示的内容应该像这样：</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# virsh -c qemu:///system list</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;Id Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">----------------------------------</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:~#</em></span></p>
<p>如果它显示的而是错误，那么准是出了什么问题。</p>
<p>接下来，我们需要在服务器上建立网桥，以便可以从其他主机访问我们的虚拟机，好像虚拟机是网络中的物理系统。</p>
<p>为此，我们安装了程序包<span style="font-family: 'Times New Roman';">bridge-utils......</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>apt-get install bridge-utils</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>并配置网桥。打开<span style="font-family: 'Times New Roman';">/etc/network/interfaces</span>：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vi /etc/network/interfaces</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>在改动之前，我的文件像下面这样子：</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>该文件描述了系统上可用的网络接口，</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>以及如何激活这些网络接口。欲知详情，请参阅接口（<span style="font-family: 'Times New Roman';">5</span>）。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>回送网络接口</p>
<p><span style="font-family: 'Times New Roman';">auto lo</span></p>
<p><span style="font-family: 'Times New Roman';">iface lo inet loopback</span></p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>主网络接口</p>
<p><span style="font-family: 'Times New Roman';">auto eth0</span></p>
<p><span style="font-family: 'Times New Roman';">iface eth0 inet static</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address 192.168.0.100</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netmask 255.255.255.0</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network 192.168.0.0</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broadcast 192.168.0.255</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gateway 192.168.0.1</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dns-nameservers&nbsp;8.8.8.8 8.8.4.4</span></p>
<p>我对文件作了更改，以便像下面这样子：</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>该文件描述了系统上可用的网络接口，</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>以及如何激活这些网络接口。欲知详情，请参阅接口（<span style="font-family: 'Times New Roman';">5</span>）。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>回送网络接口</p>
<p><span style="font-family: 'Times New Roman';">auto lo</span></p>
<p><span style="font-family: 'Times New Roman';">iface lo inet loopback</span></p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>主网络接口</p>
<p><span style="font-family: 'Times New Roman';">auto eth0</span></p>
<p><span style="font-family: 'Times New Roman';">iface eth0 inet manual</span></p>
<p><span style="font-family: 'Times New Roman';">auto br0</span></p>
<p><span style="font-family: 'Times New Roman';">iface br0 inet static</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address 192.168.0.100</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network 192.168.0.0</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netmask 255.255.255.0</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broadcast 192.168.0.255</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gateway 192.168.0.1</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dns-nameservers&nbsp;8.8.8.8 8.8.4.4</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_ports eth0</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_fd 9</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_hello 2</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_maxage 12</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bridge_stp off</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;</span></p>
<p>（确保你的网络使用了正确的设置！）</p>
<p>重新启动网络<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>/etc/init.d/networking restart</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>然后运行</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>ifconfig</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>现在它应该显示了网桥（<span style="font-family: 'Times New Roman';">br0</span>）：</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# ifconfig</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">br0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Ethernet&nbsp;&nbsp;HWaddr 00:1e:90:f3:f0:02</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr:192.168.0.100&nbsp;&nbsp;Bcast:192.168.0.255&nbsp;&nbsp;Mask:255.255.255.0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr: fe80::21e:90ff:fef3:f002/64 Scope:Link</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST RUNNING MULTICAST&nbsp;&nbsp;MTU:1500&nbsp;&nbsp;Metric:1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:29 errors:0 dropped:0 overruns:0 frame:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:29 errors:0 dropped:0 overruns:0 carrier:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:0 txqueuelen:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:1934 (1.9 KB)&nbsp;&nbsp;TX bytes:2844 (2.8 KB)</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Ethernet&nbsp;&nbsp;HWaddr 00:1e:90:f3:f0:02</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST RUNNING MULTICAST&nbsp;&nbsp;MTU:1500&nbsp;&nbsp;Metric:1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:44613 errors:0 dropped:0 overruns:0 frame:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:23445 errors:0 dropped:0 overruns:0 carrier:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:0 txqueuelen:1000</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:63663064 (63.6 MB)&nbsp;&nbsp;TX bytes:1792940 (1.7 MB)</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interrupt:41 Base address:0xa000</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">lo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Local Loopback</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr:127.0.0.1&nbsp;&nbsp;Mask:255.0.0.0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet6 addr: ::1/128 Scope:Host</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP LOOPBACK RUNNING&nbsp;&nbsp;MTU:16436&nbsp;&nbsp;Metric:1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:0 txqueuelen:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:0 (0.0 B)&nbsp;&nbsp;TX bytes:0 (0.0 B)</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">virbr0&nbsp;&nbsp;&nbsp;&nbsp;Link encap:Ethernet&nbsp;&nbsp;HWaddr&nbsp;2a:4a:49:13:de:8f</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet addr:192.168.122.1&nbsp;&nbsp;Bcast:192.168.122.255&nbsp;&nbsp;Mask:255.255.255.0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UP BROADCAST MULTICAST&nbsp;&nbsp;MTU:1500&nbsp;&nbsp;Metric:1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collisions:0 txqueuelen:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RX bytes:0 (0.0 B)&nbsp;&nbsp;TX bytes:0 (0.0 B)</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:~#</em></span></p>
<p>在我们开始运行第一个虚拟机之前，建议重新启动系统：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>reboot</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>如果你没有重启，可能会在<span style="font-family: 'Times New Roman';">/var/log/libvirt/qemu/</span>目录的虚拟机日志中看到错误，比如<span style="font-family: 'Times New Roman';">/dev/kvm: Permission denied</span>。</p>
<p>&nbsp;</p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">3.</span></strong><strong>创建基于镜像的虚拟机</strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p>现在我们可以创建第一个虚拟机：基于镜像的虚拟机（如果你预计该虚拟机会有大量的流量和频繁的读写操作，可以改而使用基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机，如下面第<span style="font-family: 'Times New Roman';">6</span>节所示&mdash;&mdash;基于镜像的虚拟机其硬盘输入<span style="font-family: 'Times New Roman';">/</span>输出操作很频繁）。</p>
<p>我想在<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/</span>目录中创建虚拟机（无法在<span style="font-family: 'Times New Roman';">/root</span>目录中创建虚拟机，因为<span style="font-family: 'Times New Roman';">libvirt-qemu</span>用户在该目录中没有读取权限）。</p>
<p>我们将为想要创建的每个虚拟机建立一个新的目录，比如<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm1</span>、<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm2</span>、<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm3</span>等等，因为每个虚拟机都会有一个子目录，名为<span style="font-family: 'Times New Roman';">ubuntu-kvm</span>；很显然，在<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm1</span>中只有这样一个目录。比如说，如果你试图在<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm1</span>创建第二个虚拟机，就会看到错误消息，表明<span style="font-family: 'Times New Roman';">ubuntu-kvm</span>已经存在（除非你使用<span style="font-family: 'Times New Roman';">--dest=DESTDIR</span>变量运行<span style="font-family: 'Times New Roman';">vmbuilder</span>）：</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:/var/lib/libvirt/images/vm1# vmbuilder kvm ubuntu -c vm2.cfg</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">2009-05-07 16:32:44,185 INFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cleaning up</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">ubuntu-kvm already exists</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:/var/lib/libvirt/images/vm1#</em></span></p>
<p>我们会使用<span style="font-family: 'Times New Roman';">vmbuilder</span>工具来创建虚拟机。你可以在此（<a href="https://help.ubuntu.com/community/JeOSVMBuilder"><span style="font-family: 'Times New Roman';">https://help.ubuntu.com/community/JeOSVMBuilder</span></a>）进一步了解<span style="font-family: 'Times New Roman';">vmbuilder</span>。<span style="font-family: 'Times New Roman';">vmbuilder</span>使用模板来创建虚拟机&mdash;&mdash;该模板位于<span style="font-family: 'Times New Roman';">/etc/vmbuilder/libvirt/</span>目录中。我们先创建一个副本：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><em><span style="font-family: 'Times New Roman';">mkdir -p /var/lib/libvirt/images/vm1/mytemplates/libvirt</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>cp /etc/vmbuilder/libvirt/* /var/lib/libvirt/images/vm1/mytemplates/libvirt/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>现在我们进入到虚拟机的分区。我们创建了一个文件，名为<span style="font-family: 'Times New Roman';">vmbuilder.partition&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vi /var/lib/libvirt/images/vm1/vmbuilder.partition</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>并定义所需的分区，如下所示：</p>
<p><span style="font-family: 'Times New Roman';">root 8000</span></p>
<p><span style="font-family: 'Times New Roman';">swap 4000</span></p>
<p><span style="font-family: 'Times New Roman';">---</span></p>
<p><span style="font-family: 'Times New Roman';">/var 20000</span></p>
<p>这定义了大小为<span style="font-family: 'Times New Roman';">800MB</span>的根分区（<span style="font-family: 'Times New Roman';">/</span>）、<span style="font-family: 'Times New Roman';">4000MB</span>的交换分区以及<span style="font-family: 'Times New Roman';">20000MB</span>的<span style="font-family: 'Times New Roman';">/var</span>分区。<span style="font-family: 'Times New Roman';">---</span>这一行表示，下列分区（本例中的<span style="font-family: 'Times New Roman';">/var</span>）在另外的磁盘镜像上（也就是说这将创建两个磁盘镜像，一个用于根分区和交换分区，另一个用于<span style="font-family: 'Times New Roman';">/var</span>分区）。当然，你可以随意定义自己喜欢的任何分区（只要你还定义了根分区和交换分区）；当然，它们可以在一个磁盘镜像中&mdash;&mdash;这只是个例子。</p>
<p>我想在虚拟机中安装<span style="font-family: 'Times New Roman';">openssh-server</span>。为了确保每个虚拟机都获得一个独特的<span style="font-family: 'Times New Roman';">OpenSSH</span>密钥，我们创建虚拟机时无法安装<span style="font-family: 'Times New Roman';">openssh-server</span>。因此，我们创建了名为<span style="font-family: 'Times New Roman';">boot.sh</span>的脚本，虚拟机第一次启动时，就会执行该脚本。它会安装<span style="font-family: 'Times New Roman';">openssh-server</span>（借助独特密钥）；用户第一次登录后，它还会迫使用户更改密码。（我将让虚拟机使用默认的用户名<span style="font-family: 'Times New Roman';">administrator</span>，默认密码是<span style="font-family: 'Times New Roman';">howtoforge</span>）：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vi /var/lib/libvirt/images/vm1/boot.sh</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>虚拟机第一次启动时，该脚本将运行。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>它以根用户来运行。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>到期终止用户帐户</p>
<p><span style="font-family: 'Times New Roman';">passwd -e administrator</span></p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>安装<span style="font-family: 'Times New Roman';">openssh-server</span></p>
<p><span style="font-family: 'Times New Roman';">apt-get update</span></p>
<p><span style="font-family: 'Times New Roman';">apt-get install -qqy --force-yes openssh-server</span></p>
<p>确保你把用户名<span style="font-family: 'Times New Roman';">administrator</span>换成了默认登录名。</p>
<p>（你可以在这里进一步了解这方面：<a href="https://help.ubuntu.com/community/JeOSVMBuilder#First%20boot"><span style="font-family: 'Times New Roman';">https://help.ubuntu.com/community/JeOSVMBuilder#First%20boot</span></a>）</p>
<p>（你还可以定义在此<a href="https://help.ubuntu.com/community/JeOSVMBuilder#First%20login"><span style="font-family: 'Times New Roman';">https://help.ubuntu.com/community/JeOSVMBuilder#First%20login</span></a>描述的&ldquo;首次登录&rdquo;脚本）</p>
<p>现在看一下</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vmbuilder kvm ubuntu --help</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>即可了解可用的选项。</p>
<p>想创建第一个虚拟机<span style="font-family: 'Times New Roman';">vm1</span>，我们进入到虚拟机目录<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>cd /var/lib/libvirt/images/vm1/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>并运行<span style="font-family: 'Times New Roman';">vmbuilder</span>，如下所示：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="732">
<p><em><span style="font-family: 'Times New Roman';">vmbuilder kvm ubuntu --suite=precise --flavour=virtual --arch=amd64 --mirror=http://de.archive.ubuntu.com/ubuntu -o --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">libvirt=qemu:///system --ip=192.168.0.101 --gw=192.168.0.1 --part=vmbuilder.partition --templates=mytemplates --user=administrator --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">name=Administrator --pass=howtoforge --addpkg=vim-nox --addpkg=unattended-upgrades --addpkg=acpid --</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>firstboot=/var/lib/libvirt/images/vm1/boot.sh --mem=256 --hostname=vm1 --bridge=br0</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">--mirror=http://mirrors.163.com/ubuntu--------more fast</span></p>
<p>大多数选项不言自明。<span style="font-family: 'Times New Roman';">--part</span>指定了有分区详细信息的文件，相对于我们的工作目录（这就是我们在运行<span style="font-family: 'Times New Roman';">vmbuilder</span>之前为什么要进入到虚拟机目录），<span style="font-family: 'Times New Roman';">--templates</span>指定了保存模板文件的目录（再次相对于我们的工作目录），<span style="font-family: 'Times New Roman';">--firstboot</span>指定了首次启动脚本。<span style="font-family: 'Times New Roman';">--libvirt=qemu:///system</span>告诉<span style="font-family: 'Times New Roman';">KVM</span>把该虚拟机添加到可用虚拟机的列表。<span style="font-family: 'Times New Roman';">--addpkg</span>让你可以指定创建虚拟机过程中想安装的<span style="font-family: 'Times New Roman';">Ubuntu</span>程序包（上文解释了为什么不该把<span style="font-family: 'Times New Roman';">openssh-server</span>添加到该列表中，而是应该使用首次启动脚本）。<span style="font-family: 'Times New Roman';">&nbsp;--bridge</span>建立了桥接网络；由于我们已在第<span style="font-family: 'Times New Roman';">2</span>节建立了网桥<span style="font-family: 'Times New Roman';">br0</span>，我们在此指定该网桥。</p>
<p>在<span style="font-family: 'Times New Roman';">--mirror</span>这一行，你可以使用<span style="font-family: 'Times New Roman';">--mirror</span>来指定官方的<span style="font-family: 'Times New Roman';">Ubuntu</span>库，比如<a href="http://de.archive.ubuntu.com/ubuntu"><span style="font-family: 'Times New Roman';">http://de.archive.ubuntu.com/ubuntu</span></a>。如果你略去<span style="font-family: 'Times New Roman';">--mirror</span>，那么就会使用默认的<span style="font-family: 'Times New Roman';">Ubuntu</span>库（<a href="http://archive.ubuntu.com/ubuntu"><span style="font-family: 'Times New Roman';">http://archive.ubuntu.com/ubuntu</span></a>）。</p>
<p>如果你用<span style="font-family: 'Times New Roman';">--ip</span>参数选项符指定<span style="font-family: 'Times New Roman';">IP</span>地址，要确保你还使用<span style="font-family: 'Times New Roman';">--gw</span>参数选项符指定了正确的网关<span style="font-family: 'Times New Roman';">IP</span>（不然，<span style="font-family: 'Times New Roman';">vmbuilder</span>会假设它是网络中的第一个有效地址，实则不然）。网关<span style="font-family: 'Times New Roman';">IP</span>通常与你在<span style="font-family: 'Times New Roman';">/etc/network/interfaces</span>中所用的一样（参阅第<span style="font-family: 'Times New Roman';">2</span>节）。</p>
<p>创建过程可能要花几分钟。</p>
<p>之后，你能在<span style="font-family: 'Times New Roman';">/etc/libvirt/qemu/ (=&gt; /etc/libvirt/qemu/vm1.xml)</span>中找到该虚拟机的<span style="font-family: 'Times New Roman';">XML</span>配置文件：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>ls -l /etc/libvirt/qemu/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:/var/lib/libvirt/images/vm1# ls -l /etc/libvirt/qemu/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">total 8</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">drwxr-xr-x 3 root root 4096 May 21 13:00 networks</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">-rw------- 1 root root 2082 May 21 13:15 vm1.xml</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:/var/lib/libvirt/images/vm1#</em></span></p>
<p>磁盘镜像位于我们虚拟机目录的<span style="font-family: 'Times New Roman';">ubuntu-kvm/</span>子目录中：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>ls -l /var/lib/libvirt/images/vm1/ubuntu-kvm/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:/var/lib/libvirt/images/vm1# ls -l /var/lib/libvirt/images/vm1/ubuntu-kvm/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">total 604312</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">-rw-r--r-- 1 root root 324337664 May 21 13:14 tmpE4IiRv.qcow2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">-rw-r--r-- 1 root root 294715392 May 21 13:15 tmpxvSVOT.qcow2</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:/var/lib/libvirt/images/vm1#</em></span></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">4.&nbsp;</span></strong><strong>创建第二个虚拟机</strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p>如果你想创建第二个虚拟机（<span style="font-family: 'Times New Roman';">vm2</span>），这里简要概述一下命令：</p>
<p><em><span style="font-family: 'Times New Roman';">mkdir -p /var/lib/libvirt/images/vm2/mytemplates/libvirt</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">cp /etc/vmbuilder/libvirt/* /var/lib/libvirt/images/vm2/mytemplates/libvirt/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">vi /var/lib/libvirt/images/vm2/vmbuilder.partition</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">vi /var/lib/libvirt/images/vm2/boot.sh</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">cd /var/lib/libvirt/images/vm2/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">vmbuilder kvm ubuntu --suite=precise --flavour=virtual --arch=amd64 --mirror=http://de.archive.ubuntu.com/ubuntu -o --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">libvirt=qemu:///system --ip=192.168.0.102 --gw=192.168.0.1 --part=vmbuilder.partition --templates=mytemplates --user=administrator --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">name=Administrator --pass=howtoforge --addpkg=vim-nox --addpkg=unattended-upgrades --addpkg=acpid --</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>firstboot=/var/lib/libvirt/images/vm2/boot.sh --mem=256 --hostname=vm2 --bridge=br0</em></span></p>
<p>请注意：如果你把<span style="font-family: 'Times New Roman';">-d DESTDIR</span>变量传递给<span style="font-family: 'Times New Roman';">vmbuilder</span>命令，就没必要为虚拟机创建新目录（<span style="font-family: 'Times New Roman';">/var/lib/libvirt/images/vm2</span>）&mdash;&mdash;它让你可以在你已经创建了另一个虚拟机的目录中创建虚拟机。这种情况下，你没必要创建新的<span style="font-family: 'Times New Roman';">vmbuilder.partition</span>和<span style="font-family: 'Times New Roman';">boot.sh</span>文件，也没必要改动模板，而是只要使用现有文件：</p>
<p><em><span style="font-family: 'Times New Roman';">cd /var/lib/libvirt/images/vm1/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">vmbuilder kvm ubuntu --suite=precise --flavour=virtual --arch=amd64 --mirror=http://de.archive.ubuntu.com/ubuntu -o --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">libvirt=qemu:///system --ip=192.168.0.102 --gw=192.168.0.1 --part=vmbuilder.partition --templates=mytemplates --user=administrator --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">name=Administrator --pass=howtoforge --addpkg=vim-nox --addpkg=unattended-upgrades --addpkg=acpid --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">firstboot=/var/lib/libvirt/images/vm1/boot.sh --mem=256 --hostname=vm2 --bridge=br0 -d vm2-kvm</span></em></p>
<p align="center"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">5.&nbsp;</span></strong><strong>管理虚拟机</strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p>可以通过<span style="font-family: 'Times New Roman';">virsh</span>（虚拟外壳）来管理虚拟机。想连接到虚拟外壳，运行：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>virsh --connect qemu:///system</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>虚拟外壳的样子如下：</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# virsh --connect qemu:///system</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">Welcome to virsh, the virtualization interactive terminal.</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">Type:&nbsp;&nbsp;'help' for help with commands</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'quit' to quit</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>virsh #</em></span></p>
<p>现在，你可以在虚拟外壳上输入命令来管理虚拟机。运行</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>Help</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>即可获得可用命令列表：</p>
<p><em><span style="font-family: 'Times New Roman';">virsh # help</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">Grouped commands:</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>域管理命令（帮助关键字<span style="font-family: 'Times New Roman';">'domain'</span></em><em>）：<span style="font-family: 'Times New Roman';">:</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">attach-device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件附加设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;attach-disk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>附加磁盘设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;attach-interface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>附加网络接口</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;autostart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>自动启动域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;blkdeviotune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>设定或查询块设备输入<span style="font-family: 'Times New Roman';">/</span></em><em>输出调整参数</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;blkiotune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取或设定块输入<span style="font-family: 'Times New Roman';">/</span></em><em>输出参数</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;blockpull&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从支持镜像填充磁盘</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;blockjob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>管理活动的块操作</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;blockresize&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为域的块设备调整大小</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;console&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>连接到客户机控制台</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;cpu-baseline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>计算基准处理器</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;cpu-compare&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>比较主机处理器与<span style="font-family: 'Times New Roman';">XML</span></em><em>文件描述的处理器</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件创建域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义（但不启动）域</em></p>
<p><em><span style="font-family: 'Times New Roman';">destroy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>销毁（停止）域</em></p>
<p><em><span style="font-family: 'Times New Roman';">detach-device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件分离设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;detach-disk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>分离磁盘设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;detach-interface&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>分享网络接口</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域名或<span style="font-family: 'Times New Roman';">UUID</span></em><em>转换成域编号</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domif-setlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>设定虚拟接口的链路状态</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domjobabort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>放弃活动的域任务</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domjobinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域任务信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">domname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域编号或<span style="font-family: 'Times New Roman';">UUID</span></em><em>转换成域名</em></p>
<p><em><span style="font-family: 'Times New Roman';">domuuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域名或编号转换成域<span style="font-family: 'Times New Roman';">UUID</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">domxml-from-native&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把原生配置转换成域<span style="font-family: 'Times New Roman';">XML</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domxml-to-native&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域<span style="font-family: 'Times New Roman';">XML</span></em><em>转换成原生配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;dump&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域的核心转储到文件中，以便分析</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的域信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为域编辑<span style="font-family: 'Times New Roman';">XML</span></em><em>配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">inject-nmi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把<span style="font-family: 'Times New Roman';">NMI</span></em><em>注入到客户机</em></p>
<p><em><span style="font-family: 'Times New Roman';">send-key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>将键码发送到客户机</em></p>
<p><em><span style="font-family: 'Times New Roman';">managedsave&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域状态的托管保存</em></p>
<p><em><span style="font-family: 'Times New Roman';">managedsave-remove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>清除域的托管保存</em></p>
<p><em><span style="font-family: 'Times New Roman';">maxvcpus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>连接虚拟处理器最大值</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;memtune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取或设定内存参数</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;migrate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把域迁移到另一个主机</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;migrate-setmaxdowntime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>设定可以容忍的最长停机时间</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;migrate-setspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>设定最大迁移带宽</em></p>
<p><em><span style="font-family: 'Times New Roman';">migrate-getspeed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取最大迁移带宽</em></p>
<p><em><span style="font-family: 'Times New Roman';">reboot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>重启域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;reset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>重置域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;restore&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从文件中的保存状态恢复域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;resume&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>恢复运行域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;save&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>将域状态保存到文件</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;save-image-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为域的保存状态文件重新定义<span style="font-family: 'Times New Roman';">XML</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">save-image-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的保存状态域信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">save-image-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为域的保存状态文件编辑<span style="font-family: 'Times New Roman';">XML</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">schedinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>显示<span style="font-family: 'Times New Roman';">/</span></em><em>设定调度器参数</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;screenshot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取当前域控制台的屏幕截图，并保存到文件中</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;setmaxmem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>改变最大内存限额</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;setmem&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>改变内存分配</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;setvcpus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>改变虚拟处理器的数量</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;shutdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从容地关闭域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>启动（之前定义的）非活动域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;suspend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>暂停域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;ttyconsole&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tty</span></em><em>控制台</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;update-device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件更新设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vcpucount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域虚拟处理器数量</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vcpuinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>详细的域虚拟处理器信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vcpupin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>控制或查询域虚拟处理器亲近性</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>显示版本</em></p>
<p><em><span style="font-family: 'Times New Roman';">vncdisplay&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vnc</span></em><em>显示</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>域监控命令（帮助关键字<span style="font-family: 'Times New Roman';">'monitor'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">domblkinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域块设备大小信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">domblklist&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出所有域块</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domblkstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取一个域的设备块统计信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domcontrol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域控制台界面状态</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domif-getlink&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取虚拟接口的链路状态</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domifstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取域的网络接口统计信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;dominfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;dommemstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取域的内存统计信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;domstate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>域状态</em></p>
<p><em><span style="font-family: 'Times New Roman';">list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出域</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>主机和虚拟机管理程序命令（帮助关键字<span style="font-family: 'Times New Roman';">'host'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;capabilities&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>功能</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;connect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>（重新）连接至虚拟机管理程序</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;freecell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NUMA</span></em><em>闲置内存</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;hostname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印虚拟机管理程序主机名</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodecpustats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印节点的处理器统计信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodeinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>节点信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodememstats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印节点的内存统计信息<span style="font-family: 'Times New Roman';">.</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodesuspend&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>将主机节点暂停一段特定的时间</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;qemu-attach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QEMU</span></em><em>附加</em></p>
<p><em><span style="font-family: 'Times New Roman';">qemu-monitor-command&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;QEMU</span></em><em>监测器命令</em></p>
<p><em><span style="font-family: 'Times New Roman';">sysinfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印虚拟机管理程序的系统信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">uri&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印虚拟机管理程序<span style="font-family: 'Times New Roman';">canonical URI</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>接口命令（帮助关键字<span style="font-family: 'Times New Roman';">'interface'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>拍摄当前接口设置的快照，以后可以提交（<span style="font-family: 'Times New Roman';">iface-commit</span></em><em>）或恢复<span style="font-family: 'Times New Roman';">(iface-rollback)</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-bridge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>建立网桥设备，并与现有网络设备相连</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-commit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>实行自<span style="font-family: 'Times New Roman';">iface-begin</span></em><em>和闲置恢复点以来所作的变化</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义（但不启动）物理主机接口</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-destroy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>销毁物理主机接口（禁用它<span style="font-family: 'Times New Roman';">/ "if-down"</span></em><em>）</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的接口信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为物理主机接口编辑<span style="font-family: 'Times New Roman';">XML</span></em><em>配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出物理主机接口</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-mac&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把接口名称转换成接口<span style="font-family: 'Times New Roman';">MAC</span></em><em>地址</em></p>
<p><em><span style="font-family: 'Times New Roman';">iface-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把接口<span style="font-family: 'Times New Roman';">MAC</span></em><em>地址转换成接口名称</em></p>
<p><em><span style="font-family: 'Times New Roman';">iface-rollback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>恢复到通过<span style="font-family: 'Times New Roman';">iface-begin</span></em><em>创建的之前保存的配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>启动物理主机接口（启用它<span style="font-family: 'Times New Roman';">/ "if-up"</span></em><em>）</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;iface-unbridge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>分离从属设备后，取消定义网桥设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">iface-undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义物理主机接口（将它从配置中移除）</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>网络过滤器命令（帮助关键字<span style="font-family: 'Times New Roman';">'filter'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nwfilter-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义或更新网络过滤器</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nwfilter-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的网络过滤器信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nwfilter-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为网络过滤器编辑<span style="font-family: 'Times New Roman';">XML</span></em><em>配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nwfilter-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出网络过滤器</em></p>
<p><em><span style="font-family: 'Times New Roman';">nwfilter-undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义网络过滤器</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>网络命令（帮助关键字<span style="font-family: 'Times New Roman';">'network'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-autostart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>自动启动网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件创建网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义（但不启动）网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-destroy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>销毁（停止）网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的网络信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为网络编辑<span style="font-family: 'Times New Roman';">XML</span></em><em>配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>网络信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把网络<span style="font-family: 'Times New Roman';">UUID</span></em><em>转换成网络名称</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>启动（之前定义）的非活动网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;net-undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义非活动网络</em></p>
<p><em><span style="font-family: 'Times New Roman';">net-uuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把网络名称转换成网络<span style="font-family: 'Times New Roman';">UUID</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>节点设备命令（帮助关键字<span style="font-family: 'Times New Roman';">'nodedev'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodedev-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>在节点上创建由<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义的设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodedev-destroy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>销毁（停止）节点上的设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodedev-dettach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>将节点设备与设备驱动程序分离</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;nodedev-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的节点设备详细信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">nodedev-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列举该主机上的设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">nodedev-reattach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>重新将节点设备连接至设备驱动程序</em></p>
<p><em><span style="font-family: 'Times New Roman';">nodedev-reset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>重置节点设备</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>密钥（帮助关键字<span style="font-family: 'Times New Roman';">'secret'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;secret-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义或改动密钥</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;secret-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的密钥属性</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;secret-get-value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>输出密钥值</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;secret-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出密钥</em></p>
<p><em><span style="font-family: 'Times New Roman';">secret-set-value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>设定密钥值</em></p>
<p><em><span style="font-family: 'Times New Roman';">secret-undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义密钥</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>快照命令（帮助关键字<span style="font-family: 'Times New Roman';">'snapshot'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>创建快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-create-as&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从一组变更创建快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-current&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取或设定当前快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>删除域的快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">snapshot-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>转储域快照的<span style="font-family: 'Times New Roman';">XML</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">snapshot-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>编辑快照的<span style="font-family: 'Times New Roman';">XML</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出域的快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;snapshot-parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>获取快照母版的名称</em></p>
<p><em><span style="font-family: 'Times New Roman';">snapshot-revert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>使域回复到快照</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>存储池命令（帮助关键字<span style="font-family: 'Times New Roman';">'pool'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;find-storage-pool-sources-as&nbsp;&nbsp;&nbsp;</span></em><em>查找潜在的存储池来源</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;find-storage-pool-sources&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>发现潜在的存储池来源</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-autostart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>自动启动存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>建立存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-create-as&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从一组变量创建存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件创建存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-define-as&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从一组变量定义存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-define&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件定义（但不启动）存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">pool-delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>删除存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">pool-destroy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>销毁（停止）存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的存储池信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-edit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>为存储池编辑<span style="font-family: 'Times New Roman';">XML</span></em><em>配置</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>存储池信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把存储池<span style="font-family: 'Times New Roman';">UUID</span></em><em>转换成存储池名称</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-refresh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>刷新存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-start&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>启动（之前定义）的非活动存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pool-undefine&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>取消定义非活动存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">pool-uuid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>把存储池名称转换成存储池<span style="font-family: 'Times New Roman';">UUID</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em>存储卷命令（帮助关键字<span style="font-family: 'Times New Roman';">'volume'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-clone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>克隆存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-create-as&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从一组变量创建存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-create&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>从<span style="font-family: 'Times New Roman';">XML</span></em><em>文件创建存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-create-from&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>创建存储卷，使用另一个存储卷作为输入</em></p>
<p><em><span style="font-family: 'Times New Roman';">vol-delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>删除存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">vol-download&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>下载存储卷到文件</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-dumpxml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML</span></em><em>中的存储卷信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-info&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>存储卷信息</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>返回某个存储卷名称或路径的存储卷密钥</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-list&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>列出存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>返回某个存储卷密钥或路径的存储卷名称</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>返回某个存储卷名称或密钥的存储卷路径</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-pool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>返回某个存储卷密钥或路径的存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;vol-upload&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>将文件上传到存储池</em></p>
<p><em><span style="font-family: 'Times New Roman';">vol-wipe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>清除存储卷</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em><em>虚拟外壳命令（帮助关键字<span style="font-family: 'Times New Roman';">virsh'</span></em><em>）：</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;cd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>变更当前目录</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>回显变量</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>退出这个交互式终端</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印帮助</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;pwd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>打印当前目录</em></p>
<p><em><span style="font-family: 'Times New Roman';">quit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></em><em>退出这个交互式终端</em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">virsh #</span></em></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>list</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>显示所有运行中虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>list --all</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>显示所有虚拟机，包括运行中虚拟机和非活动虚拟机：</p>
<p><em><span style="font-family: 'Times New Roman';">virsh # list --all</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;Id Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">----------------------------------</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;- vm1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shut off</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;- vm2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shut off</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>virsh #</em></span></p>
<p>在你第一次启动新虚拟机之前，必须从<span style="font-family: 'Times New Roman';">XML</span>文件来定义（该文件位于<span style="font-family: 'Times New Roman';">/etc/libvirt/qemu/</span>目录）：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>define /etc/libvirt/qemu/vm1.xml</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>请注意：只要你改动<span style="font-family: 'Times New Roman';">/etc/libvirt/qemu/</span>中的虚拟机<span style="font-family: 'Times New Roman';">XML</span>文件，就必须再次运行<span style="font-family: 'Times New Roman';">define</span>命令！</p>
<p>现在你可以启动虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>start vm1</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>片刻过后，你应该可以使用<span style="font-family: 'Times New Roman';">PuTTY</span>等<span style="font-family: 'Times New Roman';">SSH</span>客户程序，连接到虚拟机；以默认的用户名和密码登录。第一次登录后，你会看到要求更改密码的提示。</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';">list</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>现在应该显示虚拟机是运行中：</p>
<p><em><span style="font-family: 'Times New Roman';">virsh # list</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;Id Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">----------------------------------</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;1 vm1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;running</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>virsh #</em></span></p>
<p>想停止虚拟机，运行</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>shutdown vm1</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>想立即停止虚拟机（也就是拔掉电源），运行</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>destroy vm1</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>暂停虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>suspend vm1</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>恢复运行虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>resume vm1</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>上面这些是最重要的命令。</p>
<p>输入</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>Quit</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>即可退出虚拟外壳。</p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">6.&nbsp;</span></strong><strong>创建基于<span style="font-family: 'Times New Roman';">LVM</span></strong><strong>的虚拟机</strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p>基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机与基于镜像的虚拟机相比有一些优点。它们的硬盘输入<span style="font-family: 'Times New Roman';">/</span>输出不大频繁，而且更容易备份（使用<span style="font-family: 'Times New Roman';">LVM</span>快照）。</p>
<p>想使用基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机，你就需要一个卷组，它要有未分配给任何逻辑卷的一些闲置空间。在本例中，我使用了大小约为<span style="font-family: 'Times New Roman';">465GB</span>的卷组<span style="font-family: 'Times New Roman';">/dev/vg0&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vgdisplay</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# vgdisplay</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;--- Volume group ---</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vg0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;System ID</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Format&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lvm2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Metadata Areas&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Metadata Sequence No&nbsp;&nbsp;3</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read/write</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resizable</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;MAX&nbsp;LV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Cur&nbsp;LV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Open&nbsp;LV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Max PV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Cur PV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Act PV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;465.29 GiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;PE Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.00 MiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Total PE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;119115</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Alloc&nbsp;PE&nbsp;/ Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;24079 / 94.06 GiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Free&nbsp;&nbsp;PE / Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;95036 / 371.23 GiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG UUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRenhH-0MvN-wXCL-nl4i-IfsQ-J6fc-2raYLD</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~#</span></em></p>
<p>该卷组包含大小约为<span style="font-family: 'Times New Roman';">100GB</span>的逻辑卷<span style="font-family: 'Times New Roman';">/dev/vg0/root</span>和大小约为<span style="font-family: 'Times New Roman';">1GB</span>的逻辑卷<span style="font-family: 'Times New Roman';">/dev/vg0/swap_1</span>，其余空间未分配，可供虚拟机使用：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>lvdisplay</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:~# lvdisplay</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;--- Logical volume ---</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/dev/vg0/root</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vg0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;UUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dwnORf-yG3U-x1ZC-Bet1-TOoc-q1Dd-KZnbtw</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Write Access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read/write</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;available</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;# open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93.13 GiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Current LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;23841</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Segments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Allocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Read ahead sectors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;- currently set to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Block device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;252:0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;--- Logical volume ---</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/dev/vg0/swap_1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;VG Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vg0</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;UUID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZdPKO6-sZrr-tIRb-PPcl-aWBj-QAUU-fnYUuP</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Write Access&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read/write</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;available</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;# open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;LV&nbsp;Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;952.00 MiB</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Current LE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;238</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Segments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Allocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inherit</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Read ahead sectors&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;auto</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;- currently set to&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;256</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;Block device&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;252:1</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>root@server1:~#</em></span></p>
<p>现在我将创建虚拟机<span style="font-family: 'Times New Roman';">vm5</span>，作为基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机。我们可以再度使用<span style="font-family: 'Times New Roman';">vmbuilder</span>命令。<span style="font-family: 'Times New Roman';">vmbuilder</span>知道<span style="font-family: 'Times New Roman';">--raw</span>选项，该选项允许将虚拟机写入到块设备（如<span style="font-family: 'Times New Roman';">/dev/vg0/vm5</span>）&mdash;&mdash;我试用了该选项；不过它没有返回错误，我也启动不了虚拟机（<span style="font-family: 'Times New Roman';">start vm5</span>也没有显示任何错误，但是我根本无法访问该虚拟机。）因此，我将先创建<span style="font-family: 'Times New Roman';">vm5</span>，作为基于镜像的虚拟机，然后转换成基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机。</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><em><span style="font-family: 'Times New Roman';">mkdir -p /var/lib/libvirt/images/vm5/mytemplates/libvirt</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>cp /etc/vmbuilder/libvirt/* /var/lib/libvirt/images/vm5/mytemplates/libvirt/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>确保你在仅仅一个镜像文件中创建所有分区，所以在<span style="font-family: 'Times New Roman';">vmbuilder.partition</span>文件中不要使用<span style="font-family: 'Times New Roman';">---</span>：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vi /var/lib/libvirt/images/vm5/vmbuilder.partition</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">root 8000</span></p>
<p><span style="font-family: 'Times New Roman';">swap 2000</span></p>
<p><span style="font-family: 'Times New Roman';">/var 10000</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>vi /var/lib/libvirt/images/vm5/boot.sh</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>虚拟机第一次启动时，该脚本将运行。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>它以根用户来运行。</p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>到期终止用户帐户</p>
<p><span style="font-family: 'Times New Roman';">passwd -e administrator</span></p>
<p><span style="font-family: 'Times New Roman';">#&nbsp;</span>安装<span style="font-family: 'Times New Roman';">openssh-server</span></p>
<p><span style="font-family: 'Times New Roman';">apt-get update</span></p>
<p><span style="font-family: 'Times New Roman';">apt-get install -qqy --force-yes openssh-server</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="736">
<p><em><span style="font-family: 'Times New Roman';">cd /var/lib/libvirt/images/vm5/</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">vmbuilder kvm ubuntu --suite=precise --flavour=virtual --arch=amd64 --mirror=http://de.archive.ubuntu.com/ubuntu -o --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">libvirt=qemu:///system --ip=192.168.0.105 --gw=192.168.0.1 --part=vmbuilder.partition --templates=mytemplates --user=administrator --</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">name=Administrator --pass=howtoforge --addpkg=vim-nox --addpkg=unattended-upgrades --addpkg=acpid --</span></em></p>
<p><span style="font-family: 'Times New Roman';"><em>firstboot=/var/lib/libvirt/images/vm5/boot.sh --mem=256 --hostname=vm5 --bridge=br0</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>你可以从<span style="font-family: 'Times New Roman';">vmbuilder.partition</span>文件看到，虚拟机将使用最多<span style="font-family: 'Times New Roman';">20GB</span>的空间，于是我们现在创建一个大小为<span style="font-family: 'Times New Roman';">20GB</span>的逻辑卷，名为<span style="font-family: 'Times New Roman';">/dev/vg0/vm5</span>：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>lvcreate -L20G&nbsp;-n vm5 vg0</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>别在新的逻辑卷中创建文件系统！</p>
<p>我们将使用<span style="font-family: 'Times New Roman';">qemu-img</span>命令，把镜像转换成基于<span style="font-family: 'Times New Roman';">LVM</span>的虚拟机。</p>
<p>现在我们进入到虚拟机的<span style="font-family: 'Times New Roman';">ubuntu-kvm/</span>目录<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>cd /var/lib/libvirt/images/vm5/ubuntu-kvm/</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>即可发现我们的镜像是如何命名的：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>ls -l</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:/var/lib/libvirt/images/vm5/ubuntu-kvm# ls -l</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">total 592140</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">-rw-r--r-- 1 root root 606470144 May 21 14:06 tmpesHsUI.qcow2</span></em></p>
<p><em><span style="font-family: 'Times New Roman';">root@server1:/var/lib/libvirt/images/vm5/ubuntu-kvm#</span></em></p>
<p>由于我们已知道了镜像的名称（<span style="font-family: 'Times New Roman';">tmpN27tbO.qcow2</span>），可按如下方式来转换它：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>qemu-img convert tmpesHsUI.qcow2 -O raw /dev/vg0/vm5</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>之后，你可以删除磁盘镜像：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>rm -f tmpesHsUI.qcow2</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">&nbsp;</span></p>
<p>现在，我们必须改动虚拟机的配置<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>virsh edit vm5</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>并改变下列部分<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p><span style="font-family: 'Times New Roman';">[...]</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<source file="/var/lib/libvirt/images/vm5/ubuntu-kvm/tmpesHsUI.qcow2" /></span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">[...]</span></p>
<p>以便看起来像下面这样：</p>
<p><span style="font-family: 'Times New Roman';">[...]</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<source file="/dev/vg0/vm5" /></span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
<p>&nbsp;</p>
<p><span style="font-family: 'Times New Roman';">&nbsp;&nbsp;&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">[...]</span></p>
<p>现在，你可以使用<span style="font-family: 'Times New Roman';">virsh</span>来管理虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>virsh --connect qemu:///system</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>由于我们已改动了虚拟机的<span style="font-family: 'Times New Roman';">XML</span>文件，必须先运行<span style="font-family: 'Times New Roman';">define</span>命令<span style="font-family: 'Times New Roman';">&hellip;&hellip;</span></p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>define /etc/libvirt/qemu/vm5.xml</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>然后启动虚拟机：</p>
<p>&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="703">
<p><span style="font-family: 'Times New Roman';"><em>start vm5</em></span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p align="center"><strong><span style="font-family: 'Times New Roman';">&nbsp;</span></strong></p>
<p align="left"><strong><span style="font-family: 'Times New Roman';">7.&nbsp;</span></strong><strong>相关链接</strong></p>
<p><strong>&bull;</strong><span style="font-family: 'Times New Roman';">KVM</span>（<span style="font-family: 'Times New Roman';">Ubuntu</span>社区说明文档）：<span style="font-family: 'Times New Roman';">https://help.ubuntu.com/community/KVM</span></p>
<p><strong>&bull;</strong><span style="font-family: 'Times New Roman';">vmbuilder</span>：<span style="font-family: 'Times New Roman';">https://help.ubuntu.com/community/JeOSVMBuilder</span></p>
<p><strong>&bull;</strong><span style="font-family: 'Times New Roman';">JeOS</span>和<span style="font-family: 'Times New Roman';">vmbuilder</span>：<span style="font-family: 'Times New Roman';">http://doc.ubuntu.com/ubuntu/serverguide/C/jeos-and-vmbuilder.html</span></p>
<p><strong>&bull;</strong><span style="font-family: 'Times New Roman';">Ubuntu</span>：<span style="font-family: 'Times New Roman';">http://www.ubuntu.com/&nbsp;</span></p>
<p><span style="font-family: 'Times New Roman';">&nbsp;<a href="http://virtual.51cto.com/art/201206/341911_3.htm">http://virtual.51cto.com/art/201206/341911_3.htm</a></span></p>
<p><span style="font-family: 'Times New Roman';"><a href="http://www.howtoforge.com/virtualization-with-kvm-on-ubuntu-12.04-lts">&nbsp;</a></span></p>]]></description></item><item><title>TCP三路握手</title><link>http://www.cnblogs.com/isohybrid/archive/2013/03/01/three-way_handshake.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Thu, 28 Feb 2013 19:58:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/03/01/three-way_handshake.html</guid><description><![CDATA[<p><img src="http://images.cnitblog.com/blog/464387/201303/01034140-e0e4b84d010c499d9629d98fe668156e.jpg" alt="" /></p>
<p>&nbsp;</p>
<p>建立一个TCP连接时回发生下述情形</p>
<p>（1）服务器必须准备好接受外来的连接。这通常通过调用socket,bind,和listen这三个函数来完成，我们称之为被动打开（passive open）</p>
<p>（2）客户通过调用connect发起主动打开(active open)。这导致客户TCP发送一个SYN（同步）分节，他告诉服务器客户将在（待建立的）连接中发送的数据的初始序列号。通常SYN分节不携带数据，其所在IP数据包只含有一个IP首部，一个TCP首部以及可能有的TCP选项</p>
<p>（3）服务器必须确认（ACK）客户的SYN，同时自己也得发送一个SYN分节，它含有服务器将在同一连接中发送的数据的初始序列号。服务器在单个分节发送SYN和对客户SYN的确认（ACK）</p>
<p>（4）客户必须确认服务器的SYN</p>
<p>&nbsp;</p>
<p>这种交换至少需要三个分组，因此称之为TCP的三路握手（three-way handshake）</p>
<p>&nbsp;</p>
<p>图中给出的客户的初始序列号为J,服务器的初始序列号为K。ACK中的确认号是发送这个ACK的一端所期待的下一个序列号。因为SYN占据一个字节的序列号空间。所以每个SYN的ACK中的确认号就是该SYN的初始序列号加1.类似的，每一个FIN（表示结束）的ACK中的确认号为该FIN的序列号加1.</p>]]></description></item><item><title>linux iptables</title><link>http://www.cnblogs.com/isohybrid/archive/2013/03/01/iptables.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Thu, 28 Feb 2013 18:55:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/03/01/iptables.html</guid><description><![CDATA[<p></p>
<table id="pid14985526" summary="pid14985526" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td class="plc">
<div class="pct">
<div class="pcb">
<div class="t_fsz">
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td id="postmessage_14985526" class="t_f">iptables 指令<br />语法：<br />iptables [-t table] command [match] [-j target/jump]<br />-t&nbsp;<span style="color: red;">参数</span>用来指定规则表，内建的规则表有三个，分别是：nat、mangle 和 filter，当未指定规则表时，则一律视为是 filter。<br />个规则表的功能如下：<br /><br />nat 此规则表拥有 Prerouting 和 postrouting 两个规则链，主要功能为进行一对一、一对多、多对多等网址转译工作（SNAT<br />DNAT），由于转译工作的特性，需进行目的地网址转译的封包，就不需要进行来源网址转译，反之亦然，因此为了提升改写封包的<br />率，在防火墙运作时，每个封包只会经过这个规则表一次。如果我们把封包过滤的规则定义在这个数据表里，将会造成无法对同一<br />包进行多次比对，因此这个规则表除了作网址转译外，请不要做其它用途。<br /><br />mangle 此规则表拥有 Prerouting、FORWARD 和 postrouting 三个规则链。<br />除了进行网址转译工作会改写封包外，在某些特殊应用可能也必须去改写封包（TTL、TOS）或者是设定 MARK（将封包作记号，以<br />进行后续的过滤），这时就必须将这些工作定义在 mangle 规则表中，由于使用率不高，我们不打算在这里讨论 mangle 的用法。<br /><br />filter 这个规则表是预设规则表，拥有 INPUT、FORWARD 和 OUTPUT 三个规则链，这个规则表顾名思义是用来进行封包过滤的<br />理动作（例如：DROP、 LOG、 ACCEPT 或 REJECT），我们会将基本规则都建立在此规则表中。<br /><br />常用<span style="color: green;">命令</span>列表：<br /><span style="color: green;">命令</span>&nbsp;-A, --append<br />范例 iptables -A INPUT ...<br />说明 新增规则到某个规则链中，该规则将会成为规则链中的最后一条规则。<br /><span style="color: green;">命令</span>&nbsp;-D, --delete<br />范例 iptables -D INPUT --dport 80 -j DROP<br />iptables -D INPUT 1<br />说明 从某个规则链中删除一条规则，可以输入完整规则，或直接指定规则编号加以删除。<br /><span style="color: green;">命令</span>&nbsp;-R, --replace<br />范例 iptables -R INPUT 1 -s 192.168.0.1 -j DROP<br />说明 取代现行规则，规则被取代后并不会改变顺序。<br /><span style="color: green;">命令</span>&nbsp;-I, --insert<br />范例 iptables -I INPUT 1 --dport 80 -j ACCEPT<br />说明 插入一条规则，原本该位置上的规则将会往后移动一个顺位。<br /><span style="color: green;">命令</span>&nbsp;-L, --list<br />范例 iptables -L INPUT<br />说明 列出某规则链中的所有规则。<br /><span style="color: green;">命令</span>&nbsp;-F, --flush<br />范例 iptables -F INPUT<br />说明 删除某规则链中的所有规则。<br /><span style="color: green;">命令</span>&nbsp;-Z, --zero<br />范例 iptables -Z INPUT<br />说明 将封包计数器归零。封包计数器是用来计算同一封包出现次数，是过滤阻断式攻击不可或缺的工具。<br /><span style="color: green;">命令</span>&nbsp;-N, --new-chain<br />范例 iptables -N allowed<br />说明 定义新的规则链。<br /><span style="color: green;">命令</span>&nbsp;-X, --delete-chain<br />范例 iptables -X allowed<br />说明 删除某个规则链。<br /><span style="color: green;">命令</span>&nbsp;-P, --policy<br />范例 iptables -P INPUT DROP<br />说明 定义过滤政策。 也就是未符合过滤条件之封包，预设的处理方式。<br /><span style="color: green;">命令</span>&nbsp;-E, --rename-chain<br />范例 iptables -E allowed disallowed<br />说明 修改某自订规则链的名称。<br />常用封包比对<span style="color: red;">参数</span>：<br /><span style="color: red;">参数</span>&nbsp;-p, --protocol<br />范例 iptables -A INPUT -p tcp<br />说明 比对通讯协议类型是否相符，可以使用 ! 运算子进行反向比对，例如：-p ! tcp ，意思是指除 tcp 以外的其它类型，包含<br />udp、icmp ...等。如果要比对所有类型，则可以使用 all 关键词，例如：-p all。<br /><span style="color: red;">参数</span>&nbsp;-s, --src, --source<br />范例 iptables -A INPUT -s 192.168.1.1<br />说明 用来比对封包的来源 IP，可以比对单机或网络，比对网络时请用数字来表示屏蔽，例如：-s 192.168.0.0/24，比对 IP 时<br />可以使用 ! 运算子进行反向比对，例如：-s ! 192.168.0.0/24。<br /><span style="color: red;">参数</span>&nbsp;-d, --dst, --destination<br />范例 iptables -A INPUT -d 192.168.1.1<br />说明 用来比对封包的目的地 IP，设定方式同上。<br /><span style="color: red;">参数</span>&nbsp;-i, --in-interface<br />范例 iptables -A INPUT -i eth0<br />说明 用来比对封包是从哪片网卡进入，可以使用通配字符 + 来做大范围比对，例如：-i eth+ 表示所有的 ethernet 网卡，也<br />以使用 ! 运算子进行反向比对，例如：-i ! eth0。<br /><span style="color: red;">参数</span>&nbsp;-o, --out-interface<br />范例 iptables -A FORWARD -o eth0<br />说明 用来比对封包要从哪片网卡送出，设定方式同上。<br /><span style="color: red;">参数</span>&nbsp;--sport, --source-port<br />范例 iptables -A INPUT -p tcp --sport 22<br />说明 用来比对封包的来源埠号，可以比对单一埠，或是一个范围，例如：--sport 22:80，表示从 22 到 80 埠之间都算是符合<br />件，如果要比对不连续的多个埠，则必须使用 --multiport&nbsp;<span style="color: red;">参数</span>，详见后文。比对埠号时，可以使用 ! 运算子进行反向比对。<br /><span style="color: red;">参数</span>&nbsp;--dport, --destination-port<br />范例 iptables -A INPUT -p tcp --dport 22<br />说明 用来比对封包的目的地埠号，设定方式同上。<br /><span style="color: red;">参数</span>&nbsp;--tcp-flags<br />范例 iptables -p tcp --tcp-flags SYN,FIN,ACK SYN<br />说明 比对 TCP 封包的状态旗号，<span style="color: red;">参数</span>分为两个部分，第一个部分列举出想比对的旗号，第二部分则列举前述旗号中哪些有被设<br />，未被列举的旗号必须是空的。TCP 状态旗号包括：SYN（同步）、ACK（应答）、FIN（结束）、RST（重设）、URG（紧急）<br />PSH（强迫推送） 等均可使用于<span style="color: red;">参数</span>中，除此之外还可以使用关键词 ALL 和 NONE 进行比对。比对旗号时，可以使用 ! 运算子<br />行反向比对。<br /><span style="color: red;">参数</span>&nbsp;--syn<br />范例 iptables -p tcp --syn<br />说明 用来比对是否为要求联机之 TCP 封包，与 iptables -p tcp --tcp-flags SYN,FIN,ACK SYN 的作用完全相同，如果使用 !<br />运算子，可用来比对非要求联机封包。<br /><span style="color: red;">参数</span>&nbsp;-m multiport --source-port<br />范例 iptables -A INPUT -p tcp -m multiport --source-port 22,53,80,110<br />说明 用来比对不连续的多个来源埠号，一次最多可以比对 15 个埠，可以使用 ! 运算子进行反向比对。<br /><span style="color: red;">参数</span>&nbsp;-m multiport --destination-port<br />范例 iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110<br />说明 用来比对不连续的多个目的地埠号，设定方式同上。<br /><span style="color: red;">参数</span>&nbsp;-m multiport --port<br />范例 iptables -A INPUT -p tcp -m multiport --port 22,53,80,110<br />说明 这个<span style="color: red;">参数</span>比较特殊，用来比对来源埠号和目的埠号相同的封包，设定方式同上。注意：在本范例中，如果来源端口号为 80&nbsp;<br />目的地埠号为 110，这种封包并不算符合条件。<br /><span style="color: red;">参数</span>&nbsp;--icmp-type<br />范例 iptables -A INPUT -p icmp --icmp-type 8<br />说明 用来比对 ICMP 的类型编号，可以使用代码或数字编号来进行比对。请打 iptables -p icmp --help 来查看有哪些代码可<br />用。<br /><span style="color: red;">参数</span>&nbsp;-m limit --limit<br />范例 iptables -A INPUT -m limit --limit 3/hour<br />说明 用来比对某段时间内封包的平均流量，上面的例子是用来比对：每小时平均流量是否超过一次 3 个封包。 除了每小时平均<br />次外，也可以每秒钟、每分钟或每天平均一次，默认值为每小时平均一次，<span style="color: red;">参数</span>如后： /second、 /minute、/day。 除了进行封<br />数量的比对外，设定这个<span style="color: red;">参数</span>也会在条件达成时，暂停封包的比对动作，以避免因骇客使用洪水攻击法，导致服务被阻断。<br /><span style="color: red;">参数</span>&nbsp;--limit-burst<br />范例 iptables -A INPUT -m limit --limit-burst 5<br />说明 用来比对瞬间大量封包的数量，上面的例子是用来比对一次同时涌入的封包是否超过 5 个（这是默认值），超过此上限的封<br />将被直接丢弃。使用效果同上。<br /><span style="color: red;">参数</span>&nbsp;-m mac --mac-source<br />范例 iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01<br />说明 用来比对封包来源网络接口的硬件地址，这个<span style="color: red;">参数</span>不能用在 OUTPUT 和 Postrouting 规则炼上，这是因为封包要送出到网<br />后，才能由网卡驱动程序透过 ARP 通讯协议查出目的地的 MAC 地址，所以 iptables 在进行封包比对时，并不知道封包会送到<br />个网络接口去。<br /><span style="color: red;">参数</span>&nbsp;--mark<br />范例 iptables -t mangle -A INPUT -m mark --mark 1<br />说明 用来比对封包是否被表示某个号码，当封包被比对成功时，我们可以透过 MARK 处理动作，将该封包标示一个号码，号码最<br />不可以超过 4294967296。<br /><span style="color: red;">参数</span>&nbsp;-m owner --uid-owner<br />范例 iptables -A OUTPUT -m owner --uid-owner 500<br />说明 用来比对来自本机的封包，是否为某特定使用者所产生的，这样可以避免服务器使用 root 或其它身分将敏感数据传送出<br />，可以降低系统被骇的损失。可惜这个功能无法比对出来自其它主机的封包。<br /><span style="color: red;">参数</span>&nbsp;-m owner --gid-owner<br />范例 iptables -A OUTPUT -m owner --gid-owner 0<br />说明 用来比对来自本机的封包，是否为某特定使用者群组所产生的，使用时机同上。<br /><span style="color: red;">参数</span>&nbsp;-m owner --pid-owner<br />范例 iptables -A OUTPUT -m owner --pid-owner 78<br />说明 用来比对来自本机的封包，是否为某特定行程所产生的，使用时机同上。<br /><span style="color: red;">参数</span>&nbsp;-m owner --sid-owner<br />范例 iptables -A OUTPUT -m owner --sid-owner 100<br />说明 用来比对来自本机的封包，是否为某特定联机（Session ID）的响应封包，使用时机同上。<br /><span style="color: red;">参数</span>&nbsp;-m state --state<br />范例 iptables -A INPUT -m state --state RELATED,ESTABLISHED<br />说明 用来比对联机状态，联机状态共有四种：INVALID、ESTABLISHED、NEW 和 RELATED。<br /><br />INVALID 表示该封包的联机编号（Session ID）无法辨识或编号不正确。<br />ESTABLISHED 表示该封包属于某个已经建立的联机。<br />NEW 表示该封包想要起始一个联机（重设联机或将联机重导向）。<br />RELATED 表示该封包是属于某个已经建立的联机，所建立的新联机。例如：FTP-DATA 联机必定是源自某个 FTP 联机。<br /><br />常用的处理动作：<br />-j&nbsp;<span style="color: red;">参数</span>用来指定要进行的处理动作，常用的处理动作包括：ACCEPT、REJECT、DROP、REDIRECT、MASQUERADE、LOG、DNAT、<br /><br />SNAT、MIRROR、QUEUE、RETURN、MARK，分别说明如下：<br />ACCEPT 将封包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则炼（natostrouting）。<br />REJECT 拦阻该封包，并传送封包通知对方，可以传送的封包有几个选择：ICMP port-unreachable、ICMP echo-reply 或是&nbsp;<br />tcp-reset（这个封包会要求对方关闭联机），进行完此处理动作后，将不再比对其它规则，直接 中断过滤程序。 范例如下：<br />iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset<br />DROP 丢弃封包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。<br />REDIRECT 将封包重新导向到另一个端口（PNAT），进行完此处理动作后，将 会继续比对其它规则。 这个功能可以用来实作通透式<br />porxy 或用来保护 web 服务器。例如：iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080<br />MASQUERADE 改写封包来源 IP 为防火墙 NIC IP，可以指定 port 对应的范围，进行完此处理动作后，直接跳往下一个规则<br />（mangleostrouting）。这个功能与 SNAT 略有不同，当进行 IP 伪装时，不需指定要伪装成哪个 IP，IP 会从网卡直接读<br />，当使用拨接连线时，IP 通常是由 ISP 公司的 DHCP 服务器指派的，这个时候 MASQUERADE 特别有用。范例如下：<br />iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000<br />LOG 将封包相关讯息纪录在 /var/log 中，详细位置请查阅 /etc/syslog.conf 组态档，进行完此处理动作后，将会继续比对其<br />规则。例如：<br />iptables -A INPUT -p tcp -j LOG --log-prefix "INPUT packets"<br />SNAT 改写封包来源 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将直接跳往下一个规则<br />（mangleostrouting）。范例如下：<br />iptables -t nat -A POSTROUTING -p tcp-o eth0 -j SNAT --to-source 194.236.50.155-194.236.50.160:1024-32000<br />DNAT 改写封包目的地 IP 为某特定 IP 或 IP 范围，可以指定 port 对应的范围，进行完此处理动作后，将会直接跳往下一个规<br />炼（filter:input 或 filter:forward）。范例如下：<br />iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT --to-destination<br />192.168.1.1-192.168.1.10:80-100<br />MIRROR 镜射封包，也就是将来源 IP 与目的地 IP 对调后，将封包送回，进行完此处理动作后，将会中断过滤程序。<br />QUEUE 中断过滤程序，将封包放入队列，交给其它程序处理。透过自行开发的处理程序，可以进行其它应用，例如：计算联机费<br />.......等。<br />RETURN 结束在目前规则炼中的过滤程序，返回主规则炼继续过滤，如果把自订规则炼看成是一个子程序，那么这个动作，就相当<br />提早结束子程序并返回到主程序中。<br />MARK 将封包标上某个代号，以便提供作为后续过滤的条件判断依据，进行完此处理动作后，将会继续比对其它规则。范例如下：<br />iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2</td>

</tr>

</tbody>

</table>

</div>
<div id="comment_14985526" class="cm">&nbsp;</div>
<div id="post_rate_div_14985526">&nbsp;</div>

</div>

</div>

</td>

</tr>
<tr>
<td class="plc plm">&nbsp;</td>

</tr>

</tbody>
</table>]]></description></item><item><title>linux IPC</title><link>http://www.cnblogs.com/isohybrid/archive/2013/02/28/IPC.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 27 Feb 2013 17:13:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/02/28/IPC.html</guid><description><![CDATA[<p><span>IPC进程间通信(Inter-Process Communication)就是指多个进程之间相互通信，交换信息的方法。Linux IPC基本上都是从Unix平台上继承而来的。主要包括最初的Unix IPC，System V IPC以及基于Socket的IPC。另外，Linux也支持POSIX IPC。</span></p>
<p><strong>System V,BSD,POSIX</strong></p>
<p>&nbsp;&nbsp;&nbsp; System V是Unix操作系统最早的商业发行版之一。它最初由AT&amp;T(American Telephone &amp; Telegraph)开发，最早在1983年发布。System V主要发行了4个版本，其中SVR4(System V Release 4)是最成功的版本。BSD(Berkeley Software Distribution，有时也被称为Berkeley Unix)是加州大学于1977至1995年间开发的。在19世纪八十年代至九十年代之间，System V和BSD代表了Unix的两种主要的操作风格。它们的主要区别如下:</p>
<p>&nbsp;&nbsp;&nbsp; 系统&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System V&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BSD<br />&nbsp;&nbsp;&nbsp; root脚本位置&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /etc/init.d/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /etc/rc.d/<br />&nbsp;&nbsp;&nbsp; 默认shell&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bshell&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cshell<br />&nbsp;&nbsp;&nbsp; 文件系统数据&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /etc/mnttab&nbsp;&nbsp; &nbsp; /etc/mtab<br />&nbsp;&nbsp;&nbsp; 内核位置&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /UNIX&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; /vmUnix<br />&nbsp;&nbsp;&nbsp; 打印机设备&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lp&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rlp<br />&nbsp;&nbsp;&nbsp; 字符串函数&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcopy&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; bcopy<br />&nbsp;&nbsp;&nbsp; 终端初始化设置文件&nbsp;&nbsp; &nbsp;/etc/initab&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; /etc/ttys<br />&nbsp;&nbsp;&nbsp; 终端控制&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; termio&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; termios</p>
<p>&nbsp;&nbsp;&nbsp; Linux系统的操作风格往往介于这两种风格之间。</p>
<p>&nbsp;&nbsp;&nbsp; POSIX(Portable Operating System Interface [for Unix])是由IEEE(Institute of Electrical and Electronics Engineers，电子电气工程协会)开发的。现有的大部分Unix都遵循POSIX标准，而Linux从一开始就遵循POSIX标准。</p>
<p><strong>最初的Unix IPC</strong></p>
<p><strong><em>1、信号</em></strong></p>
<p>&nbsp;&nbsp;&nbsp; 信号是Unix/Linux系统在一定条件下生成的事件。信号是一种异步通信机制，进程不需要执行任何操作来等待信号的到达。信号异步通知接收信号的进程发生了某个事件，然后操作系统将会中断接收到信号的进程的执行，转而去执行相应的信号处理程序。</p>
<p>&nbsp;&nbsp;&nbsp; (1)注册信号处理函数<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;signal.h&gt;</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*typedef void (*sighandler_t)(int);&nbsp; sighandler_t signal(int signum,sighandler_t handler);*/</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* void (*signal(int signum, void (*handler)(int)))(int);&nbsp;&nbsp;//SIG_IGN &amp;&amp; SIG_DFL<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span></p>
<p>&nbsp;&nbsp;&nbsp; (2)发送信号<br />&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;signal.h&gt;</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* int kill(pid_t pid,int sig);&nbsp;//#include &lt;sys/types.h&gt;&nbsp;</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* int raise(int sig);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//kill(getpid(),sig);</span><br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* unsigned int alarm(unsigned int seconds);&nbsp;//(#include &lt;unistd.h&gt;) seconds秒后，向进程本身发送SIGALRM信号。</span></p>
<p>&nbsp;&nbsp;&nbsp; (3)信号集<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 信号集被定义为:<span>typedef struct {unsigned long sig[_NSIG_WORDS];} sigset_t;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>* int sigaddset(sigset_t *set,int sig);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>*</span><span>&nbsp;int sigemptyset(sigset_t *set);</span></p>
<p><em><strong>2、管道(Pipe)</strong></em></p>
<p>&nbsp;&nbsp;&nbsp; 管道用来连接不同进程之间的数据流。</p>
<p>&nbsp;&nbsp;&nbsp; (1)在两个程序之间传递数据的最简单的方法是使用popen()和pclose()函数:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>#include &lt;stdio.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *popen(const char *command, const char *open_mode);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pclose(FILE *stream);</span><br />&nbsp;&nbsp;&nbsp; popen()函数首先调用一个shell，然后把<em>command</em>作为参数传递给shell。这样每次调用popen()函数都需要启动两个进程；但是由于在Linux中，所有的参数扩展(parameter expansion)都是由shell执行的，这样<em>command</em>中包含的所有参数扩展都可以在<em>command</em>程序启动之前完成。</p>
<p>&nbsp;&nbsp;&nbsp; (2)pipe()函数:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>#include &lt;unistd.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int pipe(int pipefd[2]);</span><br />&nbsp;&nbsp;&nbsp; popen()函数只能返回一个管道描述符，并且返回的是文件流(file stream)，可以使用函数fread()和fwrite()来访问。pipe()函数可以返回两个管道描述符:<em>pipefd[0]</em>和<em>pipefd[1]</em>，任何写入<em>pipefd[1]</em>的数据都可以从<em>pipefd[0]</em>读回；pipe()函数返回的是文件描述符(file descriptor)，因此只能使用底层的read()和write()系统调用来访问。pipe()函数通常用来实现父子进程之间的通信。</p>
<p>&nbsp;&nbsp;&nbsp; (3)命名管道:FIFO<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;sys/types.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &lt;sys/stat.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mkfifo(const char *fifo_name, mode_t mode);</span><br />&nbsp;&nbsp;&nbsp; 前面两种管道只能用在相关的程序之间，使用命名管道可以解决这个问题。在使用open()打开FIFO时，mode中不能包含O_RDWR。mode最常用的是O_RDONLY，O_WRONLY与O_NONBLOCK的组合。O_NONBLOCK影响了read()和write()在FIFO上的执行方式。</p>
<p>&nbsp;&nbsp;&nbsp; PS:要想查看库函数用法，最可靠的资料来自Linux manual page:</p>
<p>&nbsp;&nbsp;&nbsp; $sudo apt-get install manpages-dev</p>
<p>&nbsp;&nbsp;&nbsp; $man 3&nbsp;<span><em>function_name</em></span></p>
<p>&nbsp;</p>
<div class="postText">
<p><strong>System V IPC</strong></p>
<p>&nbsp;&nbsp;&nbsp; System V IPC指的是AT&amp;T在System V.2发行版中引入的三种进程间通信工具:(1)信号量，用来管理对共享资源的访问 (2)共享内存，用来高效地实现进程间的数据共享 (3)消息队列，用来实现进程间数据的传递。我们把这三种工具统称为System V IPC的对象，每个对象都具有一个唯一的IPC标识符(identifier)。要保证不同的进程能够获取同一个IPC对象，必须提供一个IPC关键字(IPC key)，内核负责把IPC关键字转换成IPC标识符。&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp; System V IPC具有相似的语法，一般操作如下:</p>
<p>&nbsp;&nbsp;&nbsp; (1)选择IPC关键字，可以使用如下三种方式:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a)IPC_PRIVATE。由内核负责选择一个关键字然后生成一个IPC对象并把IPC标识符直接传递给另一个进程。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b)直接选择一个关键字。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)使用ftok()函数生成一个关键字。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(2)使用semget()/shmget()/msgget()函数根据IPC关键字key和一个标志flag创建或访问IPC对象。如果key是IPC_PRIVATE;或者key尚未与已经存在的IPC对象相关联且flag中包含IPC_CREAT标志，那么就会创建一个全新的IPC对象。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(3)使用semctl()/shmctl()/msgctl()函数修改IPC对象的属性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(4)使用semctl()/shmctl()/msgctl()函数和IPC_RMID标志销毁IPC实例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;System V IPC为每个IPC对象设置了一个ipc_perm结构体并在创建IPC对象的时候进行初始化。这个结构体中定义了IPC对象的访问权限和所有者:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span>struct ipc_perm{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid_t uid;&nbsp;&nbsp;&nbsp;<span>//所有者的用户id</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gid_t gid;&nbsp;&nbsp;&nbsp;<span>//所有者的组id</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uid_t cuid;&nbsp;&nbsp;<span>//创建者的用户id</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gid_t cgid;&nbsp;&nbsp;<span>//创建者的组id</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode_t mode;&nbsp;<span>//访问模式</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hellip;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span>};</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;shell中管理IPC对象的命令是ipcs、ipcmk和ipcrm。</p>
<p><strong><em>1、信号量(Semaphores)</em></strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;System V的信号量集表示的是一个或多个信号量的集合。内核为每个信号量集维护一个semid_ds数据结构，而信号量集中的每个信号量使用一个无名结构体表示，这个结构体至少包含以下成员:<br />&nbsp;&nbsp;&nbsp;&nbsp;<span>struct{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short semval;<span>//信号量值，总是&gt;=0</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid_t sempid;&nbsp;&nbsp;<span>//上一次操作的pid</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&hellip;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span>};</span></p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;sys/types.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;sys/ipc.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span>#include &lt;sys/sem.h&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(1)创建或访问信号量<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp; * int semget(key_t key,int nsems,int flag);&nbsp;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;nsems指定信号量集中信号量的个数，如果只是获取信号量集的标识符(而非新建)，那么nsems可以为0。flag的低9位作为信号量的访问权限位，类似于文件的访问权限;如果flag中同时指定了IPC_CREAT和IPC_EXCL，那么如果key已与现存IPC对象想关联的话，函数将会返回EEXIST错误。例如，flag可以为IPC_CREAT|0666。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(2)控制信号量集<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span>* int semctl(int semid,int semnum,int cmd,union semun arg);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;对semid信号量集合执行cmd操作;cmd常用的两个值是:SETVAL初始化第semnum个信号量的值为arg.val;IPC_RMID删除信号量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(3)对一个或多个信号量进行操作<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>&nbsp;&nbsp;</span><span>* int semop(int semid,struct sembuf *sops,unsigned nsops);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* struct sembuf{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;unsigned short sem_num;&nbsp;&nbsp;<span>//信号量索引</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;short&nbsp;&nbsp; sem_op;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>//对信号量进行的操作，常用的两个值为-1和+1，分别代表P、V操作</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;short &nbsp; sem_flag;&nbsp;&nbsp;&nbsp;<span>//比较重要的值是SEM_UNDO:当进程结束时，相应的操作将被取消；</span><span>同时，如果进程结束时没有释放资源的话，系统会自动释放</span><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>};</span></p>
<p><em><strong>2、共享内存</strong></em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;共享内存允许两个或多个进程共享一定的存储区，因为不需要拷贝数据，所以这是最快的一种IPC。</p>
<p>&nbsp;<span>&nbsp;&nbsp;&nbsp;</span><span>#include &lt;sys/ipc.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span>#include &lt;sys/shm.h&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(1)创建或访问共享内存<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * int shmget(key_t key,size_t size,int shmflg);</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(2)附加共享内存到进程的地址空间<br />&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>* void *shmat(int shmid,const void *shmaddr,int shmflg);<span>//shmaddr通常为NULL，由系统选择共享内存附加的地址;shmflg可以为SHM_RDONLY</span></span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(3)从进程的地址空间分离共享内存<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span>* int shmdt(const void *shmaddr);</span>&nbsp;<span>//shmaddr是shmat()函数的返回值</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(4)控制共享内存<br /><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* int shmctl(int shmid,int cmd,struct shmid_ds *buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* struct shmid_ds{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;struct ipc_perm shm_perm;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&hellip;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>};&nbsp;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;cmd的常用取值有:(a)IPC_STAT获取当前共享内存的shmid_ds结构并保存在buf中(2)IPC_SET使用buf中的值设置当前共享内存的shmid_ds结构(3)IPC_RMID删除当前共享内存</p>
<p><em><strong>3、消息队列</strong></em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;消息队列保存在内核中，是一个由消息组成的链表。</p>
<p>&nbsp;<span>&nbsp;&nbsp;&nbsp;</span><span>#include &lt;sys/types.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;#include &lt;sys/ipc.h&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;</span><span>#include &lt;sys/msg.h&gt;</span><br />&nbsp;&nbsp;&nbsp;&nbsp;(1)创建或访问消息队列<br /><span>&nbsp;&nbsp;&nbsp; * int msgget(key_t key,int msgflg);</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(2)操作消息队列<br />&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>* int msgsnd(int msqid,const void *msg,size_t nbytes,int msgflg);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;msg指向的结构体必须以一个long int成员开头，作为msgrcv()的消息类型，必须大于0。nbytes指的是msg指向结构体的大小，但不包括long int部分的大小<br />&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>* ssize_t msgrcv(int msqid,void *msg,size_t nbytes,long msgtype,int msgflg);</span><br />&nbsp;&nbsp;&nbsp;&nbsp;如果msgtype是0，就返回消息队列中的第一个消息;如果是正整数，就返回队列中的第一个该类型的消息;如果是负数，就返回队列中具有最小值的第一个消息，并且该最小值要小于等于msgtype的绝对值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;(3)控制消息队列<br />&nbsp;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span>* int msgctl(int msqid,int cmd,struct msqid_ds *buf);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* struct msqid_ds{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;struct ipc_perm msg_perm;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&hellip;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</span></p>

</div>
<div class="postText">
<p><strong>Socket</strong><br />　　套接字(Socket)是由Berkeley在BSD系统中引入的一种基于连接的IPC，是对网络接口(硬件)和网络协议(软件)的抽象。它既解决了无名管道只能在相关进程间单向通信的问题，又解决了网络上不同主机之间无法通信的问题。</p>
<p>　　套接字有三个属性:域(domain)、类型(type)和协议(protocol)，对应于不同的域，套接字还有一个地址(address)来作为它的名字。</p>
<p>　　域(domain)指定了套接字通信所用到的协议族，最常用的域是AF_INET，代表网络套接字，底层协议是IP协议。对于网络套接字，由于服务器端有可能会提供多种服务，客户端需要使用IP端口号来指定特定的服务。AF_UNIX代表本地套接字，使用Unix/Linux文件系统实现。</p>
<p>　　IP协议提供了两种通信手段:流(streams)和数据报(datagrams)，对应的套接字类型(type)分别为流式套接字和数据报套接字。流式套接字(SOCK_STREAM)用于提供面向连接、可靠的数据传输服务。该服务保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字使用TCP协议。数据报套接字(SOCK_DGRAM)提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP协议。</p>
<p>　　一种类型的套接字可能可以使用多于一种的协议来实现，套接字的协议(protocol)属性用于指定一种特定的协议。</p>
<div class="wp_codebox_msgheader"><span class="right"><sup><a title="WP-CodeBox HowTo?" href="http://www.ericbess.com/ericblog/2008/03/03/wp-codebox/#examples" target="_blank"><span>&nbsp;</span></a></sup></span></div>

</div>
<p><span>总结：</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>System V IPC API</p>
<p>&nbsp;</p>
<p>1,消息队列</p>
<p>int ftok(const char *pathname, int prj_id);</p>
<p>int msgget(key_t key,int msgflag);</p>
<p>int msgsnd(int msqid,const void *msgp,size_t msgsz,int msgflg);</p>
<p>int msgrcv(int msqid,void *msgp,size_t msgsz,long msgtyp,int msgflg);</p>
<p>&nbsp;</p>
<p>2,信号量</p>
<p>int semget(key_t key,int nsems,int semflag);</p>
<p>int semctl(int semid,int semnum,int cmd,&hellip;);</p>
<p>int semop(int semid,struct sembuf *sops,unsigned nsops,struct timespec *timeout);</p>
<p>&nbsp;</p>
<p>3,共享内存</p>
<p>int shmget(key_t key,size_t size,int shmflag);</p>
<p>int shmctl(int shmid,int cmd,struct shmid_ds *buf);</p>
<p>&nbsp;&nbsp;</p>
<p>POSIX IPC API</p>]]></description></item><item><title>Unix中 . ;source 与 /ABS/path/* ; ./＊ ;sh *的区别</title><link>http://www.cnblogs.com/isohybrid/archive/2013/02/27/sh.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 27 Feb 2013 15:52:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/02/27/sh.html</guid><description><![CDATA[<p>标题中的命令都可以用来执行一个文件，如脚本（.sh .pl .tcsh等）或一个配置文件（.bashrc &nbsp;.vimrc等）。但它们是有区别的。其中，</p>
<p>$ . &nbsp; filename</p>
<p>$ source &nbsp;filename</p>
<p>是在当前的shell中运行，而</p>
<p>$ /absolute/path/to/filename</p>
<p>$ ./filename</p>
<p>$ sh &nbsp;filename &nbsp; &nbsp;（或者bash, tcsh等）</p>
<p>则是到一个新建的子shell中去运行。</p>
<p>&nbsp;</p>
<p>差别体现在，当你运行的文件中有变量声明时，在前一种情况，这些新变量的值会被保留在当前shell中；而在后一种情况，当你的文件被执行完后，子shell被关闭回到当前shell，那些新变量的值会随子shell一齐被删除掉。</p>
<p>因此，我们在配置环境变量时一般都要用第一种方式运行配置文件，而如果用第二种方式将会无效。</p>
<p>如果你试图监视子shell中的变量定义情况，那么就不要期望着用第二种方式运行后还能echo出它的值，而你只能是在你的被执行文件中对你关心的变量使用echo命令，这样才有效。</p>
<p>同样需要注意的是，反过来，当前shell（父shell）的所有变量却可以被其子shel通通l继承下来。</p>
<p>----------------------------------------------------------------------------------</p>
<p>sh filename与./filename的区别在于</p>
<p><span>&ldquo;在一般的linux系统当中（如redhat）,使用sh调用执行脚本相当于打开了bash的POSIX标准模式（等效于bash的 --posix 参数），一般的，sh是bash的&ldquo;子集&rdquo;，不是子集的部分。bash程序执行，当&ldquo;$0&rdquo;是&ldquo;sh&rdquo;的时候，则要求代码遵循一定的规范，当不符合规范的语法存在时，则会报错，所以可以这样理解，&ldquo;sh&rdquo;并不是一个程序，而是一种标准（POSIX），这种标准，在一定程度上保证了脚本的跨系统性。&rdquo;</span></p>
<p>&nbsp;</p>
<p>[root@centos ~]# cat test.sh<br />#!/bin/bash<br />grep -wv -f &lt;(echo '1 2 3 5 9'|sed 's/\s/\n/g') &lt;(seq 1 10)<br />[root@centos ~]# <br />[root@centos ~]# sh test.sh<br />test.sh: line 2: syntax error near unexpected token `('<br />test.sh: line 2: `grep -wv -f &lt;(echo '1 2 3 5 9'|sed 's/\s/\n/g') &lt;(seq 1 10)'<br />[root@centos ~]# <br />[root@centos ~]# bash --posix test.sh<br />test.sh: line 2: syntax error near unexpected token `('<br />test.sh: line 2: `grep -wv -f &lt;(echo '1 2 3 5 9'|sed 's/\s/\n/g') &lt;(seq 1 10)'<br />[root@centos ~]# <br />[root@centos ~]# bash test.sh<br />4<br />6<br />7<br />8<br />10<br />[root@centos ~]# </p>]]></description></item><item><title>unset 与 null 对于$var=${str=expr}的影响</title><link>http://www.cnblogs.com/isohybrid/archive/2013/01/13/unset.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sat, 12 Jan 2013 22:25:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/01/13/unset.html</guid><description><![CDATA[<p><span style="font-family: song, Verdana; line-height: 22px; background-color: #f0f3fa;">例子1：<br style="word-wrap: break-word;" />
$ str=&nbsp;<br style="word-wrap: break-word;" />
$ var=${str=expr}&nbsp;<br style="word-wrap: break-word;" />
$ echo $var<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
$ echo $str<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
例子2：<br style="word-wrap: break-word;" />
$ unset str&nbsp;<br style="word-wrap: break-word;" />
$ var=${str=expr}&nbsp;<br style="word-wrap: break-word;" />
$ echo $var<br style="word-wrap: break-word;" />
expr<br style="word-wrap: break-word;" />
$ echo $str<br style="word-wrap: break-word;" />
expr</span></p>
<div><span style="font-family: song,Verdana;"><span style="line-height: 22px;">&nbsp;</span></span></div>
<div><span style="font-family: song,Verdana;"><span style="line-height: 22px;"><br /></span></span>
<div>原理：</div>



</div>
<div>&nbsp;</div>
<div>
<table style="word-wrap: break-word; empty-cells: show; border-collapse: collapse; table-layout: fixed; width: 838px;" cellspacing="0" cellpadding="0">
<tbody style="word-wrap: break-word;">
<tr style="word-wrap: break-word;">
<td style="word-wrap: break-word; font: normal normal normal 12px/normal song, Verdana; font-size: 14px; line-height: 1.6em;">
null是指该变量存在(内存存储单元)，但其值是空的。<br style="word-wrap: break-word;" />
set | grep variable_name<br style="word-wrap: break-word;" />
unset是删除变量名(连同内存存储单元也一并删除)，说白一点，就是该变量不存在了。<br style="word-wrap: break-word;" />
set | grep variable_name<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
${parameter=word}<br style="word-wrap: break-word;" />
注意"="等号左边没有":"冒号。<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
${parameter=word}<br style="word-wrap: break-word;" />
一、如果parameter属于unset的那种情况：<br style="word-wrap: break-word;" />
parameter没进行定义，bash就把word赋值给parameter，并显示parameter变量的值。<br style="word-wrap: break-word;" />
$ echo $testvar #没有定义testvar变量<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
$ echo ${testvar=123}<br style="word-wrap: break-word;" />
$ 123<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
$ echo $testvar #打印testvar的值<br style="word-wrap: break-word;" />
$ 123<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
二、如果parameter属于null那种情况<br style="word-wrap: break-word;" />
<span style="color: #f40000;">${parameter=word}，由于parameter进行了定义(只不过其值为空)，那么bash只显示parameter的值(后面也就不进行赋值操作)。</span><br style="word-wrap: break-word;" />

$
testvar=&nbsp;&nbsp;#对testvar赋null值<br style="word-wrap: break-word;" />

$ echo ${testvar=123} #无内容显示<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
$ echo $testvar #无内容显示<br style="word-wrap: break-word;" />
<br style="word-wrap: break-word;" />
如果把${testvar:=123}，注意多了一个冒号，其运行结果跟上述的unset的那种情况一样。<br style="word-wrap: break-word;" />
":"　是指为空(null)的意思。<br style="word-wrap: break-word;" />
${testvar:=123}，不管testvar为空或者没有进行定义，都把123赋给testvar这个变量，并打印该变量的值。<br style="word-wrap: break-word;" />

<br style="word-wrap: break-word;" />
还有<br style="word-wrap: break-word;" />
1. var=${str-expr} vs var=${str:-expr}<br style="word-wrap: break-word;" />
2. var=${str+expr} vs var=${str:+expr}<br style="word-wrap: break-word;" />
3. var=${str?expr} vs var=${str:?expr}<br style="word-wrap: break-word;" />
这些都是变量替换的几种形式。</td>


</tr>


</tbody>


</table>


</div>]]></description></item><item><title>随记1</title><link>http://www.cnblogs.com/isohybrid/archive/2013/01/08/bishi.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Tue, 08 Jan 2013 13:14:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/01/08/bishi.html</guid><description><![CDATA[<p>1.查看Linux系统当前单个共享内存段的最大值（命令）<br />ipcs -m<br />ipcs -a<br />2.用什么命令查询指定IP地址的服务器端口<br />题意应该是 nmap 和nbtscan 命令来扫吧。<br />3.crontab中用什么命令定义某个程序执行的优先级别<br />nice/renice：进程执行优先级</p>
<p>4.如何让history命令显示具体时间<br />HISTTIMEFORMAT=&rdquo;%Y-%m-%d %H:%M:%S &rdquo;<br />expect HISTTIMEFORMAT<br />重新开机后会还原，可以写／etc／profile<br />5.查看Linux系统当前指定用户的邮件队列<br />mailq 命令<br />打印两种类型的列表：<br />mailq 命令列出如下所示的邮件队列：<br />Mail Queue(1 request)<br />&mdash;QID&mdash;- &ndash;Size&ndash; &mdash;&ndash;Q-Time&mdash;&ndash; &mdash;&mdash;Sender/Recipient&mdash;&ndash;<br />AA02508 3 Thu Dec 17 10:01 root<br />(User unknown)<br />bad_user<br />mailq -v 命令列出如下所示的邮件队列：<br />Mail Queue (1 request)<br />&mdash;QID&mdash;- &ndash;Size&ndash; -Priority- &mdash;Q-Time&mdash; &ndash;Sender/Recipient&ndash;<br />AA02508 3 1005 Dec 17 10:01 root<br />(User unknown)<br />bad_user<br />6.查看Linux系统当前加载的库文件<br />lsof<br />7.Ext3文件系统如何恢复RM命令删除文件?<br />(1).Ext3文件系统结构的简单介绍<br />在Linux所用的Ext3文件系统中，文件是以块为单位存储的，默认情况下每个块的大小是1K，不同的块以块号区分。每个文件还有一个节点，节点中包含有文件所有者，读写权限，文件类型等信息。对于一个小于12个块的文件，在节点中直接存储文件数据块的块号。如果文件大于12个块，那么节点在12个块号之后存储一个间接块的块号，在这个间接块号所对应的块中，存储有256个文件数据块的块号（Ext2fs中每个块号占用4字节，这样一个块中所能存储的块号就是1024/4=256）。如果有更大的文件，那么还会在节点中出现二级间接块和三级间接块。<br />(2).恢复被误删文件的方法<br />大多数Linux发行版都提供一个debugfs工具，可以用来对Ext3文件系统进行编辑操作。不过在使用这个工具之前，还有一些工作要做。</p>
<p>首先以只读方式重新挂载被误删的文件所在分区。使用如下命令：（假设文件在/usr分区）<br />mount -r -n -o remount /usr<br />-r表示只读方式挂载；-n表示不写入/etc/mtab，如果是恢复/etc上的文件，就加上这个参数。如果系统说xxx partion busy，可以用fuser命令查看一下是哪些进程使用这个分区上的文件：<br />fuser -v -m /usr<br />如果没有什么重要的进程，用以下命令停掉它们：<br />fuser -k -v -m /usr<br />然后就可以重新挂载这些文件系统了。<br />如果是把所有的文件统一安装在一个大的/分区当中，可以在boot提示符下用linux single进入单用户模式，尽量减少系统进程向硬盘写入数据的机会，要不干脆把硬盘挂在别的机器上。另外，恢复出来的数据不要写到/上面，避免破坏那些有用的数据。如果机器上有dos/windows，可以写到这些分区上面：<br />mount -r -n /dev/hda1 /mnt/had<br />然后就可以执行debugfs：(假设Linux在 /dev/hda5)<br />#debugfs /dev/hda5<br />就会出现debugfs提示符debugfs：<br />使用lsdel命令可以列出很多被删除的文件的信息：<br />debugfs：lsdel<br />debugfs: 2692 deleted inodes found.<br />Inode Owner Mode Size Blocks Time deleted<br />164821 0 100600 8192 1/ 1 Sun May 13 19:22:46 2001<br />&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;<br />36137 0 100644 4 1/ 1 Tue Apr 24 10:11:15 2001<br />196829 0 100644 149500 38/ 38 Mon May 27 13:52:04 2001<br />debugfs:<br />列出的文件有很多（这里找到2692个），第一字段是文件节点号，第二字段是文件所有者，第三字段是读写权限，接下来是文件大小，占用块数，删除时间。然后就可以根据文件大小和删除日期判断那些是我们需要的。比如我们要恢复节点是196829的文件：<br />可以先看看文件数据状态：<br />debugfs：stat<br />Inode: 196829 Type: regular Mode: 0644 Flags: 0&times;0 Version: 1<br />User: 0 Group: 0 Size: 149500<br />File ACL: 0 Directory ACL: 0<br />Links: 0 Blockcount: 38<br />Fragment: Address: 0 Number: 0 Size: 0<br />ctime: 0x31a9a574 &mdash; Mon May 27 13:52:04 2001<br />atime: 0x31a21dd1 &mdash; Tue May 21 20:47:29 2001<br />mtime: 0x313bf4d7 &mdash; Tue Mar 5 08:01:27 2001<br />dtime: 0x31a9a574 &mdash; Mon May 27 13:52:04 2001<br />BLOCKS:<br />594810 594811 594814 594815 594816 594817 &hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.<br />TOTAL: 38<br />然后就可以用dump指令恢复文件：<br />debugfs：dump /mnt/hda/01.sav<br />这样就把文件恢复出来了。退出debugfs：<br />debugfs：quit<br />另一种方法是手工编辑inode：<br />debugfs：mi<br />Mode [0100644]<br />User ID [0]<br />Group ID [0]<br />Size [149500]<br />Creation time [0x31a9a574]<br />Modification time [0x31a9a574]<br />Access time [0x31a21dd1]<br />Deletion time [0x31a9a574] 0<br />Link count [0] 1<br />Block count [38]<br />File flags [0x0]<br />Reserved1 [0]<br />File acl [0]<br />Directory acl [0]<br />Fragment address [0]<br />Fragment number [0]<br />Fragment size [0]<br />Direct Block #0 [594810]<br />&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.<br />Triple Indirect Block [0]<br />使用mi指令后每次显示一行信息以供编辑，其它行可以直接按回车表示确认，把deletion time改成0（未删除），Link count改成1。改好后退出debugfs：<br />debugfs：quit<br />然后用fsck检查/dev/hda5<br />fsck /dev/hda5<br />程序会说找到丢失的数据块，放在lost+found里面。<br />8.查看当前系统某一硬件的驱动版本。比如网卡<br />dmidecode<br />9.DNS服务器有哪三种类型<br />主 从 缓存<br />10.apache目录访问身份验证的实施步骤（用htpasswd设置）<br />htpasswd -c /目录 user<br />alias /目录<br />11.使用tcpdump监听主机IP为192.168.1.1，tcp端口为80的数据，写出相应命令<br />tcpdump tcp port 80 host 192.168.1.1<br />12.简述IDS作用和实现原理<br />入侵检测，设备放在intelnet进来的第一台路由后面。对进入路由的所有的包进行检测，如果有异常就报警。<br />13.用sed修改test.txt的23行test为tset；<br />sed &lsquo;23s/test/tset/g &rsquo; test.txt</p>
<p>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</p>
<p>一、有文件file1<br />1、请用shell查询file1 里面空行的所在行号<br />awk &lsquo;{if($0~/^$/)print NR}&rsquo; file<br />or<br />grep -n ^$ file |awk &lsquo;BEGIN{FS=&rdquo;:&rdquo;}{print $1}&rsquo;<br /><br />2、编写ShellScript查询file1 以abc 结尾的行<br />grep abc$ file1<br /><br />3、打印出file1 文件第1 到第3 行<br />sed -n &rsquo;1,3p&rsquo; file1<br />head -3 file1<br /><br />二、如何将本地80 端口的请求转发到8080 端口，当前主机IP 为192.168.2.1<br />Iptables -A PREROUTING -d 192.168.2.1 -p tcp -m tcp &ndash;dport 80 -j DNAT -to-destination 192.168.2.1:8080<br />三、crontab<br />在11 月份内，每天的早上6 点到12 点中，每隔2 小时执行一次/usr/bin/httpd.sh 怎么<br />实现<br />0 6-12/2 * 11 * /usr/bin/httpd.sh<br /><br />四、编写个shell 脚本将/usr/local/test 目录下大于100K 的文件转移到/tmp 目录下<br />#!/bin/bash<br />for file in `ls /root`<br />do<br />if [ -f $file ]; then<br />if [ `ls -l $file|awk '{print $5}'` -gt 10000 ]; then<br />mv $file /tmp/<br />fi<br />fi<br />done<br /><br />五、简述raid0 raid1 raid5 三种工作模式的工作原理及特点。<br />　　RAID 0：连续以位或字节为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余，因此并不能算是真正的RAID 结构。RAID 0 只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据。因此，RAID 0 不能应用于数据安全性要求高的场合。<br />　　RAID 1：它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1 可以提高读取性能。RAID 1 是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写 ，而不需要重组失效的数据。简单来说就是：镜象结构，类似于备份模式，一个数据被复制到两块硬盘上。<br />　　RAID10:高可靠性与高效磁盘结构一个带区结构加一个镜象结构，因为两种结构各有优缺点，因此可以相互补充。主要用于容量不大，但要求速度和差错控制的数据库中。<br />　　RAID5：分布式奇偶校验的独立磁盘结构，它的奇偶校验码存在于所有磁盘上，任何一个硬盘损坏，都可以根据其它硬盘上的校验位来重建损坏的数据。支持一块盘掉线后仍然正常运行。<br /><br />六、oracle 数据库备份方式<br />　　物理备份：开启网络监听，备份数据库文件。<br />　　RMAN 备份：通过表空间文件在RMAN 模式对ORACLE 数据备份。<br /><br />七、如何查看占用端口8080 的进程<br />lsof -i:8080<br /><br />八、请写出apache2.X 版本的两种工作模式，以及各自工作原理。如何查看apache 当前所支持的模块，并且查看是工作在哪种模式下？<br />答案：<br />　　prefork(多进程，每个进程产生子进程)和worker（多进程，每个进程生成多个线程)<br />　　prefork 的工作原理是，控制进程在最初建立&ldquo;StartServers&rdquo;个子进程后，为了满足MinSpareServers 设置的需要创建一个进程，等待一秒钟，继续创建两个，再等待一秒钟，继续创建四个&hellip;&hellip;如此按指数级增加创建的进程数，最多达到每秒32 个，直到满足MinSpareServers 设置的值为止。这就是预派生（prefork）的由来。这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销以增加性能。<br />　　worker 是2.0 版中全新的支持多线程和多进程混合模型的MPM。由于使用线程来处理，所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器。但是，worker 也使用了多进程，每个进程又生成多个线程，以获得基于进程服务器的稳定性。这种MPM 的工作方式将是Apache 2.0 的发展趋势。<br />　　可以通过命令httpd -l 可以查看apache 当前的模块，如果带有worker.c 就是工作在worker 模式下，如果有prefork.c 就是工作在prefork.c 的模式下。<br /><br />九、你使用过监控软件吗？说说其特点<br />使用nagios 对服务器进行监控，其特点可实时实现手机短信、电子邮件、MSN、飞信报警。使用cacti 对流量进行监控。<br /><br />十、你对现在运维工程师的理解和以及对其工作的认识运维工程师在公司当中责任重大，需要保证时刻为公司及客户提供最高、最快、最稳定、最安全的服务。运维工程师的一个小小的失误，很有可能会对公司及客户造成重大损失，因此运维工程师的工作需要严谨及富有创新精神。<br /><br />十一、linux 下常用的DNS服务软件是什么，举出几种常用的DNS记录，如果域名abc.com配置好了一台邮件服务器,IP 地址为202.106.0.20，我该如何做相关的解析？是否了解bind 的智能解析，如果了解请简述一下其原理<br />答案：<br />1)常用的DNS 软件是bind<br />2)A 记录 地址记录<br />MX 记录 邮件交换记录<br />CNAME 记录 别名域记录<br />3)修改abc.com 域名的配置文件，增加以下记录<br />IN MX 10 mail.abc.com.<br />mail IN A 202.106.0.20<br />4)bind 根据请求解析客户端的IP 地址，做出不同的解析，其原理是在配置文件中，设定了<br />view，在每个view 都有客户端的IP 地址段，bind 服务器根据请求解析客户端的IP 地址，<br />匹配不同的view,再根据该view 的配置，到相应的配置文件进行查询，将结果返回给请求<br />的客户端。<br /><br />十二、通过apache 访问日志access.log 统计IP 和每个地址访问的次数，按访问量列出<br />前10 名。<br />日志格式样例如下<br />192.168.1.247 &ndash; - [02/Jul/2010:23:44:59 +0800] &ldquo;GET / HTTP/1.1&Prime; 200 19<br />答案：<br />cat access_log | awk &lsquo;{print $1}&rsquo; | uniq -c|sort -rn|head -10<br />//这个别的方法也能统计,但有些命令是必要的 awk , sort,uniq ,主要看是否这些命令都<br />使用了。<br />十三、如何用mysql 命令进行备份和恢复？以test 库为例，创建一个备份，并再用此备份<br />进行恢复。<br />mysqldump -u root -p test &gt; test.sql<br />mysql -u root -p test &lt; test.sql<br />//主要考对方msqldump &gt; test.sql 和 mysql &lt; test.sql<br />十四、你认为在系统调优方面都包括哪些工作，以linux 为例，请简明阐述，并举一些参数<br />为例。<br />答案：<br />系统调优包括内核参数优化和应用优化2 个方面，对方只要从这两方面来说，就可以了，<br />尽量能有些经验的阐述。<br />有个文件如下：<br /><br />http://a.domain.com/1.html<br /><br />http://b.domain.com/1.html<br /><br />http://c.domain.com/1.html<br /><br />http://a.domain.com/2.html<br /><br />http://b.domain.com/2.html<br /><br />http://a.domain.com/3.html<br /><br />要求：得到主机名（和域名），并统计哪个网址出现的次数，并排序。可以shell 或C。<br />得到的结果应该是:<br />3 a.domain.com<br />2 b.domain.com<br />1 c.domain.com<br />[root@mail ~]# awk &lsquo;BEGIN{FS=&rdquo;/&rdquo;}{arr[$3]++}END{for(i in arr) print<br />arr[i],i}&rsquo; list| sort -r 答案<br />3 a.domain.com<br />2 b.domain.com<br />1 c.domain.com<br />挂载windows 的共享目录？<br />mount.cifs //IP/SHARE linux 的目录 --verbose -o user=username &lt;--这个用户是<br />windows 下的用户--verbose 这个参数可以不加，它是显示过程的<br />例如mount.cifs //10.1.1.246/gongxiang /mnt --verbose -o user=gao<br />或者是mount -t cifs<br />umount /mnt 或umount.cifs /mnt -l &lt;--取消挂载<br />图形界面：smb://IP<br />A B 网络是通的，最少列出五种传输文件的服务<br />nfs ,ftp,scp ,rsync,samba,http://<br />1.假设Apache 产生的日志文件名为access_log,在apache 正在运行时,执行命令mv<br />access_log access_log.bak,执行完后,请问新的apache 的日志会打印到哪里,为什么?<br />新的日志会打印在access_log.bak 中，因为apache 启动时会找到access_log 文件，<br />随时准备向文件中加入日志信息，<br />虽然此时文件被改名，但是由于服务正在运行，因为它的inode 节点的位置没有变，程序<br />打开的fd 仍然会指向原来那个inode，<br />不会因为文件名的改变而改变。apache 会继续向已改名的文件中追加日志，但是若重启<br />apache 服务，系统会检查access_log<br />文件是否存在，若不存在则创建。<br />2.在Shell 环境下,如何查看远程Linux 系统运行了多少时间?<br />2、监控主机执行： ssh user@被监控主机ip "uptime"<br />这样得到了被监控主机的uptime<br />3.处理以下文件内容,将域名取出并进行计数排序,如处理:<br /><br />http://www.baidu.com/index.html<br /><br />http://www.baidu.com/1.html<br /><br />http://post.baidu.com/index.html<br /><br />http://mp3.baidu.com/index.html<br /><br />http://www.baidu.com/3.html<br /><br /><a href="http://post.baidu.com/2.html">http://post.baidu.com/2.html</a></p>
<p>得到如下结果:<br />域名的出现的次数 域名<br />3 www.baidu.com<br />2 post.baidu.com<br />1 mp3.baidu.com<br />可以使用bash/perl/php/c 任意一种<br />3、[root@localhost shell]# cat file | sed -e ' s/http:\/\///' -e ' s/\/.*//' | sort |<br />uniq -c | sort -rn<br />3 www.baidu.com<br />2 post.baidu.com<br />1 mp3.baidu.com<br />[root@codfei4 shell]# awk -F/ '{print $3}' file |sort -r|uniq -c|awk '{print<br />$1"\t",$2}'<br />3 www.baidu.com<br />2 post.baidu.com<br />1 mp3.baidu.com<br />4.如果得到随机的字串,长度和字串中出现的字符表可定义,并将字串倒序显示,如<br />把0123456789 作为基准的字串字符表,产生一个6 位的字串642031,打印出的字串为<br />130246,可使用bash/perl/php/c 任意一种.<br />4、[root@localhost ~]# awk -v count=6 'BEGIN<br />{srand();str="0123456789";len=length(str);for(i=count;i&gt;0;i--)<br />marry[i]=substr(str,int(rand()*len),1);for(i=count;i&gt;0;i--)<br />printf("%c",marry[i]);printf("\n");for<br />(i=0;i&lt;=count;i++) printf("%c",marry[i]);printf("\n")}'<br />838705<br />507838<br />5.如何查看当前Linux 系统的状态,如CPU 使用,内存使用,负载情况等.<br />5、Linux 系统中&ldquo;/proc&rdquo;是个伪文件目录,不占用系统空间，及时的反应出内存现在使用的<br />进程情况......其中许多文件都保存系统运行状态和相关信息<br />对于&ldquo;/proc&rdquo;中文件可使用文件查看命令浏览其内容，文件中包含系统特定信息：<br />cpuinfo 主机CPU 信息<br />filesystems 文件系统信息<br />meninfo 主机内存信息<br />version Linux 内存版本信息<br />diskstatus 磁盘负载情况<br />另外top 命令可以动态的显示当前系统进程用户的使用情况,而且是动态的显示出来，尤其<br />是在该命令显示出来的对上方对系统的情况进行汇总.<br />free 命令呢可以查看真实使用的内存 一般用free -m<br />使用lsof 、ps -aux 可以查看详细的每个进程的使用状况<br />dmesg 也是常用来查看系统性能的命令<br />#题目：有10 台被监控主机、一台监控机，在监控机上编写脚本，一旦某台被监控机器/<br />分区适用率大于80%， 就发邮件报警放到crontab 里面， 每10 分钟检查一次<br />#测试机器：虚拟机Linux as 4<br />#1.首先建立服务器间的信任关系。拿两台机器做测试<br />本机ip:192.168.1.6<br />[root@codfei ~]# ssh-keygen -t rsa<br />Generating public/private rsa key pair.<br />Enter file in which to save the key (/root/.ssh/id_rsa):<br />/root/.ssh/id_rsa already exists.<br />Overwrite (y/n)? y (以为我是第2 次建立关系所以此处覆盖原来的文件)<br />Enter passphrase (empty for no passphrase):(直接回车无须输入密钥)<br />Enter same passphrase again:<br />Your identification has been saved in /root/.ssh/id_rsa.<br />Your public key has been saved in /root/.ssh/id_rsa.pub.<br />The key fingerprint is:<br />04:37:13:2a:4b:10:af:c1:2b:03:3f:6b:27:ce:b9:62 root@codfei<br />[root@codfei ~]# cd .ssh/<br />[root@codfei .ssh]# ll<br />-rw------- 1 root root 883 Apr 25 17:51 id_rsa<br />-rw-r--r-- 1 root root 221 Apr 25 17:51 id_rsa.pub<br />-rw-r--r-- 1 root root 442 Apr 25 17:37 known_hosts<br />id_rsa 是密钥文件，id_rsa.pub 是公钥文件。<br />[root@codfei .ssh]# scp id_rsa.pub192.168.1.4:/root/.ssh/192.168.1.6<br />root@192.168.1.4's password:<br />id_rsa.pub 100% 221 0.2KB/s 00:00<br />这里把公钥文件取名为本机的ip 地址就是为了以后和更多的机器建立信任关系不发生混<br />淆。<br />现在登陆到192.168.1.4 机器<br />[root@codfei ~]# cd .ssh/<br />[root@codfei .ssh]# cat 192.168.1.6 &gt;&gt; authorized_keys<br />然后回到192.168.1.6 机器直接<br />[root@codfei .ssh]# ssh 192.168.1.4<br />Last login: Wed Aug 8 12:14:42 2007 from 192.168.1.6<br />这样就可以了，里面偶尔涉及到权限问题。一般./ssh 文件夹是755 authorized_keys 为<br />600 或者644<br />####脚本如下#######################<br />#!/bin/bash<br />#SCRIPT:df_check.sh<br />#Writeen by codfei Mon Sep 3 07:25:28 CST 2007<br />#PURPOSE:This script is used to monitor for full filesystems.<br />#######################Begining####################<br />####################<br />FSMAX="80"<br />remote_user='root' #####完全可以不用root<br />remote_ip=(192.168.1.5 192.168.1.6 192.168.1.7 192.168.1.8 192.168.1.9<br />192.168.1.10 192.168.1.11 192.168.1.12 192.168.1.13 192.168.1.14 ) ----&gt;<br />这里填写你要监控的主机ip<br />ip_num='0'<br />while [ "$ip_num" -le "$(expr ${#remote_ip[@]} - 1)" ]<br />do<br />read_num='1'<br />ssh "$remote_user"@"${remote_ip[$ip_num]}" df -h &gt; /tmp/diskcheck_tmp<br />grep '^/dev/*' /tmp/diskcheck_tmp|awk '{print $5}'|sed 's/\%//g' &gt;<br />/tmp/diskcheck_num_tmp<br />while [ "$read_num" -le $(wc -l &lt; /tmp/diskcheck_num_tmp) ]<br />do<br />size=$(sed -n "$read_num"'p' /tmp/diskcheck_num_tmp)<br />if [ "$size" -gt "$FSMAX" ]<br />then<br />$(grep '^/dev/*' /tmp/diskcheck_tmp|sed -n $read_num'p' &gt;<br />/tmp/disk_check_mail)<br />$(echo ${remote_ip[$ip_num]} &gt;&gt; /tmp/disk_check_mail)<br />$(mail -s "diskcheck_alert" admin &lt; /tmp/disk_check_mail)<br />fi<br />read_num=$(expr $read_num + 1)<br />done<br />ip_num=$(expr $ip_num + 1)<br />done<br />#############over################################<br />################让脚本每十分钟执行一次#############<br />在cron 表中加入<br />0/10 * * * * /home/codfei/diskcheck.sh 2&gt;&amp;1<br />################################################<br />##########################<br />比如， ext2 文件系统， 如果异常死机，开机如何修复文件系统？<br />如果异常关机，比如断电，通知机房的人开机之后，<br />我们需要远程修复、检查文件系统<br />除了/分区之外， 其他的分区：<br />umount /home<br />fsck -y /home<br />/ 分区需要开机之后， 由机房的人来扫描<br />随后我们再登录并扫描/home 等其他分区<br />如何查看一个进程所使用的文件句柄？<br />看这里面 /proc/进程号/fd/<br />的个数就行了<br />简单的比如如何查看apache 进程数<br />[root@localhost fd]# ps -ef|grep httpd|wc -l<br />1<br />如何统计apache 的每秒访问数？<br />tail access_log | awk '{print $1,$4}'<br />[root@localhost logs]# grep -c `date -d '3 second ago' +%T` access_log<br />0<br />################################################<br />1、/proc/sys 子目录的作用<br />该子目录的作用是报告各种不同的内核参数，并让您能交互地更改其中的某些。与 /proc<br />中所有其他文件不同，该目录中的某些文件可以写入，不过这仅针对 root。<br />其中的目录以及文件的详细列表将占据过多的篇幅，而且该目录的内容是依赖于系统的，而<br />大部分的文件也仅仅对某些特殊的应用程序有用。然而，以下是该子目录的两个最常见的用<br />途：<br />允许路由：即便是 Mandrakelinux 默认的内核也是允许路由的，您必需显式允许它这么<br />做。为此，您只要以 root 身份键入以下命令：<br />$ echo 1 &gt;/proc/sys/net/ipv4/ip_forward<br />如果您要禁用路由，请将上述命令中的 1 改为 0。<br />阻止 IP 欺骗：IP 欺骗会让人认为某个来自于外部的某个数据包是来自于它到达的那个接<br />口。这一技术常被骇客(cracker)所使用。您可以让内核阻止这种入侵。请键入：<br />$ echo 1 &gt;/proc/sys/net/ipv4/conf/all/rp_filter<br />这样，这种攻击就不再可能了。<br />这些改变仅当系统运行时有效。在系统重新启动之后，它们会改会它们的默认值。要在启动<br />时就改动这些值，您可以将您在 shell 提示符后键入的命令添加到 /etc/rc.d/rc.local 中<br />以免每次都键入它们。另一个方法是修改<br />/etc/sysctl.conf<br />2、将一个文本的奇数行和偶数行合并，第2 行和第3 行合并<br />[root@localhost bin]# cat 1<br />48 Oct 3bc1997 lpas 68.00 lvx2a 138<br />484 Jan 380sdf1 usp 78.00 deiv 344<br />483 nov 7pl1998 usp 37.00 kvm9d 644<br />320 aug der9393 psh 83.00 wiel 293<br />231 jul sdf9dsf sdfs 99.00 werl 223<br />230 nov 19dfd9d abd 87.00 sdiv 230<br />219 sept 5ap1996 usp 65.00 lvx2c 189<br />216 Sept 3zl1998 usp 86.00 kvm9e 234<br />[root@localhost bin]# sed '$!N;s/\n/ /g' 1<br />48 Oct 3bc1997 lpas 68.00 lvx2a 138 484 Jan 380sdf1 usp 78.00 deiv 344<br />483 nov 7pl1998 usp 37.00 kvm9d 644 320 aug der9393 psh 83.00 wiel 293<br />231 jul sdf9dsf sdfs 99.00 werl 223 230 nov 19dfd9d abd 87.00 sdiv 230<br />219 sept 5ap1996 usp 65.00 lvx2c 189 216 Sept 3zl1998 usp 86.00 kvm9e 234<br />[root@localhost bin]# sed -n -e 2p -e 3p 1|sed '$!N;s/\n/ /'<br />484 Jan 380sdf1 usp 78.00 deiv 344 483 nov 7pl1998 usp 37.00 kvm9d 644<br />3、read 命令5 秒后自动退出<br />[root@localhost bin]# read -t 5<br />4、自动ftp 上传<br />#!/bin/sh<br />ftp -n&lt;&lt;END_FTP<br />open 192.168.1.4<br />user codfei duibuqi //用户名codfei 密码duibuqi<br />binary<br />prompt off //关闭提示<br />mput test //上传test<br />close<br />bye<br />END_FTP<br />自动ssh 登陆 从A 到B 然后再到c<br />#!/usr/bin/expect -f<br />set timeout 30<br />spawn ssh codfei@B<br />expect "password:"<br />send "pppppp\r"<br />expect "]*"<br />send "ssh codfei@C\r"<br />expect "password:"<br />send "pppppp\r"<br />interact<br />5、#打印第一个域<br />[root@localhost bin]# cat 3<br />eqeqedadasdD<br />eqeqdadfdfDD<br />fdsfdsfQWEDD<br />DSADASDSADSA<br />[root@localhost bin]#<br />[root@localhost bin]#<br />[root@localhost bin]# awk -F "" '{print $1}' 3<br />e<br />e<br />f<br />D<br />6、实现字符串翻转<br />[root@localhost bin]# cat 8<br />qweqewqedadaddas<br />[root@localhost bin]# rev 8<br />saddadadeqweqewq<br />########################################第2 次电面<br />7、sed awk grep 哪个最好<br />我答的是 哪个掌握的精通，都很好，但是还是问我哪个最好，我只能说awk 了，对于行操<br />作和列操作都可以操作的很好。<br />8、grep -E -P 是什么意思<br />我说的是-E, --extended-regexp 采用规则表示式去解释样式。 -P 不太清楚<br />9、请介绍一下你对运维这个工作的理解，和应该具备的素质。<br />shell 脚本编程部分：<br />1．从a.log 文件中提取包含&ldquo;WARNING&rdquo;或&rdquo;FATAL&rdquo;,同时不包含&ldquo;IGNOR&rdquo;的行，然后，<br />提取以&ldquo;：&rdquo;分割的第五个字段？<br />2．添加一个新组为class01,然后，添加属于这个组的30 个用户，用户名的形式为stdXX,<br />其中，XX 从01 到30？<br />3．在每个月的第一天备份并压缩/etc 目录下的所有内容，存放在/root/backup 目录里，<br />且文件名为如下形式yymmdd_etc,yy 为年，mm为月，dd 为日。shell 程序fileback<br />存放在/usr/bin 目录下？<br />4．用shell 编程，判断一文件是不是字符设备文件，如果是将其拷贝到/dev 目录下？<br />参考答案：<br />#!/bin/bash<br />directory=/dev<br />for file in anaconda-ks.cfg install.log install.log.syslog<br />do<br />if [ -f $file ]<br />then<br />cp $file $directory/$file.bak<br />echo " HI, $LOGNAME $file is backed up already in $directory !!"<br />fi<br />done<br />5．某系统管理员需要每天做一定的重复工作，编制一个解决方案：<br />(1).从下午4：50 删除/abc 目录下的全部子目录和全部文件；<br />(2).从早上8：00～下午6：00 每小时读取/xyz 目录下x1 文件中每行第一个域的全部数<br />据加入到/backup 目录下的back01.txt 文件内；<br />(3).每逢周一下午5：50 将/data 目录下的所有目录和文件归档并压缩为文件<br />backup.tar.gz;<br />(4).在下午5：55 将IDE 接口的CD－ROM 缷载（假设CD－ROM 的设备名为hdc）;<br />(5).在早上8：00 前开机后启动。<br />－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br />－－－－－－－－－－－－－－－－－－<br />1、简述Apache 两种工作模式，以及它们之间的区别。<br />答案：最主要的两种模式是prefork 模式与worker 模式。prefork 每个子进程只有一个线<br />程，效率高但消耗内存大，是unix 下默认的模式；worker 模式每个子进程有多个线程，<br />内存消耗低，但一个线程崩溃会牵连其它同子进程的线程。<br />2、用iptables 添加一个规则允许192.168.0.123 访问本机3306 端口<br />iptables -I INPUT 1 -p tcp -m tcp --dport 3306 -s 192.168.0.123 -j ACCEPT<br />3、如何对一台Linux 服务器进行系统性能调优，列举出参数。<br />4、DNS 服务器的工作原理。<br />5、修改第一块网卡的路径是什么。<br />/etc/sysconfig/network-scripts/ifcfg-eth0<br />7、使用shell，建立class1 用户组，再批量建立stu1--stu30 的用户，并指定用户组为<br />class1。<br />vi autoaddusr<br />#!/usr/bin/php -q<br />&lt;?php<br />exec("groupadd class1");<br />for($i=1; $i&lt;=30; $i++){<br />exec("useradd -G class1 stu".$i);<br />}<br />?&gt;<br />chmod +x autoaddusr<br />./autoaddusr<br />8、个人对该工作的未来如何规划，需要加强哪些能力。<br />首先，我有一颗真诚的心，遇事沉着冷静，不急不躁；<br />其次，我有相应的专业知识和工作经验。一年多的系统管理经历锻炼了我在这个行业的业务<br />能力，并对行业前景和发展动态有相应的了解；<br />最后，我会用踏实的作风在今后的工作中证明我自己的能力！<br />9、日常监控都需要监控哪些？<br />1)硬件：<br />CPU：/proc/cpuinfo<br />内存：/proc/meminfo<br />硬盘：fdisk -l<br />2)系统：<br />负载：/proc/loadavg<br />uptime 查看实时load average、swap<br />虚拟内存：vmstat（参数-s；2 4）<br />SUID,用户,进程<br />系统日志：tail -f /var/log/messages<br />logwatch --print --range Today --service SSHD --service pam_unix<br />3)网络：Host_Alive,Ping,端口,连接<br />1.如何将本地80 端口的请求转发到8080 端口,当前主机IP 为192.168.16.1,其中本地<br />网卡eth0:<br />答：<br />#iptables -t nat -A PREROUTING -d 192.168.16.1 -p tcp --dport 80 -j DNAT --to<br />192.168.16.1:8080<br />或者：<br />#iptables -t nat -A PREROUTING -i eth0 -d 192.168.16.1 -p tcp -m tcp --dport<br />80 -j REDIRECT --to-ports 8080<br />2.什么是NAT,常见分为那几种，DNAT 与SNAT 有什么不同，应用事例有那些？<br />3.包过滤防火墙与代理应用防火墙有什么区别，能列举几种相应的产品吗？<br />4.iptables 是否支持time 时间控制用户行为，如有请写出具体操作步骤<br />5.说出你知道的几种linux/unix 发行版本<br />6.列出linux 常见打包工具并写相应解压缩参数(至少三种)<br />7.计划每星期天早8 点服务器定时重启,如何实现？<br />8.列出作为完整邮件系统的软件,至少二类<br />9，当用户在浏览器当中输入一个网g 站，说说计算机对dns 解释经过那些流程？注：本机<br />跟本地dns 还没有缓存。<br />答： a.用户输入网址到浏览器<br />b.浏览器发出DNS 请求信息<br />c.计算机首先查询本机HOST 文件，看是否存在，存在直接返回结果，不存在，继续下一<br />步<br />d.计算机按照本地DNS 的顺序，向合法dns 服务器查询IP 结果，<br />e.合法dns 返回dns 结果给本地dns，本地dns 并缓存本结果，直到TTL 过期，才再次<br />查询此结果<br />f.返回IP 结果给浏览器<br />g.浏览器根据IP 信息，获取页面<br />10，我们都知道，dns 既采用了tcp 协议，又采用了udp 协议，什么时候采用tcp 协议？<br />什么时候采用udp 协议？为什么要这么设计？<br />答：这个题需要理解的东西比较的多，分一下几个方面<br />a，从数据包大小上分：UDP 的最大包长度是65507 个字节，响应dns 查询的时候数据包<br />长度超过512 个字节，而返回的只要前512 个字节，这时名字解释器通常使用TCP 从发<br />原来的请求。<br />b，从协议本身来分：大部分的情况下使用UDP 协议，大家都知道UDP 协议是一种不可靠<br />的协议，dns 不像其它的使用UDP 的Internet 应用 (如：TFTP，BOOTP 和SNMP 等)，<br />大部分集中在局域网，dns 查询和响应需要经过广域网，分组丢失和往返时间的不确定性在<br />广域网比局域网上更大，这就要求dns 客户端需要好的重传和超时算法，这时候使用TCP<br />11，一个EXT3 的文件分区，当使用touch test.file 命令创建一个新文件时报错，报错的<br />信息是提示磁盘已满，但是采用df -h 命令查看磁盘大小时，只使用了，60%的磁盘空间，<br />为什么会出现这个情况，说说你的理由。<br />答：两种情况，一种是磁盘配额问题，另外一种就是EXT3 文件系统的设计不适合很多小<br />文件跟大文件的一种文件格式，出现很多小文件时，容易导致inode 耗尽了。<br />12，我们都知道FTP 协议有两种工作模式，说说它们的大概的一个工作流程？<br />FTP 两种工作模式：主动模式（Active FTP）和被动模式（Passive FTP）<br />在主动模式下，FTP 客户端随机开启一个大于1024 的端口N 向服务器的21 号端口发起<br />连接，然后开放N+1 号端口进行监听，并向服务器发出PORT N+1 命令。<br />服务器接收到命令后，会用其本地的FTP 数据端口（通常是20）来连接客户端指定的端口<br />N+1，进行数据传输。<br />在被动模式下，FTP 客户端随机开启一个大于1024 的端口N 向服务器的21 号端口发起<br />连接，同时会开启N+1 号端口。然后向服务器发送PASV 命令，通知服务器自己处于被动<br />模式。服务器收到命令后，会开放一个大于1024 的端口P 进行监听，然后用PORT P 命<br />令通知客户端，自己的数据端口是P。客户端收到命令后，会通过<br />N+1 号端口连接服务器的端口P，然后在两个端口之间进行数据传输。<br />总的来说，主动模式的FTP 是指服务器主动连接客户端的数据端口，被动模式的FTP 是指<br />服务器被动地等待客户端连接自己的数据端口。<br />被动模式的FTP 通常用在处于防火墙之后的FTP 客户访问外界FTp 服务器的情况，因为在<br />这种情况下，防火墙通常配置为不允许外界访问防火墙之<br />后主机，而只允许由防火墙之后的主机发起的连接请求通过。<br />因此，在这种情况下不能使用主动模式的FTP 传输，而被动模式的FTP 可以良好的工作。<br />13.编写个shell 脚本将当前目录下大于10K 的文件转移到/tmp 目录下<br />#/bin/sh<br />#Programm :<br /># Using for move currently directory to /tmp<br />for FileName in `ls -l |awk '$5&gt;10240 {print $9}'`<br />do<br />mv $FileName /tmp<br />done<br />ls -al /tmp<br />echo "Done! "<br />14.apache 有几种工作模式，分别介绍下其特点，并说明什么情况下采用不同的工作模<br />式？<br />apache 主要有两种工作模式：prefork(apache 的默认安装模式)和worker(可以在编译<br />的时候加参数--with-mpm-worker 选择工作模式)<br />prefork 的特点是：(预派生)<br />1.这种模式可以不必在请求到来时再产生新的进程，从而减小了系统开销<br />2.可以防止意外的内存泄漏<br />3.在服务器负载下降的时候会自动减少子进程数<br />worker 的特点是：支持混合的多线程多进程的多路处理模块<br />如果对于一个高流量的HTTP 服务器，worker MPM 是一个比较好的选择，因为worker<br />MPM 占用的内存要比prefork 要小。<br />15.名词解释 HDLC,VTP,OSPF,RIP,DDOS,system<br />V,GNU,netscreen,ssh,smartd,apache,WAIT_TIME 等等<br />16.编写shell 脚本获取本机的网络地址。比如：本机的ip 地址是：<br />192.168.100.2/255.255.255.0，那么它的网络地址是<br />192.168.100.1/255.255.255.0<br />方法一：<br />1. #!/bin/bash<br />2. #This script print ip and network<br />3. file="/etc/sysconfig/network-scripts/ifcfg-eth0"<br />4. if [ -f $file ] ;then<br />5. IP=`grep "IPADDR" $file|awk -F"=" '{ print $2 }'`<br />6. MASK=`grep "NETMASK" $file|awk -F"=" '{ print $2 }'`<br />7. echo "$IP/$MASK"<br />8. exit 1<br />9. fi<br />方法二：<br />1. #!/bin/bash<br />2. #This programm will printf ip/network<br />3. #<br />4. IP=`ifconfig eth0 |grep 'inet ' |sed 's/^.*addr://g'|sed 's/ Bcast.*$//g'`<br />5. NETMASK=`ifconfig eth0 |grep 'inet '|sed 's/^.*Mask://g'`<br />6. echo "$IP/$NETMASK"<br />7. exit<br />17.在命令行下发一邮件，发件人：123@abc.com,收信人：abc@xyz.com<br />二简答题：<br />1.linux 下如何改IP地址,主机名及DNS<br />2.linux 下如何添加路由<br />3.简述linux 下编译内核的意义与步骤<br />4.简述Linux 启动过程<br />5.简述DDOS 攻击的原理<br />6.简述Tcp 三次握手的过程<br />7.简述VPN，常见有哪几种？</p>]]></description></item><item><title>AWK关联数组</title><link>http://www.cnblogs.com/isohybrid/archive/2013/01/05/awk_array.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sat, 05 Jan 2013 15:14:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2013/01/05/awk_array.html</guid><description><![CDATA[<p><span style="background-color: #ffff00;"><strong>一、定义方法</strong></span></p>
<p><span style="background-color: #ffff00;">1：可以用数值作数组索引(下标)</span></p>
<pre><span style="background-color: #ffff00;">Tarray[1]=&ldquo;cheng mo&rdquo;
Tarray[2]=&ldquo;800927&rdquo;

</span></pre>
<p><span style="background-color: #ffff00;">2：可以用字符串作数组索引(下标)</span></p>
<pre><span style="background-color: #ffff00;">Tarray[&ldquo;first&rdquo;]=&ldquo;cheng &rdquo;
Tarray[&ldquo;last&rdquo;]=&rdquo;mo&rdquo;
Tarray[&ldquo;birth&rdquo;]=&rdquo;800927&rdquo;

</span></pre>
<p><span style="background-color: #ffff00;">使用中 print Tarray[1] 将得到&rdquo;cheng mo&rdquo; 而 print Tarray[2] 和 print[&ldquo;birth&rdquo;] 都将得到 &rdquo;800927&rdquo; 。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;"><strong>二、数组相关函数</strong></span></p>
<blockquote>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk --version</span><br /><span style="background-color: #ffff00;">GNU Awk 3.1.5</span></p>
<p><span style="background-color: #ffff00;">使用版本是：3.1以上，不同版本下面函数不一定相同</span></p>



</blockquote>
<ul>
<li><span style="background-color: #ffff00;">得到数组长度（<strong>length方法使用</strong>）</span></li>



</ul>
<blockquote>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{info="it is a test";lens=split(info,tA," ");print length(tA),lens;}'</span><br /><span style="background-color: #ffff00;">4 4</span></p>
<p><span style="background-color: #ffff00;">length返回字符串以及数组长度，split进行分割字符串为数组，也会返回分割得到数组长度。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">(asort使用）:</span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{info="it is a test";split(info,tA," ");print asort(tA);}'</span><br /><span style="background-color: #ffff00;">4</span></p>
<p><span style="background-color: #ffff00;">asort对数组进行排序，返回数组长度。</span></p>



</blockquote>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<ul>
<li><span style="background-color: #ffff00;">输出数组内容(无序，有序输出）：</span></li>



</ul>
<blockquote>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{info="it is a test";split(info,tA," ");for(k in tA){print k,tA[k];}}'</span><br /><span style="background-color: #ffff00;">4 test</span><br /><span style="background-color: #ffff00;">1 it</span><br /><span style="background-color: #ffff00;">2 is</span><br /><span style="background-color: #ffff00;">3 a</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">for&hellip;in 输出，因为数组是关联数组，默认是无序的。所以通过for&hellip;in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{info="it is a test";tlen=split(info,tA," ");for(k=1;k&lt;=tlen;k++){print k,tA[k];}}'&nbsp;</span><br /><span style="background-color: #ffff00;">1 it</span><br /><span style="background-color: #ffff00;">2 is</span><br /><span style="background-color: #ffff00;">3 a</span><br /><span style="background-color: #ffff00;">4 test</span></p>
<p><span style="background-color: #ffff00;">注意：数组下标是从1开始，与c数组不一样。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>



</blockquote>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<ul>
<li><span style="background-color: #ffff00;">判断键值存在以及删除键值：</span></li>



</ul>
<blockquote>
<p><span style="background-color: #ffff00;"><strong>一个错误的判断方法</strong>：</span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{tB["a"]="a1";tB["b"]="b1";if(tB["c"]!="1"){print "no found";};for(k in tB){print k,tB[k];}}'&nbsp;</span><br /><span style="background-color: #ffff00;">no found</span><br /><span style="background-color: #ffff00;">a a1</span><br /><span style="background-color: #ffff00;">b b1</span><br /><span style="background-color: #ffff00;">c</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">以上出现奇怪问题，tB[&ldquo;c&rdquo;]没有定义，但是循环时候，发现已经存在该键值，它的值为空，这里需要注意，awk数组是关联数组，只要通过数组引用它的key，就会自动创建改序列.</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;"><strong>正确判断方法：</strong></span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{tB["a"]="a1";tB["b"]="b1";if( "c" in tB){print "ok";};for(k in tB){print k,tB[k];}}'&nbsp;&nbsp;</span><br /><span style="background-color: #ffff00;">a a1</span><br /><span style="background-color: #ffff00;">b b1</span></p>
<p><span style="background-color: #ffff00;">if(key in array) 通过这种方法判断数组中是否包含&rdquo;key&rdquo;键值。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;"><strong>删除键值：</strong></span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{tB["a"]="a1";tB["b"]="b1";delete tB["a"];for(k in tB){print k,tB[k];}}'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br /><span style="background-color: #ffff00;">b b1</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">delete array[key]可以删除，对应数组key的，序列值。<br /></span></p>



</blockquote>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;"><strong>三、二维数组使用(多维数组使用）</strong></span></p>
<blockquote>
<p><span style="background-color: #ffff00;">awk的多维数组在本质上是一维数组，更确切一点，awk在存储上并不支持多维数组。awk提供了逻辑上模拟二维数组的访问方式。例 如，array[2,4] = 1这样的访问是允许的。awk使用一个特殊的字符串SUBSEP (\034)作为分割字段，在上面的例子中，关联数组array存储的键值实际上是2\0344。</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">类似一维数组的成员测试，多维数组可以使用 if ( (i,j) in array)这样的语法，但是下标必须放置在圆括号中。</span><br /><span style="background-color: #ffff00;">类似一维数组的循环访问，多维数组使用 for ( item in array )这样的语法遍历数组。与一维数组不同的是，多维数组必须使用split()函数来访问单独的下标分量。split ( item, subscr, SUBSEP)</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{</span></p>
<p><span style="background-color: #ffff00;">for(i=1;i&lt;=9;i++)</span><br /><span style="background-color: #ffff00;">{</span><br /><span style="background-color: #ffff00;">&nbsp; for(j=1;j&lt;=9;j++)&nbsp;&nbsp;</span><br /><span style="background-color: #ffff00;">&nbsp; {</span><br /><span style="background-color: #ffff00;">tarr[i,j]=i*j;</span><br /><span style="background-color: #ffff00;">print i,"*",j,"=",tarr[i,j];</span><br /><span style="background-color: #ffff00;">&nbsp; }</span><br /><span style="background-color: #ffff00;">}</span><br /><span style="background-color: #ffff00;">}'</span><br /><span style="background-color: #ffff00;">1 * 1 = 1</span><br /><span style="background-color: #ffff00;">1 * 2 = 2</span><br /><span style="background-color: #ffff00;">1 * 3 = 3</span><br /><span style="background-color: #ffff00;">1 * 4 = 4</span><br /><span style="background-color: #ffff00;">1 * 5 = 5</span><br /><span style="background-color: #ffff00;">1 * 6 = 6</span></p>
<p><span style="background-color: #ffff00;">&hellip;&hellip;</span></p>
<p><span style="background-color: #ffff00;">可以通过array[k,k2]引用获得数组内容.</span></p>
<p><span style="background-color: #ffff00;">&nbsp;</span></p>
<p><span style="background-color: #ffff00;">方法二：</span></p>
<p><span style="background-color: #ffff00;">[chengmo@localhost ~]$ awk 'BEGIN{</span><br /><span style="background-color: #ffff00;">for(i=1;i&lt;=9;i++)</span><br /><span style="background-color: #ffff00;">{</span><br /><span style="background-color: #ffff00;">&nbsp; for(j=1;j&lt;=9;j++)&nbsp;&nbsp;</span><br /><span style="background-color: #ffff00;">&nbsp; {</span><br /><span style="background-color: #ffff00;">tarr[i,j]=i*j;</span><br /><span style="background-color: #ffff00;">&nbsp; }</span><br /><span style="background-color: #ffff00;">}</span><br /><span style="background-color: #ffff00;">for(m in tarr)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><br /><span style="background-color: #ffff00;">{</span><br /><br /><span style="background-color: #ffff00;">split(m,tarr2,SUBSEP);</span><br /><span style="background-color: #ffff00;">print tarr2[1],"*",tarr2[2],"=",tarr[m];</span><br /><span style="background-color: #ffff00;">}</span><br /><span style="background-color: #ffff00;">}'</span></p>



</blockquote>
<div class="t_fsz">
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td id="postmessage_15581090" class="t_f">awk的数组，一种关联数组（Associative Arrays），下标可以是数字和字符串。因无需对数组名和元素提前声明，也无需指定元素个数 ，所以awk的数组使用非常灵活。<br />首先介绍下几个awk数组相关的知识点：<br /><br />&lt;1&gt;建立数组
<div class="blockcode">
<div id="code_I55"><ol>
<li>array[index] = value ：数组名array，下标index以及相应的值value。</li>



</ol></div>



<em>复制代码</em></div>



&lt;2&gt;读取数组值
<div class="blockcode">
<div id="code_GhS"><ol>
<li>{ for (item in array)&nbsp;&nbsp;print array[item]} # 输出的顺序是随机的</li>
<li>{for(i=1;i&lt;=len;i++)&nbsp;&nbsp;print array[i]} # Len 是数组的长度</li>



</ol></div>



<em>复制代码</em></div>



&lt;3&gt;多维数组，array[index1,index2,&hellip;&hellip;]：SUBSEP是数组下标分割符，默认为&ldquo;\034&rdquo;。可以事先设定SUBSEP，也可以直接在SUBSEP的位置输入你要用的分隔符，如：
<div class="blockcode">
<div id="code_gfA"><ol>
<li>awk 'BEGIN{SUBSEP=":";array["a","b"]=1;for(i in array) print i}'</li>
<li>a:b</li>
<li>awk 'BEGIN{array["a"":""b"]=1;for(i in array) print i}'</li>
<li>a:b</li>



</ol></div>



<em>复制代码</em></div>



但，有些特殊情况需要避免，如：
<div class="blockcode">
<div id="code_JIQ"><ol>
<li>awk 'BEGIN{</li>
<li>SUBSEP=":"</li>
<li>array["a","b:c"]=1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;# 下标为&ldquo;a:b:c&rdquo;</li>
<li>array["a:b","c"]=2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;#下标同样是&ldquo;a:b:c&rdquo;</li>
<li>for (i in array) print i,array[i]}'</li>
<li>a:b:c 2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;#所以数组元素只有一个。</li>



</ol></div>



<em>复制代码</em></div>



&lt;4&gt;删除数组或数组元素： 使用delete 函数
<div class="blockcode">
<div id="code_tTD"><ol>
<li>delete array&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;#删除整个数组</li>
<li>delete array[item]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;# 删除某个数组元素（item）</li>



</ol></div>



<em>复制代码</em></div>



&lt;5&gt; 排序：awk中的asort函数可以实现对数组的值进行排序，不过排序之后的数组下标改为从1到数组的长度。在gawk 3.1.2以后的版本还提供了一个asorti函数，这个函数不是依据关联数组的值，而是依据关联数组的下标排序，即asorti(array)以后，仍会用数字（1到数组长度）来作为下标，但是array的数组值变为排序后的原来的下标，除非你指定另一个参数如:asorti(a,b)。（非常感谢lionfun对asorti的指正和补充<img src="http://bbs.chinaunix.net/images/smilies/default/emn23.gif" alt="" width="20" height="20" border="0" />）<br /><br />
<div class="blockcode">
<div id="code_BBN"><ol>
<li>echo 'aa</li>
<li>bb</li>
<li>aa</li>
<li>bb</li>
<li>cc' |\</li>
<li>awk '{a[$0]++}END{l=asorti(a);for(i=1;i&lt;=l;i++)print a[i]}'</li>
<li>aa</li>
<li>bb</li>
<li>cc</li>
<li></li>
<li>echo 'aa</li>
<li>bb</li>
<li>aa</li>
<li>bb</li>
<li>cc' |\</li>
<li>awk '{a[$0]++}END{l=asorti(a,b);for(i=1;i&lt;=l;i++)print b[i],a[b[i]]}'</li>
<li>aa 2</li>
<li>bb 2</li>
<li>cc 1</li>



</ol></div>



<em>复制代码</em></div>



<br /><br />下面说awk数组的实际应用。<br /><br />1.&nbsp;&nbsp;除去重复项, 这个不多说, 只给出代码：
<div class="blockcode">
<div id="code_9Nt"><ol>
<li>awk '!a[$0]++' file(s) &nbsp; &nbsp;-----------------------------------------??------------------awk `if a[$0]==0 {a[$0]++;print $0}` file(s)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li>
<li>awk '!($0 in a){a[$0];print}' file(s)&nbsp; &nbsp;</li>



</ol></div>



<em>复制代码</em></div>



另一种：<a href="http://bbs.chinaunix.net/thread-1859344-1-1.html" target="_blank">http://bbs.chinaunix.net/thread-1859344-1-1.html</a>&nbsp;<br /><br />2. 计算总数（sum），如：
<div class="blockcode">
<div id="code_J1L"><ol>
<li>awk&nbsp;&nbsp;'{name[$0]+=$1};END{for(i in name) print&nbsp;&nbsp;i, name[i]}'</li>
<li></li>
<li>再举个例子：</li>
<li></li>
<li>echo "aaa 1</li>
<li>aaa 1</li>
<li>ccc 1</li>
<li>aaa 1</li>
<li>bbb 1</li>
<li>ccc 1" |awk '{a[$1]+=$2}END{for(i in a) print i,a[i]}'</li>
<li>aaa 3</li>
<li>bbb 1</li>
<li>ccc 2</li>



</ol></div>



<em>复制代码</em></div>



3. 查看文件差异。
<div class="blockcode">
<div id="code_6J1"><ol>
<li>cat file1</li>
<li>aaa</li>
<li>bbb</li>
<li>ccc</li>
<li>ddd</li>
<li>cat file2</li>
<li>aaa</li>
<li>eee</li>
<li>ddd</li>
<li>fff</li>



</ol></div>



<em>复制代码</em></div>



&lt;1&gt;&nbsp;&nbsp;合并file1和file2，除去重复项：
<div class="blockcode">
<div id="code_RGg"><ol>
<li>awk 'NR==FNR{a[$0]=1;print}&nbsp; &nbsp;#读取file1，建立数组a，下标为$0，并赋值为1，然后打印</li>
<li>NR&gt;FNR{&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; #读取file2</li>
<li>if(!(a[$0])) {print }&nbsp; &nbsp;&nbsp; &nbsp;#如果file2 的$0不存在于数组a中，即不存在于file1，则打印。</li>
<li>}' file1 file2</li>
<li>aaa</li>
<li>bbb</li>
<li>ccc</li>
<li>ddd</li>
<li>eee</li>
<li>fff</li>



</ol></div>



<em>复制代码</em></div>



&lt;2&gt; 提取文件1中有，但文件2中没有：
<div class="blockcode">
<div id="code_9ey"><ol>
<li>awk 'NR==FNR{a[$0]=1}&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;#读取file2，建立数组a，下标为$0，并赋值为1</li>
<li>NR&gt;FNR{&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; #读取file1</li>
<li>if(!(a[$0])) {print }&nbsp; &nbsp;&nbsp; &nbsp;#如果file1 的$0不存在于数组a中，即不存在于file2，则打印。</li>
<li>}' file2 file1</li>
<li>bbb</li>
<li>ccc</li>



</ol></div>



<em>复制代码</em></div>



另：<a href="http://bbs.chinaunix.net/viewthread.php?tid=2307853&amp;rpid=15547885&amp;ordertype=0&amp;page=1#pid15547885" target="_blank">http://bbs.chinaunix.net/viewthr ... &amp;page=1#pid15547885</a>&nbsp;<br /><br />4.&nbsp;&nbsp;排序：
<div class="blockcode">
<div id="code_jzt"><ol>
<li>echo "a</li>
<li>1</li>
<li>0</li>
<li>b</li>
<li>2</li>
<li>10</li>
<li>8</li>
<li>100" |</li>
<li>awk '{a[$0]=$0} #建立数组a，下标为$0，赋值也为$0</li>
<li>END{</li>
<li>len=asort(a)&nbsp; &nbsp;&nbsp; &nbsp;#利用asort函数对数组a的值排序，同时获得数组长度len</li>
<li>for(i=1;i&lt;=len;i++) print i "\t"a[i]&nbsp;&nbsp;#打印</li>
<li>}'</li>
<li>1&nbsp; &nbsp;&nbsp; &nbsp; 0</li>
<li>2&nbsp; &nbsp;&nbsp; &nbsp; 1</li>
<li>3&nbsp; &nbsp;&nbsp; &nbsp; 2</li>
<li>4&nbsp; &nbsp;&nbsp; &nbsp; 8</li>
<li>5&nbsp; &nbsp;&nbsp; &nbsp; 10</li>
<li>6&nbsp; &nbsp;&nbsp; &nbsp; 100</li>
<li>7&nbsp; &nbsp;&nbsp; &nbsp; a</li>
<li>8&nbsp; &nbsp;&nbsp; &nbsp; b</li>



</ol></div>



<em>复制代码</em></div>



5.&nbsp;&nbsp;有序输出：采用（index in array）的方式打印数组值的顺序是随机的，如果要按原序输出，则可以使用下面的方法：<a href="http://bbs2.chinaunix.net/viewthread.php?tid=1811279" target="_blank">http://bbs2.chinaunix.net/viewthread.php?tid=1811279</a>
<div class="blockcode">
<div id="code_KUX"><ol>
<li>awk '{a[$1]=$2</li>
<li>c[j++]=$1}</li>
<li>END{</li>
<li>for(m=0;m&lt;j;m++)print c[m],a[c[m]]</li>
<li>}'</li>



</ol></div>



<em>复制代码</em></div>



6.&nbsp;&nbsp;多个文本编辑：这里主要指的是待处理的文本之间的格式上有区别，如分隔符不同，；或是待处理文本需提取的信息的位置不同，如不同的列或行。<br />&lt;例1&gt;：
<div class="blockcode">
<div id="code_LIl"><ol>
<li>cat file1</li>
<li>g1.1 2</li>
<li>g2.2 4</li>
<li>g2.1 5</li>
<li>g4.1 3</li>
<li>cat file2</li>
<li>g1.1 2</li>
<li>g1.2 3</li>
<li>g4.1 4</li>
<li>cat file3</li>
<li>g1.2 3</li>
<li>g5.1 3</li>



</ol></div>



<em>复制代码</em></div>



要求输出：
<div class="blockcode">
<div id="code_Lpc"><ol>
<li>g1.1 2 2 -</li>
<li>g1.2 - 3 3</li>
<li>g2.2 4 - -</li>
<li>g2.1 5 - -</li>
<li>g4.1 3 4 -</li>
<li>g5.1 - - 3</li>



</ol></div>



<em>复制代码</em></div>



实现代码如下：
<div class="blockcode">
<div id="code_Ezq"><ol>
<li>awk '{a[ARGIND" "$1]=$2 # ARGIND是当前命令行文件的位置（从0开始），将它和第一列的value作为下标，建立数组a。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp; b[$1]&nbsp; &nbsp;#将第一列的value作为下标，建立数组b，目的是在读完所有文件之后，能得到第一列value的uniqe-list。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}</li>
<li>END{&nbsp;</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;for(i in b) {&nbsp;</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; printf i" "&nbsp;</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; for(j=1;j&lt;=ARGIND;j++) printf "%s ", a[j" "i]?a[j" "i]:"-" #此时的ARGIND值为3.</li>
<li>print ""&nbsp;</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; }</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}' file1 file2 file3</li>



</ol></div>



<em>复制代码</em></div>



这里是利用awk的内置变量ARGIND来处理完成对文件的处理。关于ARGIND，ARGV，ARGC的使用，大家可以参考：<a href="http://bbs.chinaunix.net/viewthread.php?tid=1790335&amp;from=favorites" target="_blank">http://bbs.chinaunix.net/viewthr ... 0335&amp;from=favorites</a>。<br />当然，我们也可以利用另外一个内置变量FILENAME来完成相同的任务（大家可以先想想怎么写），如下：
<div class="blockcode">
<div id="code_VpV"><ol>
<li>awk '{a[FILENAME" "$1]=$2;b[$1];c[FILENAME]}END{for(i in b) {printf i" ";for(j in c) printf "%s ", a[j" "i]?a[j" "i]:"-";print""}}' file1 file2 file3</li>



</ol></div>



<em>复制代码</em></div>



&lt;例2&gt;：对上面的数据的格式稍作改动，每个文件的分隔符都一样的情况，但输出要求不变：
<div class="blockcode">
<div id="code_ubT"><ol>
<li>cat file1</li>
<li>g1.1|2</li>
<li>g2.2|4</li>
<li>g2.1|5</li>
<li>g4.1|3</li>
<li>cat file2</li>
<li>g1.1#2</li>
<li>g1.2#3</li>
<li>g4.1#4</li>
<li>cat file3</li>
<li>g1.2@3</li>
<li>g5.1@3</li>



</ol></div>



<em>复制代码</em></div>



实现代码如下：
<div class="blockcode">
<div id="code_hQx"><ol>
<li>awk '{a[ARGIND" "$1]=$2</li>
<li>b[$1]</li>
<li>}</li>
<li>END{</li>
<li>for(i in b) {</li>
<li>printf i" "</li>
<li>for(j=2;j&lt;=ARGIND;j+=2) printf "%s ", a[j" "i]?a[j" "i]:"-" # 由于FS的设置也是有对应ARGIND值，所以对ARGIND稍作改动。</li>
<li>print ""</li>
<li>}</li>
<li>}' FS="|" file1 FS="#" file2 FS="@" file3 # 对每个文件分别设置FS的值。</li>



</ol></div>



<em>复制代码</em></div>



因为这个例子的数据比较简单，我们也可以在BEGIN模块中完成对FS值设置，如下：
<div class="blockcode">
<div id="code_Hm8"><ol>
<li>awk 'BEGIN{FS="[|#@]"}{a[ARGIND" "$1]=$2; b[$1]}END{for(i in b) {printf i" ";for(j=1;j&lt;=ARGIND;j++) printf "%s ", a[j" "i]?a[j" "i]:"-"; print ""}}' file1 file2 file3</li>



</ol></div>



<em>复制代码</em></div>



利用FILENAME 同样可以解决问题：
<div class="blockcode">
<div id="code_5rA"><ol>
<li>awk '</li>
<li>FILENAME=="file1"{FS="|"}&nbsp; &nbsp; # 设置FS</li>
<li>FILENAME=="file2"{FS="#"}&nbsp; &nbsp;#设置FS</li>
<li>FILENAME=="file3"{FS="@"}&nbsp;&nbsp;#设置FS&nbsp;</li>
<li># 稍显繁琐，不过一目了然</li>
<li>{$0=$0}&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;#使FS生效。</li>
<li>{a[ARGIND" "$1]=$2; b[$1]}</li>
<li>END{ for(i in b) {printf i" "; for(j=1;j&lt;=ARGIND;j++) printf "%s ", a[j" "i]?a[j" "i]:"-"; print ""}</li>
<li>}' file1 file2 file3</li>



</ol></div>



<em>复制代码</em></div>



推荐一个关于数组处理文件的帖子<a href="http://www.chinaunix.net/jh/24/577044.html" target="_blank">http://www.chinaunix.net/jh/24/577044.html</a>&nbsp;，里面有不少例子供大家学习。<br /><br />7.&nbsp;&nbsp;文本翻转或移位：二维或多维数组的应用<br />&lt;例1&gt;：
<div class="blockcode">
<div id="code_Ldc"><ol>
<li>Inputfile</li>
<li>1 2 3 4 5 6</li>
<li>2 3 4 5 6 1</li>
<li>3 4 5 6 1 2</li>
<li>4 5 6 1 2 3</li>
<li>Outputfile</li>
<li>4 3 2 1</li>
<li>5 4 3 2</li>
<li>6 5 4 3</li>
<li>1 6 5 4</li>
<li>2 1 6 5</li>
<li>3 2 1 6</li>
<li></li>
<li>awk '{</li>
<li>&nbsp; &nbsp;&nbsp;&nbsp;if (max_nf &lt; NF)</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; max_nf = NF # 数组第一维的长度</li>
<li>&nbsp; &nbsp;&nbsp;&nbsp;max_nr = NR&nbsp; &nbsp;&nbsp; &nbsp;# 数组第二维的长度</li>
<li>&nbsp; &nbsp;&nbsp;&nbsp;for (x = 1; x &lt;= NF; x++)</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; vector[x, NR] = $x #建立数组vector</li>
<li>}</li>
<li>END {</li>
<li>&nbsp; &nbsp;&nbsp;&nbsp;for (x = 1; x &lt;= max_nf; x++) {</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; for (y = max_nr; y &gt;= 1; --y)</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;printf("%s ", vector[x, y])</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; printf("\n")</li>
<li>&nbsp; &nbsp;&nbsp;&nbsp;}</li>
<li>}'</li>



</ol></div>



<em>复制代码</em></div>



&lt;例2&gt;：来自<a href="http://bbs.chinaunix.net/viewthread.php?tid=1842707&amp;rpid=13339226&amp;ordertype=0&amp;page=1#pid13339226" target="_blank">http://bbs.chinaunix.net/viewthr ... &amp;page=1#pid13339226</a><br />有两个文本a和b，要求输出c文本，合并的规则是按照第一行的headline（按字母顺序）合并文本a和b，空缺按&ldquo;0&rdquo;补齐。
<div class="blockcode">
<div id="code_k0P"><ol>
<li>cat a.txt</li>
<li>a b c d</li>
<li>1 2 9 7</li>
<li>4 5 8 9</li>
<li>5 3 6 1</li>
<li>cat b.txt</li>
<li>a e f d g</li>
<li>9 2 4 7 3</li>
<li>4 3 7 9 4</li>
<li>cat c.txt</li>
<li>a b c d e f g</li>
<li>1 2 9 7 0 0 0</li>
<li>4 5 8 9 0 0 0</li>
<li>5 3 6 1 0 0 0</li>
<li>9 0 0 7 2 4 3</li>
<li>4 0 0 9 3 7 4</li>



</ol></div>



<em>复制代码</em></div>



下面我们来参看并解读下Tim大师的代码：
<div class="blockcode">
<div id="code_nnY"><ol>
<li>awk '</li>
<li>FNR==1{&nbsp; &nbsp; #FNR==1，即a和b文本的第一行，这个用的真的很巧妙。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;for(i=1;i&lt;=NF;i++){&nbsp;</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; b[i]=$i&nbsp; &nbsp; #读取文本的每个元素存入数组b</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; c[$i]++}&nbsp;&nbsp;#另建立数组c，并统计每个元素的个数</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; next&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; #可以理解为，读取FNR!=1的文本内容。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}</li>
<li>{k++&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; # 统计除去第一行的文本行数</li>
<li>for(i=1;i&lt;=NF;i++)a[k","b[i]]=$i&nbsp;&nbsp;#利用一个二维数组来保持每个数字的位置， k，b[i]可以理解为每个数字的坐标。</li>
<li>}</li>
<li>END{</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;l=asorti(c)&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; #利用asorti函数对数组的下标进行排序，并获取数组长度，即输出文件的列数(NF值)</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;for(i=1;i&lt;=l;i++)printf c[i]" " # 先打印第一行，相当于headline。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;print ""</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;for(i=1;i&lt;=k;i++){</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; for(j=1;j&lt;=l;j++)printf a[i","c[j]]?a[i","c[j]]" ":"0 " # 打印二维数组的值。</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; print ""}</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;}' a.txt b.txt</li>



</ol></div>



<em>复制代码</em></div>



8.&nbsp;&nbsp;选择性打印：<br />打印某个关键字前几行，以3行为例：
<div class="blockcode">
<div id="code_g63"><ol>
<li>seq 20 |awk '/\&lt;10\&gt;/{for(i=NR-3;i&lt;NR;i++)print a[i%3];exit}{a[NR%3]=$0}'</li>
<li>7</li>
<li>8</li>
<li>9</li>



</ol></div>



<em>复制代码</em></div>



利用NR取余数，建立数组，这是一种非常高效的代码。<br /><br />9. 通过split函数建立数组：数组的下标为从1开始的数字。
<div class="blockcode">
<div id="code_H11"><ol>
<li>split(s, a [, r]) # s：string， a：array name，[,r]：regular expression。</li>
<li>echo 'abcd' |awk '{len=split($0,a,"");for(i=1;i&lt;=len;i++) print "a["i"] = " a[i];print "length = " len}'</li>
<li>a[1] = a</li>
<li>a[2] = b</li>
<li>a[3] = c</li>
<li>a[4] = d</li>
<li>length = 4</li>



</ol></div>



<em>复制代码</em></div>



10． awk数组使用的小技巧和需要避免的用法：<br /><br />&lt;1&gt; 嵌套数组：
<div class="blockcode">
<div id="code_o5K"><ol>
<li>awk 'BEGIN{a[1]=3;b[1]=1;print a[b[1]]}'</li>
<li>3</li>



</ol></div>



<em>复制代码</em></div>



&lt;2&gt; 下标设为变量或函数：
<div class="blockcode">
<div id="code_303"><ol>
<li>awk 'BEGIN{s=123;a[substr(s,2)]=substr(s,1,1);for(i in a)print "index : "i"\nvalue : "a[i]}'</li>
<li>index : 23</li>
<li>value : 1</li>



</ol></div>



<em>复制代码</em></div>



&lt;3&gt; 不可以将数组名作为变量使用，否则会报错：
<div class="blockcode">
<div id="code_aLA"><ol>
<li>awk 'BEGIN{a["1"] = 3; delete a;a=3;print a}'&nbsp;&nbsp;#即使你已经使用了delete函数。</li>
<li>awk: fatal: attempt to use array `a' in a scalar context</li>



</ol></div>



<em>复制代码</em></div>



&lt;4&gt; 数组的长度：
<div class="blockcode">
<div id="code_Tw1"><ol>
<li>length(array)&nbsp;&nbsp;</li>



</ol></div>



<em>复制代码</em></div>



&lt;5&gt; match 函数也可以建立数组（你知道么？<img src="http://bbs.chinaunix.net/images/smilies/default/icon_smile.gif" alt="" width="15" height="15" border="0" />，版本要求高于gawk 3.1.2）
<div class="blockcode">
<div id="code_q5a"><ol>
<li>echo "foooobazbarrrrr |&nbsp;</li>
<li>gawk '{ match($0, /(fo+).+(bar*)/, arr)&nbsp;&nbsp;#匹配到的部分自动赋值到arr中，下标从1开始</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; print arr[1], arr[2]</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; print arr[1, "start"], arr[1, "length"]&nbsp;&nbsp;#二维数组arr[index,＂start＂]值=RSTART</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; print arr[2, "start"], arr[2, "length"]&nbsp;&nbsp;#二维数组arr[index,＂length＂]值=RLENGTH</li>
<li>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; }'</li>
<li>foooo barrrrr</li>
<li>1 5</li>
<li>9 7</li>



</ol></div>



<em>复制代码</em></div>



&lt;6&gt;想到过用split清空数组么?<img src="http://bbs.chinaunix.net/images/smilies/default/icon_smile.gif" alt="" width="15" height="15" border="0" />
<div class="blockcode">
<div id="code_mDD"><ol>
<li>awk 'BEGIN{</li>
<li>split("abc",array,"")</li>
<li>print "array[1] = "array[1],"\narray[2] = "array[2],"\narray[3] = "array[3]</li>
<li>split("",array)</li>
<li>print "array[1] = "array[1],"\narray[2] ="array[2],"\narray[3] ="array[3]</li>
<li>}'</li>
<li>array[1] = a</li>
<li>array[2] = b</li>
<li>array[3] = c</li>
<li>array[1] =</li>
<li>array[2] =</li>
<li>array[3] =</li>



</ol></div>



<em>复制代码</em></div>



</td>



</tr>



</tbody>



</table>



</div>
<div id="comment_15581090" class="cm">&nbsp;</div>
<dl id="ratelog_15581090" class="rate"><dd>
</dd></dl>]]></description></item><item><title>linux vim setting</title><link>http://www.cnblogs.com/isohybrid/archive/2012/12/14/vim_setting.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 14 Dec 2012 10:41:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/12/14/vim_setting.html</guid><description><![CDATA[<p>"*************************************</p>
<p>"set nu<br />"set autoindent<br />"set cindent<br />"set nocompatible<br />"set fileencodings+=utf8<br />":let Tlist_Auto_Open=1<br />":let Tlist_Auto_Update = 1<br />":let Tlist_Hightlight_Tag_On_BufEnter = 1</p>
<p>"**************************************</p>
<p>" All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just<br />" /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime<br />" you can find below.&nbsp; If you wish to change any of those settings, you should<br />" do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten<br />" everytime an upgrade of the vim packages is performed.&nbsp; It is recommended to<br />" make changes after sourcing debian.vim since it alters the value of the<br />" 'compatible' option.<br /><br />" This line should not be removed as it ensures that various options are<br />" properly set to work with the Vim-related packages available in Debian.<br />runtime! debian.vim<br /><br />" Uncomment the next line to make Vim more Vi-compatible<br />" NOTE: debian.vim sets 'nocompatible'.&nbsp; Setting 'compatible' changes numerous<br />" options, so any other options should be set AFTER setting 'compatible'.<br />"set compatible<br /><br />" Vim5 and later versions support syntax highlighting. Uncommenting the<br />" following enables syntax highlighting by default.<br />if has("syntax")<br />&nbsp; syntax on<br />endif<br /><br />" If using a dark background within the editing area and syntax highlighting<br />" turn on this option as well<br />"set background=dark<br /><br />" Uncomment the following to have Vim jump to the last position when<br />" reopening a file<br />"if has("autocmd")<br />"&nbsp; au BufReadPost * if line("'\"") &gt; 1 &amp;&amp; line("'\"") &lt;= line("$") | exe "normal! g'\"" | endif<br />"endif<br /><br />" Uncomment the following to have Vim load indentation rules and plugins<br />" according to the detected filetype.<br />"if has("autocmd")<br />"&nbsp; filetype plugin indent on<br />"endif<br /><br />" The following are commented out as they cause vim to behave a lot<br />" differently from regular Vi. They are highly recommended though.<br />"set showcmd&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Show (partial) command in status line.<br />"set showmatch&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Show matching brackets.<br />"set ignorecase&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Do case insensitive matching<br />"set smartcase&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Do smart case matching<br />"set incsearch&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Incremental search<br />"set autowrite&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Automatically save before commands like :next and :make<br />"set hidden&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " Hide buffers when they are abandoned<br />"set mouse=a&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;" Enable mouse usage (all modes)<br /><br />" Source a global configuration file if available<br />if filereadable("/etc/vim/vimrc.local")<br />&nbsp; source /etc/vim/vimrc.local<br />endif<br /><br />"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br /><br />"=========================================================================<br />" DesCRiption: 适合自己使用的vimrc文件，for Linux/Windows, GUI/Console<br />"<br />" Last Change: 2010年08月02日 15时13分&nbsp;<br />"<br />" Version:&nbsp;&nbsp;&nbsp;&nbsp; 1.80<br />"<br />"=========================================================================<br /><br />set nocompatible&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 关闭 vi 兼容模式<br />syntax on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 自动语法高亮<br />"colorscheme molokai&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设定配色方案<br />set number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 显示行号<br />set cursorline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 突出显示当前行<br />set ruler&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 打开状态栏标尺<br />set shiftwidth=4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4<br />"set softtabstop=4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 使得按退格键时可以一次删掉 4 个空格<br />set tabstop=4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设定 tab 长度为 4<br />set nobackup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 覆盖文件时不备份<br />set autochdir&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 自动切换当前目录为当前文件所在的目录<br />"filetype plugin indent on&nbsp;&nbsp; " 开启插件<br />set backupcopy=yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置备份时的行为为覆盖<br />set ignorecase smartcase&nbsp;&nbsp;&nbsp; " 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感<br />set nowrapscan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 禁止在搜索到文件两端时重新搜索<br />set incsearch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 输入搜索内容时就显示搜索结果<br />set hlsearch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 搜索时高亮显示被找到的文本<br />set noerrorbells&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 关闭错误信息响铃<br />set novisualbell&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 关闭使用可视响铃代替呼叫<br />set t_vb=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 置空错误铃声的终端代码<br />" set showmatch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 插入括号时，短暂地跳转到匹配的对应括号<br />" set matchtime=2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 短暂跳转到匹配括号的时间<br />set magic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置魔术<br />set hidden&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存<br />"set guioptions-=T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 隐藏工具栏<br />"set guioptions-=m&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 隐藏菜单栏<br />set smartindent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 开启新行时使用智能自动缩进<br />set backspace=indent,eol,start<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 不设定在插入状态无法用退格键和 Delete 键删除回车符<br />set cmdheight=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设定命令行的行数为 1<br />set laststatus=2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 显示状态栏 (默认值为 1, 无法显示状态栏)<br />set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置在状态行显示的信息<br />"set foldenable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 开始折叠<br />"set foldmethod=syntax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置语法折叠<br />"set foldcolumn=0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置折叠区域的宽度<br />"setlocal foldlevel=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置折叠层数为<br />" set foldclose=all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 设置为自动关闭折叠&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<br />" nnoremap &lt;space&gt; @=((foldclosed(line('.')) &lt; 0) ? 'zc' : 'zo')&lt;CR&gt;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 用空格键来开关折叠<br /><br /><br />" return OS type, eg: windows, or linux, mac, et.st..<br />function! MySys()<br />&nbsp;&nbsp;&nbsp; if has("win16") || has("win32") || has("win64") || has("win95")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "windows"<br />&nbsp;&nbsp;&nbsp; elseif has("unix")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "linux"<br />&nbsp;&nbsp;&nbsp; endif<br />endfunction<br /><br /><br />" 配置多语言环境<br />if has("multi_byte")<br />&nbsp;&nbsp;&nbsp; " UTF-8 编码<br />&nbsp;&nbsp;&nbsp; set encoding=utf-8<br />&nbsp;&nbsp;&nbsp; set termencoding=utf-8<br />&nbsp;&nbsp;&nbsp; set formatoptions+=mM<br />&nbsp;&nbsp;&nbsp; set fencs=utf-8,gbk<br /><br />&nbsp;&nbsp;&nbsp; if v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set ambiwidth=double<br />&nbsp;&nbsp;&nbsp; endif<br /><br />&nbsp;&nbsp;&nbsp; if has("win32")<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source $VIMRUNTIME/delmenu.vim<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; source $VIMRUNTIME/menu.vim<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; language messages zh_CN.utf-8<br />&nbsp;&nbsp;&nbsp; endif<br />else<br />&nbsp;&nbsp;&nbsp; echoerr "Sorry, this version of (g)vim was not compiled with +multi_byte"<br />endif<br /><br />" Buffers操作快捷方式!<br />nnoremap &lt;C-RETURN&gt; :bnext&lt;CR&gt;<br />nnoremap &lt;C-S-RETURN&gt; :bprevious&lt;CR&gt;<br /><br />" Tab操作快捷方式!<br />nnoremap &lt;C-TAB&gt; :tabnext&lt;CR&gt;<br />nnoremap &lt;C-S-TAB&gt; :tabprev&lt;CR&gt;<br /><br />"关于tab的快捷键<br />" map tn :tabnext&lt;cr&gt;<br />" map tp :tabprevious&lt;cr&gt;<br />" map td :tabnew .&lt;cr&gt;<br />" map te :tabedit<br />" map tc :tabclose&lt;cr&gt;<br /><br />"窗口分割时,进行切换的按键热键需要连接两次,比如从下方窗口移动<br />"光标到上方窗口,需要&lt;c-w&gt;&lt;c-w&gt;k,非常麻烦,现在重映射为&lt;c-k&gt;,切换的<br />"时候会变得非常方便.<br />nnoremap &lt;C-h&gt; &lt;C-w&gt;h<br />nnoremap &lt;C-j&gt; &lt;C-w&gt;j<br />nnoremap &lt;C-k&gt; &lt;C-w&gt;k<br />nnoremap &lt;C-l&gt; &lt;C-w&gt;l<br /><br />"一些不错的映射转换语法（如果在一个文件中混合了不同语言时有用）<br />"nnoremap &lt;leader&gt;1 :set filetype=xhtml&lt;CR&gt;<br />"nnoremap &lt;leader&gt;2 :set filetype=css&lt;CR&gt;<br />"nnoremap &lt;leader&gt;3 :set filetype=javascript&lt;CR&gt;<br />"nnoremap &lt;leader&gt;4 :set filetype=php&lt;CR&gt;<br /><br />" set fileformats=unix,dos,mac<br />" nmap &lt;leader&gt;fd :se fileformat=dos&lt;CR&gt;<br />" nmap &lt;leader&gt;fu :se fileformat=unix&lt;CR&gt;<br /><br />" use Ctrl+[l|n|p|cc] to list|next|previous|jump to count the result<br />" map &lt;C-x&gt;l &lt;ESC&gt;:cl&lt;CR&gt;<br />" map &lt;C-x&gt;n &lt;ESC&gt;:cn&lt;CR&gt;<br />" map &lt;C-x&gt;p &lt;ESC&gt;:cp&lt;CR&gt;<br />" map &lt;C-x&gt;c &lt;ESC&gt;:cc&lt;CR&gt;<br /><br /><br />" 让 Tohtml 产生有 CSS 语法的 html<br />" syntax/2html.vim，可以用:runtime! syntax/2html.vim<br />let html_use_css=1<br /><br />" Python 文件的一般设置，比如不要 tab 等<br />autocmd FileType python set tabstop=4 shiftwidth=4 expandtab<br />autocmd FileType python map &lt;F12&gt; :!python %&lt;CR&gt;<br /><br />" 选中状态下 Ctrl+c 复制<br />vmap &lt;C-c&gt; "+y<br /><br />" 打开javascript折叠<br />"let b:javascript_fold=1<br />" 打开javascript对dom、html和css的支持<br />"let javascript_enable_domhtmlcss=1<br />" 设置字典 ~/.vim/dict/文件的路径<br />"autocmd filetype javascript set dictionary=$VIMFILES/dict/javascript.dict<br />"autocmd filetype css set dictionary=$VIMFILES/dict/css.dict<br />"autocmd filetype php set dictionary=$VIMFILES/dict/php.dict<br /><br />"-----------------------------------------------------------------<br />" plugin - bufexplorer.vim Buffers切换<br />" \be 全屏方式查看全部打开的文件列表<br />" \bv 左右方式查看&nbsp;&nbsp; \bs 上下方式查看<br />"-----------------------------------------------------------------<br /><br /><br />"-----------------------------------------------------------------<br />"plugin - taglist.vim&nbsp; 查看函数列表，需要ctags程序<br />" F4 打开隐藏taglist窗口<br />"-----------------------------------------------------------------<br />"let Tlist_Show_One_File = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 不同时显示多个文件的tag，只显示当前文件的<br />"let Tlist_Exit_OnlyWindow = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 如果taglist窗口是最后一个窗口，则退出vim<br />"let Tlist_Use_Right_Window = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 在右侧窗口中显示taglist窗口<br />"let Tlist_File_Fold_Auto_Close=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 自动折叠当前非编辑文件的方法列表<br />let Tlist_Auto_Open = 0<br />let Tlist_Auto_Update = 1<br />let Tlist_Hightlight_Tag_On_BufEnter = 1<br />let Tlist_Enable_Fold_Column = 0<br />let Tlist_Process_File_Always = 1<br />let Tlist_Display_Prototype = 0<br />let Tlist_Compact_Format = 1<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - mark.vim 给各种tags标记不同的颜色，便于观看调式的插件。<br />" \m&nbsp; mark or unmark the word under (or before) the cursor<br />" \r&nbsp; manually input a regular expression. 用于搜索.<br />" \n&nbsp; clear this mark (i.e. the mark under the cursor), or clear all highlighted marks .<br />" \*&nbsp; 当前MarkWord的下一个&nbsp;&nbsp;&nbsp;&nbsp; \#&nbsp; 当前MarkWord的上一个<br />" \/&nbsp; 所有MarkWords的下一个&nbsp;&nbsp;&nbsp; \?&nbsp; 所有MarkWords的上一个<br />"-----------------------------------------------------------------<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - NERD_tree.vim 以树状方式浏览系统中的文件和目录<br />" :ERDtree 打开NERD_tree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :NERDtreeClose&nbsp;&nbsp;&nbsp; 关闭NERD_tree<br />" o 打开关闭文件或者目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t 在标签页中打开<br />" T 在后台标签页中打开&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! 执行此文件<br />" p 到上层目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P 到根目录<br />" K 到第一个节点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; J 到最后一个节点<br />" u 打开上层目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m 显示文件系统菜单（添加、删除、移动操作）<br />" r 递归刷新当前目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R 递归刷新当前根目录<br />"-----------------------------------------------------------------<br />" F3 NERDTree 切换<br />map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;<br />imap &lt;F3&gt; &lt;ESC&gt;:NERDTreeToggle&lt;CR&gt;<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - NERD_commenter.vim&nbsp;&nbsp; 注释代码用的，<br />" [count],cc 光标以下count行逐行添加注释(7,cc)<br />" [count],cu 光标以下count行逐行取消注释(7,cu)<br />" [count],cm 光标以下count行尝试添加块注释(7,cm)<br />" ,cA 在行尾插入 /* */,并且进入插入模式。 这个命令方便写注释。<br />" 注：count参数可选，无则默认为选中行或当前行<br />"-----------------------------------------------------------------<br />"let NERDSpaceDelims=1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; " 让注释符与语句之间留一个空格<br />"let NERDCompactSexyComs=1&nbsp;&nbsp; " 多行注释时样子更好看<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - DoxygenToolkit.vim&nbsp; 由注释生成文档，并且能够快速生成函数标准注释<br />"-----------------------------------------------------------------<br />"let g:DoxygenToolkit_authorName="Asins - asinsimple AT gmail DOT com"<br />"let g:DoxygenToolkit_briefTag_funcName="yes"<br />"map &lt;leader&gt;da :DoxAuthor&lt;CR&gt;<br />"map &lt;leader&gt;df :Dox&lt;CR&gt;<br />"map &lt;leader&gt;db :DoxBlock&lt;CR&gt;<br />"map &lt;leader&gt;dc a /*&nbsp; */&lt;LEFT&gt;&lt;LEFT&gt;&lt;LEFT&gt;<br /><br /><br />"-----------------------------------------------------------------<br />" plugin &ndash; ZenCoding.vim 很酷的插件，HTML代码生成<br />" 插件最新版：http://github.com/mattn/zencoding-vim<br />" 常用命令可看：http://nootn.com/blog/Tool/23/<br />"-----------------------------------------------------------------<br /><br /><br />"-----------------------------------------------------------------<br />" plugin &ndash; checksyntax.vim&nbsp;&nbsp;&nbsp; JavaScript常见语法错误检查<br />" 默认快捷方式为 F5<br />"-----------------------------------------------------------------<br />"let g:checksyntax_auto = 0 " 不自动检查<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - NeoComplCache.vim&nbsp;&nbsp;&nbsp; 自动补全插件<br />"-----------------------------------------------------------------<br />"let g:AutoComplPop_NotEnableAtStartup = 1<br />"let g:NeoComplCache_EnableAtStartup = 1<br />"let g:NeoComplCache_SmartCase = 1<br />"let g:NeoComplCache_TagsAutoUpdate = 1<br />"let g:NeoComplCache_EnableInfo = 1<br />"let g:NeoComplCache_EnableCamelCaseCompletion = 1<br />"let g:NeoComplCache_MinSyntaxLength = 3<br />"let g:NeoComplCache_EnableSkipCompletion = 1<br />"let g:NeoComplCache_SkipInputTime = '0.5'<br />"let g:NeoComplCache_SnippetsDir = $VIMFILES.'/snippets'<br />" &lt;TAB&gt; completion.<br />"inoremap &lt;expr&gt;&lt;TAB&gt; pumvisible() ? "\&lt;C-n&gt;" : "\&lt;TAB&gt;"<br />" snippets expand key<br />"imap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)<br />"smap &lt;silent&gt; &lt;C-e&gt; &lt;Plug&gt;(neocomplcache_snippets_expand)<br /><br /><br />"-----------------------------------------------------------------<br />" plugin - matchit.vim&nbsp;&nbsp; 对%命令进行扩展使得能在嵌套标签和语句之间跳转<br />" % 正向匹配&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g% 反向匹配<br />" [% 定位块首&nbsp;&nbsp;&nbsp;&nbsp; ]% 定位块尾<br />"-----------------------------------------------------------------<br /><br />"-----------------------------------------------------------------<br />" plugin - vcscommand.vim&nbsp;&nbsp; 对%命令进行扩展使得能在嵌套标签和语句之间跳转<br />" SVN/git管理工具<br />"-----------------------------------------------------------------<br /><br />"-----------------------------------------------------------------<br />" plugin &ndash; a.vim<br />"-----------------------------------------------------------------<br />"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++<br /><br />"在左侧打开taglist窗口<br />"let Tlist_Use_Right_Window=0<br />"自动折叠当前非编辑文件的方法列表<br />"let Tlist_File_Fold_Auto_Close=1</p>]]></description></item><item><title>Linux系统调用列表</title><link>http://www.cnblogs.com/isohybrid/archive/2012/12/14/syscall.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 14 Dec 2012 10:28:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/12/14/syscall.html</guid><description><![CDATA[<p>以下是Linux系统调用的一个列表，包含了大部分常用系统调用和由系统调用派生出的的函数。这可能是你在互联网上所能看到的唯一一篇中文注释的Linux系统调用列表，即使是简单的字母序英文列表，能做到这么完全也是很罕见的。</p>
<p>按照惯例，这个列表以man pages第2节，即系统调用节为蓝本。按照笔者的理解，对其作了大致的分类，同时也作了一些小小的修改，删去了几个仅供内核使用，不允许用户调用的系统调用，对个别本人稍觉不妥的地方作了一些小的修改，并对所有列出的系统调用附上简要注释。</p>
<p>其中有一些函数的作用完全相同，只是参数不同。（可能很多熟悉C++朋友马上就能联想起函数重载，但是别忘了Linux核心是用C语言写的，所以只能取成不同的函数名）。还有一些函数已经过时，被新的更好的函数所代替了（gcc在链接这些函数时会发出警告），但因为兼容的原因还保留着，这些函数我会在前面标上&ldquo;*&rdquo;号以示区别。</p>
<p><a name="1"></a>一、进程控制：</p>
<table class="ibm-data-table" style="width: 550px;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">fork</span></td>
<td><span style="color: #ff0000;">创建一个新进程</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">clone</span></td>
<td><span style="color: #ff0000;">按指定条件创建子进程</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">execve</span></td>
<td><span style="color: #ff0000;">运行可执行文件</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">exit</span></td>
<td><span style="color: #ff0000;">中止进程</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">_exit</span></td>
<td><span style="color: #ff0000;">立即中止当前进程</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getdtablesize</span></td>
<td><span style="color: #ff0000;">进程所能打开的最大文件数</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getpgid</span></td>
<td><span style="color: #ff0000;">获取指定进程组标识号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">setpgid</span></td>
<td><span style="color: #ff0000;">设置指定进程组标志号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getpgrp</span></td>
<td><span style="color: #ff0000;">获取当前进程组标识号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">setpgrp</span></td>
<td><span style="color: #ff0000;">设置当前进程组标志号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getpid</span></td>
<td><span style="color: #ff0000;">获取进程标识号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getppid</span></td>
<td><span style="color: #ff0000;">获取父进程标识号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getpriority</span></td>
<td><span style="color: #ff0000;">获取调度优先级</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">setpriority</span></td>
<td><span style="color: #ff0000;">设置调度优先级</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">modify_ldt</span></td>
<td><span style="color: #ff0000;">读写进程的本地描述表</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">nanosleep</span></td>
<td><span style="color: #ff0000;">使进程睡眠指定的时间</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">nice</span></td>
<td><span style="color: #ff0000;">改变分时进程的优先级</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">pause</span></td>
<td><span style="color: #ff0000;">挂起进程，等待信号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">personality</span></td>
<td><span style="color: #ff0000;">设置进程运行域</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">prctl</span></td>
<td><span style="color: #ff0000;">对进程进行特定操作</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">ptrace</span></td>
<td><span style="color: #ff0000;">进程跟踪</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_get_priority_max</span></td>
<td><span style="color: #ff0000;">取得静态优先级的上限</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_get_priority_min</span></td>
<td><span style="color: #ff0000;">取得静态优先级的下限</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_getparam</span></td>
<td><span style="color: #ff0000;">取得进程的调度参数</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_getscheduler</span></td>
<td><span style="color: #ff0000;">取得指定进程的调度策略</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_rr_get_interval</span></td>
<td><span style="color: #ff0000;">取得按RR算法调度的实时进程的时间片长度</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_setparam</span></td>
<td><span style="color: #ff0000;">设置进程的调度参数</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_setscheduler</span></td>
<td><span style="color: #ff0000;">设置指定进程的调度策略和参数</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">sched_yield</span></td>
<td><span style="color: #ff0000;">进程主动让出处理器,并将自己等候调度队列队尾</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">vfork</span></td>
<td><span style="color: #ff0000;">创建一个子进程，以供执行新程序，常与execve等同时使用</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">wait</span></td>
<td><span style="color: #ff0000;">等待子进程终止</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">wait3</span></td>
<td><span style="color: #ff0000;">参见wait</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">waitpid</span></td>
<td><span style="color: #ff0000;">等待指定子进程终止</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">wait4</span></td>
<td><span style="color: #ff0000;">参见waitpid</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">capget</span></td>
<td><span style="color: #ff0000;">获取进程权限</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">capset</span></td>
<td><span style="color: #ff0000;">设置进程权限</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">getsid</span></td>
<td><span style="color: #ff0000;">获取会晤标识号</span></td>
</tr>
<tr>
<td><span style="color: #ffff00;">setsid</span></td>
<td><span style="color: #ff0000;">设置会晤标识号</span></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p><a name="2"></a>二、文件系统控制</p>
<p> <br /><a name="N101B0"></a><strong>1、文件读写操作</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">fcntl</span></td>
<td><span style="color: #ff0000;">文件控制</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">open</span></td>
<td><span style="color: #ff0000;">打开文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">creat</span></td>
<td><span style="color: #ff0000;">创建新文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">close</span></td>
<td><span style="color: #ff0000;">关闭文件描述字</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">read</span></td>
<td><span style="color: #ff0000;">读文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">write</span></td>
<td><span style="color: #ff0000;">写文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">readv</span></td>
<td><span style="color: #ff0000;">从文件读入数据到缓冲数组中</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">writev</span></td>
<td><span style="color: #ff0000;">将缓冲数组里的数据写入文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">pread</span></td>
<td><span style="color: #ff0000;">对文件随机读</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">pwrite</span></td>
<td><span style="color: #ff0000;">对文件随机写</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">lseek</span></td>
<td><span style="color: #ff0000;">移动文件指针</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">_llseek</span></td>
<td><span style="color: #ff0000;">在64位地址空间里移动文件指针</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">dup</span></td>
<td><span style="color: #ff0000;">复制已打开的文件描述字</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">dup2</span></td>
<td><span style="color: #ff0000;">按指定条件复制文件描述字</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">flock</span></td>
<td><span style="color: #ff0000;">文件加/解锁</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">poll</span></td>
<td><span style="color: #ff0000;">I/O多路转换</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">truncate</span></td>
<td><span style="color: #ff0000;">截断文件</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">ftruncate</span></td>
<td><span style="color: #ff0000;">参见truncate</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">umask</span></td>
<td><span style="color: #ff0000;">设置文件权限掩码</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fsync</span></td>
<td><span style="color: #ff0000;">把文件在内存中的部分写回磁盘</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N10279"></a><strong>2、文件系统操作</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">access</span></td>
<td><span style="color: #ff0000;">确定文件的可存取性</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">chdir</span></td>
<td><span style="color: #ff0000;">改变当前工作目录</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fchdir</span></td>
<td><span style="color: #ff0000;">参见chdir</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">chmod</span></td>
<td><span style="color: #ff0000;">改变文件方式</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fchmod</span></td>
<td><span style="color: #ff0000;">参见chmod</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">chown</span></td>
<td><span style="color: #ff0000;">改变文件的属主或用户组</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fchown</span></td>
<td><span style="color: #ff0000;">参见chown</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">lchown</span></td>
<td><span style="color: #ff0000;">参见chown</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">chroot</span></td>
<td><span style="color: #ff0000;">改变根目录</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">stat</span></td>
<td><span style="color: #ff0000;">取文件状态信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">lstat</span></td>
<td><span style="color: #ff0000;">参见stat</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fstat</span></td>
<td><span style="color: #ff0000;">参见stat</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">statfs</span></td>
<td><span style="color: #ff0000;">取文件系统信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">fstatfs</span></td>
<td><span style="color: #ff0000;">参见statfs</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">readdir</span></td>
<td><span style="color: #ff0000;">读取目录项</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getdents</span></td>
<td><span style="color: #ff0000;">读取目录项</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mkdir</span></td>
<td><span style="color: #ff0000;">创建目录</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mknod</span></td>
<td><span style="color: #ff0000;">创建索引节点</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">rmdir</span></td>
<td><span style="color: #ff0000;">删除目录</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">rename</span></td>
<td><span style="color: #ff0000;">文件改名</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">link</span></td>
<td><span style="color: #ff0000;">创建链接</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">symlink</span></td>
<td><span style="color: #ff0000;">创建符号链接</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">unlink</span></td>
<td><span style="color: #ff0000;">删除链接</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">readlink</span></td>
<td><span style="color: #ff0000;">读符号链接的值</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mount</span></td>
<td><span style="color: #ff0000;">安装文件系统</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">umount</span></td>
<td><span style="color: #ff0000;">卸下文件系统</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">ustat</span></td>
<td><span style="color: #ff0000;">取文件系统信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">utime</span></td>
<td><span style="color: #ff0000;">改变文件的访问修改时间</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">utimes</span></td>
<td><span style="color: #ff0000;">参见utime</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">quotactl</span></td>
<td><span style="color: #ff0000;">控制磁盘配额</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="3"></a>三、系统控制</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">ioctl</span></td>
<td><span style="color: #ff0000;">I/O总控制函数</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">_sysctl</span></td>
<td><span style="color: #ff0000;">读/写系统参数</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">acct</span></td>
<td><span style="color: #ff0000;">启用或禁止进程记账</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getrlimit</span></td>
<td><span style="color: #ff0000;">获取系统资源上限</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setrlimit</span></td>
<td><span style="color: #ff0000;">设置系统资源上限</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getrusage</span></td>
<td><span style="color: #ff0000;">获取系统资源使用情况</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">uselib</span></td>
<td><span style="color: #ff0000;">选择要使用的二进制函数库</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">ioperm</span></td>
<td><span style="color: #ff0000;">设置端口I/O权限</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">iopl</span></td>
<td><span style="color: #ff0000;">改变进程I/O权限级别</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">outb</span></td>
<td><span style="color: #ff0000;">低级端口操作</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">reboot</span></td>
<td><span style="color: #ff0000;">重新启动</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">swapon</span></td>
<td><span style="color: #ff0000;">打开交换文件和设备</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">swapoff</span></td>
<td><span style="color: #ff0000;">关闭交换文件和设备</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">bdflush</span></td>
<td><span style="color: #ff0000;">控制bdflush守护进程</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sysfs</span></td>
<td><span style="color: #ff0000;">取核心支持的文件系统类型</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sysinfo</span></td>
<td><span style="color: #ff0000;">取得系统信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">adjtimex</span></td>
<td><span style="color: #ff0000;">调整系统时钟</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">alarm</span></td>
<td><span style="color: #ff0000;">设置进程的闹钟</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getitimer</span></td>
<td><span style="color: #ff0000;">获取计时器值</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setitimer</span></td>
<td><span style="color: #ff0000;">设置计时器值</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">gettimeofday</span></td>
<td><span style="color: #ff0000;">取时间和时区</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">settimeofday</span></td>
<td><span style="color: #ff0000;">设置时间和时区</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">stime</span></td>
<td><span style="color: #ff0000;">设置系统日期和时间</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">time</span></td>
<td><span style="color: #ff0000;">取得系统时间</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">times</span></td>
<td><span style="color: #ff0000;">取进程运行时间</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">uname</span></td>
<td><span style="color: #ff0000;">获取当前UNIX系统的名称、版本和主机等信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">vhangup</span></td>
<td><span style="color: #ff0000;">挂起当前终端</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">nfsservctl</span></td>
<td><span style="color: #ff0000;">对NFS守护进程进行控制</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">vm86</span></td>
<td><span style="color: #ff0000;">进入模拟8086模式</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">create_module</span></td>
<td><span style="color: #ff0000;">创建可装载的模块项</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">delete_module</span></td>
<td><span style="color: #ff0000;">删除可装载的模块项</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">init_module</span></td>
<td><span style="color: #ff0000;">初始化模块</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">query_module</span></td>
<td><span style="color: #ff0000;">查询模块信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*get_kernel_syms</span></td>
<td><span style="color: #ff0000;">取得核心符号,已被query_module代替</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="4"></a>四、内存管理</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">brk</span></td>
<td><span style="color: #ff0000;">改变数据段空间的分配</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sbrk</span></td>
<td><span style="color: #ff0000;">参见brk</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mlock</span></td>
<td><span style="color: #ff0000;">内存页面加锁</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">munlock</span></td>
<td><span style="color: #ff0000;">内存页面解锁</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mlockall</span></td>
<td><span style="color: #ff0000;">调用进程所有内存页面加锁</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">munlockall</span></td>
<td><span style="color: #ff0000;">调用进程所有内存页面解锁</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mmap</span></td>
<td><span style="color: #ff0000;">映射虚拟内存页</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">munmap</span></td>
<td><span style="color: #ff0000;">去除内存页映射</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mremap</span></td>
<td><span style="color: #ff0000;">重新映射虚拟内存地址</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">msync</span></td>
<td><span style="color: #ff0000;">将映射内存中的数据写回磁盘</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">mprotect</span></td>
<td><span style="color: #ff0000;">设置内存映像保护</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getpagesize</span></td>
<td><span style="color: #ff0000;">获取页面大小</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sync</span></td>
<td><span style="color: #ff0000;">将内存缓冲区数据写回硬盘</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">cacheflush</span></td>
<td><span style="color: #ff0000;">将指定缓冲区中的内容写回磁盘</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="5"></a>五、网络管理</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">getdomainname</span></td>
<td><span style="color: #ff0000;">取域名</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setdomainname</span></td>
<td><span style="color: #ff0000;">设置域名</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">gethostid</span></td>
<td><span style="color: #ff0000;">获取主机标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sethostid</span></td>
<td><span style="color: #ff0000;">设置主机标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">gethostname</span></td>
<td><span style="color: #ff0000;">获取本主机名称</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sethostname</span></td>
<td><span style="color: #ff0000;">设置主机名称</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="6"></a>六、socket控制</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">socketcall</span></td>
<td><span style="color: #ff0000;">socket系统调用</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">socket</span></td>
<td><span style="color: #ff0000;">建立socket</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">bind</span></td>
<td><span style="color: #ff0000;">绑定socket到端口</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">connect</span></td>
<td><span style="color: #ff0000;">连接远程主机</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">accept</span></td>
<td><span style="color: #ff0000;">响应socket连接请求</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">send</span></td>
<td><span style="color: #ff0000;">通过socket发送信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sendto</span></td>
<td><span style="color: #ff0000;">发送UDP信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sendmsg</span></td>
<td><span style="color: #ff0000;">参见send</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">recv</span></td>
<td><span style="color: #ff0000;">通过socket接收信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">recvfrom</span></td>
<td><span style="color: #ff0000;">接收UDP信息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">recvmsg</span></td>
<td><span style="color: #ff0000;">参见recv</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">listen</span></td>
<td><span style="color: #ff0000;">监听socket端口</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">select</span></td>
<td><span style="color: #ff0000;">对多路同步I/O进行轮询</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">shutdown</span></td>
<td><span style="color: #ff0000;">关闭socket上的连接</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getsockname</span></td>
<td><span style="color: #ff0000;">取得本地socket名字</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getpeername</span></td>
<td><span style="color: #ff0000;">获取通信对方的socket名字</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getsockopt</span></td>
<td><span style="color: #ff0000;">取端口设置</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setsockopt</span></td>
<td><span style="color: #ff0000;">设置端口参数</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sendfile</span></td>
<td><span style="color: #ff0000;">在文件或端口间传输数据</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">socketpair</span></td>
<td><span style="color: #ff0000;">创建一对已联接的无名socket</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="7"></a>七、用户管理</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">getuid</span></td>
<td><span style="color: #ff0000;">获取用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setuid</span></td>
<td><span style="color: #ff0000;">设置用户标志号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getgid</span></td>
<td><span style="color: #ff0000;">获取组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setgid</span></td>
<td><span style="color: #ff0000;">设置组标志号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getegid</span></td>
<td><span style="color: #ff0000;">获取有效组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setegid</span></td>
<td><span style="color: #ff0000;">设置有效组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">geteuid</span></td>
<td><span style="color: #ff0000;">获取有效用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">seteuid</span></td>
<td><span style="color: #ff0000;">设置有效用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setregid</span></td>
<td><span style="color: #ff0000;">分别设置真实和有效的的组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setreuid</span></td>
<td><span style="color: #ff0000;">分别设置真实和有效的用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getresgid</span></td>
<td><span style="color: #ff0000;">分别获取真实的,有效的和保存过的组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setresgid</span></td>
<td><span style="color: #ff0000;">分别设置真实的,有效的和保存过的组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getresuid</span></td>
<td><span style="color: #ff0000;">分别获取真实的,有效的和保存过的用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setresuid</span></td>
<td><span style="color: #ff0000;">分别设置真实的,有效的和保存过的用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setfsgid</span></td>
<td><span style="color: #ff0000;">设置文件系统检查时使用的组标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setfsuid</span></td>
<td><span style="color: #ff0000;">设置文件系统检查时使用的用户标识号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">getgroups</span></td>
<td><span style="color: #ff0000;">获取后补组标志清单</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">setgroups</span></td>
<td><span style="color: #ff0000;">设置后补组标志清单</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="8"></a>八、进程间通信</p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">ipc</span></td>
<td><span style="color: #ff0000;">进程间通信总控制调用</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N10759"></a><strong>1、信号</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">sigaction</span></td>
<td><span style="color: #ff0000;">设置对指定信号的处理方法</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sigprocmask</span></td>
<td><span style="color: #ff0000;">根据参数对信号集中的信号执行阻塞/解除阻塞等操作</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sigpending</span></td>
<td><span style="color: #ff0000;">为指定的被阻塞信号设置队列</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sigsuspend</span></td>
<td><span style="color: #ff0000;">挂起进程等待特定信号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">signal</span></td>
<td><span style="color: #ff0000;">参见signal</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">kill</span></td>
<td><span style="color: #ff0000;">向进程或进程组发信号</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*sigblock</span></td>
<td><span style="color: #ff0000;">向被阻塞信号掩码中添加信号,已被sigprocmask代替</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*siggetmask</span></td>
<td><span style="color: #ff0000;">取得现有阻塞信号掩码,已被sigprocmask代替</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*sigsetmask</span></td>
<td><span style="color: #ff0000;">用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*sigmask</span></td>
<td><span style="color: #ff0000;">将给定的信号转化为掩码,已被sigprocmask代替</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">*sigpause</span></td>
<td><span style="color: #ff0000;">作用同sigsuspend,已被sigsuspend代替</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">sigvec</span></td>
<td><span style="color: #ff0000;">为兼容BSD而设的信号处理函数,作用类似sigaction</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">ssetmask</span></td>
<td><span style="color: #ff0000;">ANSI C的信号处理函数,作用类似sigaction</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N107E3"></a><strong>2、消息</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">msgctl</span></td>
<td><span style="color: #ff0000;">消息控制操作</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">msgget</span></td>
<td><span style="color: #ff0000;">获取消息队列</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">msgsnd</span></td>
<td><span style="color: #ff0000;">发消息</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">msgrcv</span></td>
<td><span style="color: #ff0000;">取消息</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N1081C"></a><strong>3、管道</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">pipe</span></td>
<td><span style="color: #ff0000;">创建管道</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N1083A"></a><strong>4、信号量</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">semctl</span></td>
<td><span style="color: #ff0000;">信号量控制</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">semget</span></td>
<td><span style="color: #ff0000;">获取一组信号量</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">semop</span></td>
<td><span style="color: #ff0000;">信号量操作</span></td>


</tr>


</tbody>


</table>
<p><br /><a name="N1086A"></a><strong>5、共享内存</strong></p>
<table class="ibm-data-table" style="width: 100%;" border="1" cellspacing="0" cellpadding="5">
<tbody>
<tr>
<td width="30"><span style="color: #ffff00;">shmctl</span></td>
<td><span style="color: #ff0000;">控制共享内存</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">shmget</span></td>
<td><span style="color: #ff0000;">获取共享内存</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">shmat</span></td>
<td><span style="color: #ff0000;">连接共享内存</span></td>


</tr>
<tr>
<td><span style="color: #ffff00;">shmdt</span></td>
<td><span style="color: #ff0000;">拆卸共享内存</span></td>


</tr>


</tbody>


</table>
<p>&nbsp;</p>
<p><a name="resources"></a>参考资料</p>
<ul>
<ul>
<li>Linux man pages<br /><br /></li>
<li>Advanced Programming in the UNIX Environment, W. Richard Stevens, 1993</li>


</ul>

</ul>]]></description></item><item><title>设置Linux shell的输出效果［字体颜色，样式等］</title><link>http://www.cnblogs.com/isohybrid/archive/2012/12/14/shell_setting.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Fri, 14 Dec 2012 10:08:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/12/14/shell_setting.html</guid><description><![CDATA[<p><span><span><span style="font-size: large;">echo -e "\033[32;49;1m [DONE] \033[39;49;0m"</span><br /><span style="font-size: medium;">输出结果</span></span><span><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; ：</span></span></span><span><span><span style="font-size: medium;">[DONE]<br /></span></span></span></p>
<div><span><span style="font-size: medium;">＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃</span></span></div>
<div>文本终端的颜色可以使用&ldquo;ANSI非常规字符序列&rdquo;来生成。举例：</div>
<div align="left">　　echo -e "\033[44;37;5m ME \033[0m COOL"</div>
<div align="left">以上命令设置背景成为蓝色，前景白色，闪烁光标，输出字符&ldquo;ME&rdquo;，然后重新设置屏幕到缺省设置，输出字符 &ldquo;COOL&rdquo;。&ldquo;e&rdquo;是命令 echo 的一个可选项，它用于激活特殊字符的解析器。&ldquo;\033&rdquo;引导非常规字符序列。&ldquo;m&rdquo;意味着设置属性然后结束非常规字符序列，这个例子里真正有效的字符是 &ldquo;44;37;5&rdquo; 和&ldquo;0&rdquo;。</div>
<div align="left">修改&ldquo;44;37;5&rdquo;可以生成不同颜色的组合，数值和编码的前后顺序没有关系。可以选择的编码如下所示：</div>
<blockquote>
<div align="left"><span style="color: #ff0000;">编码&nbsp;&nbsp;&nbsp; 颜色/动作&nbsp;</span><br /><span style="color: #ff0000;">0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 重新设置属性到缺省设置&nbsp;</span><br /><span style="color: #ff0000;">1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置粗体&nbsp;</span><br /><span style="color: #ff0000;">2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置一半亮度（模拟彩色显示器的颜色）&nbsp;</span><br /><span style="color: #ff0000;">4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置下划线（模拟彩色显示器的颜色）&nbsp;</span><br /><span style="color: #ff0000;">5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置闪烁&nbsp;</span><br /><span style="color: #ff0000;">7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置反向图象&nbsp;</span><br /><span style="color: #ff0000;">22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置一般密度&nbsp;</span><br /><span style="color: #ff0000;">24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关闭下划线&nbsp;</span><br /><span style="color: #ff0000;">25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关闭闪烁&nbsp;</span><br /><span style="color: #ff0000;">27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关闭反向图象&nbsp;</span><br /><span style="color: #ff0000;">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置黑色前景&nbsp;</span><br /><span style="color: #ff0000;">31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置红色前景&nbsp;</span><br /><span style="color: #ff0000;">32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置绿色前景&nbsp;</span><br /><span style="color: #ff0000;">33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置棕色前景&nbsp;</span><br /><span style="color: #ff0000;">34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置蓝色前景&nbsp;</span><br /><span style="color: #ff0000;">35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置紫色前景&nbsp;</span><br /><span style="color: #ff0000;">36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置青色前景&nbsp;</span><br /><span style="color: #ff0000;">37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置白色前景&nbsp;</span><br /><span style="color: #ff0000;">38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在缺省的前景颜色上设置下划线&nbsp;</span><br /><span style="color: #ff0000;">39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在缺省的前景颜色上关闭下划线&nbsp;</span><br /><span style="color: #ff0000;">40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置黑色背景&nbsp;</span><br /><span style="color: #ff0000;">41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置红色背景&nbsp;</span><br /><span style="color: #ff0000;">42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置绿色背景&nbsp;</span><br /><span style="color: #ff0000;">43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置棕色背景&nbsp;</span><br /><span style="color: #ff0000;">44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置蓝色背景&nbsp;</span><br /><span style="color: #ff0000;">45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置紫色背景&nbsp;</span><br /><span style="color: #ff0000;">46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置青色背景&nbsp;</span><br /><span style="color: #ff0000;">47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置白色背景&nbsp;</span><br /><span style="color: #ff0000;">49&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设置缺省黑色背景</span></div>
<div>&nbsp;</div>


</blockquote>
<div align="left">其他有趣的代码还有：</div>
<div align="left">\033[2J&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　清除屏幕&nbsp;<br />\033[0q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　关闭所有的键盘指示灯&nbsp;<br />\033[1q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　设置&ldquo;滚动锁定&rdquo;指示灯 (Scroll Lock)&nbsp;<br />\033[2q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　设置&ldquo;数值锁定&rdquo;指示灯 (Num Lock)&nbsp;<br />\033[3q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　设置&ldquo;大写锁定&rdquo;指示灯 (Caps Lock)&nbsp;<br />\033[15:40H&nbsp;&nbsp;&nbsp;&nbsp; 把关闭移动到第15行，40列&nbsp;<br />\007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 　　发蜂鸣生beep</div>
<div><span>＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃<br /></span></div>
<div>RedHat的字体和背景颜色的改变方法：</div>
<div>命令：<br />PS1="[\e[32;1m\u@\h \W]\\$"&nbsp;<br />或&nbsp;<br />export PS1="[\e[32;1m\u@\h \W]\\$" 两者的区别请查看环境变量的相关资料</div>
<div>解释：</div>
<div>\e[32;1m：这就是控制字体和背景颜色的转义字符，30~37是字体颜色、40~47是背景颜色</div>
<div>例子中的32;1m数字的位置是可以对调的如\e[1;32m，如果是在X环境下可以更换一下1的范围0~10，可能有的没用处：0或者不写（\e [0;32m或\e[;32m）显示浅颜色，1：显示高亮 4：加下划线.....如果改后的效果不好，但是又还原不了，那就不写m前面的数字，如\e[32;m，或者直接注销再登陆</div>
<div>\u \h \W：这是一些转义字符，下面详细解释：</div>
<div>\d ：代表日期，格式为weekday month date，例如："Mon Aug 1"</div>
<div>\H ：完整的主机名称。例如：我的机器名称为：fc4.linux，则这个名称就是fc4.linux</div>
<div>\h ：仅取主机的第一个名字，如上例，则为fc4，.linux则被省略</div>
<div>\t ：显示时间为24小时格式，如：HH：MM：SS</div>
<div>\T ：显示时间为12小时格式</div>
<div>\A ：显示时间为24小时格式：HH：MM</div>
<div>\u ：当前用户的账号名称</div>
<div>\v ：BASH的版本信息</div>
<div>\w ：完整的工作目录名称。家目录会以 ~代替</div>
<div>\W ：利用basename取得工作目录名称，所以只会列出最后一个目录</div>
<div>\# ：下达的第几个命令</div>
<div>\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$</div>
<div>\n ：新建一行</div>
<div>字体并不局限于一个颜色，可以有多个颜色：<br />PS1="[\e[32;1m\u@\e[35;1m\h \e[31;1m\W]\\$"</div>
<div>以上两个命令在注销后再登陆就失效了，用下面方法使其永久生效：<br />vi /etc/profile&nbsp;<br />在&ldquo;export PATH .....&rdquo;下面添加一行：export PS1="[\e[32;1m\u@\h \W]\\$"<br />注销再登陆，就成功了，如果没生效，使用source /etc/profile 命令试试，或者直接重启机器。</div>]]></description></item><item><title>MYSQL常用命令</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/19/mysql.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Mon, 19 Nov 2012 04:01:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/19/mysql.html</guid><description><![CDATA[<p>1.导出整个数据库<br />mysqldump -u 用户名 -p --default-character-set=latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1)<br />mysqldump -u wcnc -p smgp_apps_wcnc &gt; wcnc.sql<br />2.导出一个表<br />mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名<br />mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql<br />3.导出一个数据库结构<br />mysqldump -u wcnc -p -d &ndash;add-drop-table smgp_apps_wcnc &gt;d:wcnc_db.sql<br />-d 没有数据 &ndash;add-drop-table 在每个create语句之前增加一个drop table<br />4.导入数据库<br />A:常用source 命令<br />进入mysql数据库控制台，<br />如mysql -u root -p<br />mysql&gt;use 数据库<br />然后使用source命令，后面参数为脚本文件(如这里用到的.sql)<br />mysql&gt;source wcnc_db.sql</p>
<p>B:使用mysqldump命令</p>
<p>mysqldump -u username -p dbname &lt; filename.sql</p>
<p>C:使用mysql命令</p>
<p>mysql -u username -p -D dbname &lt; filename.sql</p>
<p>一、启动与退出<br />1、进入MySQL：启动MySQL Command Line Client（MySQL的DOS界面），直接输入安装时的密码即可。此时的提示符是：mysql&gt;<br />2、退出MySQL：quit或exit<br />二、库操作<br />1、、创建数据库<br />命令：create database &lt;数据库名&gt;<br />例如：建立一个名为xhkdb的数据库<br />mysql&gt; create database xhkdb;&nbsp;<br />2、显示所有的数据库<br />命令：show databases （注意：最后有个s）<br />mysql&gt; show databases;<br />3、删除数据库<br />命令：drop database &lt;数据库名&gt;<br />例如：删除名为 xhkdb的数据库<br />mysql&gt; drop database xhkdb;<br />4、连接数据库<br />命令： use &lt;数据库名&gt;<br />例如：如果xhkdb数据库存在，尝试存取它：<br />mysql&gt; use xhkdb;<br />屏幕提示：Database changed<br />5、查看当前使用的数据库<br />mysql&gt; select database();</p>
<p>6、当前数据库包含的表信息：<br />mysql&gt; show tables; （注意：最后有个s）</p>
<p>三、表操作，操作之前应连接某个数据库<br />1、建表<br />命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]);</p>
<p>mysql&gt; create table MyClass(<br />&gt; id int(4) not null primary key auto_increment,<br />&gt; name char(20) not null,<br />&gt; sex int(4) not null default '0',<br />&gt; degree double(16,2));<br />2、获取表结构<br />命令： desc 表名，或者show columns from 表名<br />mysql&gt;DESCRIBE MyClass<br />mysql&gt; desc MyClass;&nbsp;<br />mysql&gt; show columns from MyClass;<br />3、删除表<br />命令：drop table &lt;表名&gt;<br />例如：删除表名为 MyClass 的表<br />mysql&gt; drop table MyClass;<br />4、插入数据<br />命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )]<br />例如，往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99，编号为3 的名为Wang 的成绩为96.5.<br />mysql&gt; insert into MyClass values(1,'Tom',96.45),(2,'Joan',82.99), (2,'Wang', 96.59);<br />5、查询表中的数据<br />1)、查询所有行<br />命令： select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;<br />例如：查看表 MyClass 中所有数据<br />mysql&gt; select * from MyClass;<br />2）、查询前几行数据<br />例如：查看表 MyClass 中前2行数据<br />mysql&gt; select * from MyClass order by id limit 0,2;</p>
<p>或者：</p>
<p>mysql&gt; select * from MyClass limit 0,2;<br />6、删除表中数据<br />命令：delete from 表名 where 表达式<br />例如：删除表 MyClass中编号为1 的记录<br />mysql&gt; delete from MyClass where id=1;<br />7、修改表中数据：update 表名 set 字段=新值,&hellip; where 条件<br />mysql&gt; update MyClass set name='Mary' where id=1;<br />7、在表中增加字段：</p>
<p>命令：alter table 表名 add字段 类型 其他;&nbsp;<br />例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0&nbsp;<br />mysql&gt; alter table MyClass add passtest int(4) default '0'<br />8、更改表名：<br />命令：rename table 原表名 to 新表名;&nbsp;<br />例如：在表MyClass名字更改为YouClass&nbsp;<br />mysql&gt; rename table MyClass to YouClass;</p>
<p>更新字段内容<br />update 表名 set 字段名 = 新内容<br />update 表名 set 字段名 = replace(字段名,'旧内容','新内容');</p>
<p>文章前面加入4个空格<br />update article set content=concat('　　',content);</p>
<p>字段类型<br />1．INT[(M)] 型： 正常大小整数类型&nbsp;<br />2．DOUBLE[(M,D)] [ZEROFILL] 型： 正常大小(双精密)浮点数字类型&nbsp;<br />3．DATE 日期类型：支持的范围是1000-01-01到9999-12-31。MySQL以YYYY-MM-DD格式来显示DATE值，但是允许你使用字符串或数字把值赋给DATE列&nbsp;<br />4．CHAR(M) 型：定长字符串类型，当存储时，总是是用空格填满右边到指定的长度&nbsp;<br />5．BLOB TEXT类型，最大长度为65535(2^16-1)个字符。&nbsp;<br />6．VARCHAR型：变长字符串类型</p>
<p>5.导入数据库表&nbsp;<br />　　 （1）创建.sql文件&nbsp;<br />　　 （2）先产生一个库如auction.c:mysqlbin&gt;mysqladmin -u root -p creat auction，会提示输入密码，然后成功创建。&nbsp;<br />　　 （2）导入auction.sql文件&nbsp;<br />　　 c:mysqlbin&gt;mysql -u root -p auction &lt; auction.sql。&nbsp;<br />　　 通过以上操作，就可以创建了一个数据库auction以及其中的一个表auction。&nbsp;<br />　　 6．修改数据库<br />　　 （1）在mysql的表中增加字段：&nbsp;<br />　　 alter table dbname add column userid int(11) not null primary key auto_increment;<br />　　 这样，就在表dbname中添加了一个字段userid，类型为int(11)。&nbsp;<br />　　 7．mysql数据库的授权<br />　　 mysql&gt;grant select,insert,delete,create,drop&nbsp;<br />　　 on *.* (或test.*/user.*/..)&nbsp;<br />　　 to 用户名@localhost&nbsp;<br />　　 identified by '密码'；&nbsp;<br />　　 如：新建一个用户帐号以便可以访问数据库，需要进行如下操作：&nbsp;<br />　　 mysql&gt; grant usage&nbsp;<br />　　 -&gt; ON test.*&nbsp;<br />　　 -&gt; TO&nbsp;<a href="mailto:testuser@localhost">testuser@localhost</a>;&nbsp;<br />　　 Query OK, 0 rows affected (0.15 sec)&nbsp;<br />　　 此后就创建了一个新用户叫：testuser，这个用户只能从localhost连接到数据库并可以连接到test 数据库。下一步，我们必须指定testuser这个用户可以执行哪些操作：&nbsp;<br />　　 mysql&gt; GRANT select, insert, delete,update&nbsp;<br />　　 -&gt; ON test.*&nbsp;<br />　　 -&gt; TO&nbsp;<a href="mailto:testuser@localhost">testuser@localhost</a>;&nbsp;<br />　　 Query OK, 0 rows affected (0.00 sec)&nbsp;<br />　　 此操作使testuser能够在每一个test数据库中的表执行SELECT，INSERT和DELETE以及UPDATE查询操作。现在我们结束操作并退出MySQL客户程序：&nbsp;<br />　　 mysql&gt; exit&nbsp;<br />　　 Bye9!</p>
<p>1:使用SHOW语句找出在服务器上当前存在什么数据库：<br />mysql&gt; SHOW DATABASES;<br />2:2、创建一个数据库MYSQLDATA<br />mysql&gt; Create DATABASE MYSQLDATA;<br />3:选择你所创建的数据库<br />mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！)<br />4:查看现在的数据库中存在什么表<br />mysql&gt; SHOW TABLES;<br />5:创建一个数据库表<br />mysql&gt; Create TABLE MYTABLE (name VARCHAR(20), sex CHAR(1));<br />6:显示表的结构：<br />mysql&gt; DESCRIBE MYTABLE;<br />7:往表中加入记录<br />mysql&gt; insert into MYTABLE values ("hyq","M");<br />8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）<br />mysql&gt; LOAD DATA LOCAL INFILE "D:/mysql.txt" INTO TABLE MYTABLE;<br />9:导入.sql文件命令（例如D:/mysql.sql）<br />mysql&gt;use database;<br />mysql&gt;source d:/mysql.sql;<br />10:删除表<br />mysql&gt;drop TABLE MYTABLE;<br />11:清空表<br />mysql&gt;delete from MYTABLE;<br />12:更新表中数据<br />mysql&gt;update MYTABLE set sex="f" where name='hyq';</p>
<p>以下是无意中在网络看到的使用MySql的管理心得,<br />摘自:http://www1.xjtusky.com/article/htmldata/2004_12/3/57/article_1060_1.html</p>
<p>在windows中MySql以服务形式存在，在使用前应确保此服务已经启动，未启动可用net start mysql命令启动。而Linux中启动时可用&ldquo;/etc/rc.d/init.d/mysqld start"命令，注意启动者应具有管理员权限。<br />刚安装好的MySql包含一个含空密码的root帐户和一个匿名帐户，这是很大的安全隐患，对于一些重要的应用我们应将安全性尽可能提高，在这里应把匿名帐户删除、 root帐户设置密码，可用如下命令进行：<br />use mysql;<br />delete from User where User="";<br />update User set Password=PASSWORD('newpassword') where User='root';<br />如果要对用户所用的登录终端进行限制，可以更新User表中相应用户的Host字段，在进行了以上更改后应重新启动数据库服务，此时登录时可用如下类似命令：<br />mysql -uroot -p;<br />mysql -uroot -pnewpassword;<br />mysql mydb -uroot -p;<br />mysql mydb -uroot -pnewpassword;<br />上面命令参数是常用参数的一部分，详细情况可参考文档。此处的mydb是要登录的数据库的名称。<br />在进行开发和实际应用中，用户不应该只用root用户进行连接数据库，虽然使用root用户进行测试时很方便，但会给系统带来重大安全隐患，也不利于管理技术的提高。我们给一个应用中使用的用户赋予最恰当的数据库权限。如一个只进行数据插入的用户不应赋予其删除数据的权限。MySql的用户管理是通过 User表来实现的，添加新用户常用的方法有两个，一是在User表插入相应的数据行，同时设置相应的权限；二是通过GRANT命令创建具有某种权限的用户。其中GRANT的常用用法如下：<br />grant all on mydb.* to&nbsp;<a href="mailto:NewUserName@HostName">NewUserName@HostName</a>&nbsp;identified by "password" ;<br />grant usage on *.* to&nbsp;<a href="mailto:NewUserName@HostName">NewUserName@HostName</a>&nbsp;identified by "password";<br />grant select,insert,update on mydb.* to&nbsp;<a href="mailto:NewUserName@HostName">NewUserName@HostName</a>&nbsp;identified by "password";<br />grant update,delete on mydb.TestTable to&nbsp;<a href="mailto:NewUserName@HostName">NewUserName@HostName</a>&nbsp;identified by "password";<br />若要给此用户赋予他在相应对象上的权限的管理能力，可在GRANT后面添加WITH GRANT OPTION选项。而对于用插入User表添加的用户，Password字段应用PASSWORD 函数进行更新加密，以防不轨之人窃看密码。对于那些已经不用的用户应给予清除，权限过界的用户应及时回收权限，回收权限可以通过更新User表相应字段，也可以使用REVOKE操作。<br />下面给出本人从其它资料(<a href="http://www.cn-java.com/">www.cn-java.com</a>)获得的对常用权限的解释：<br />全局管理权限：<br />FILE: 在MySQL服务器上读写文件。<br />PROCESS: 显示或杀死属于其它用户的服务线程。<br />RELOAD: 重载访问控制表，刷新日志等。<br />SHUTDOWN: 关闭MySQL服务。<br />数据库/数据表/数据列权限：<br />Alter: 修改已存在的数据表(例如增加/删除列)和索引。<br />Create: 建立新的数据库或数据表。<br />Delete: 删除表的记录。<br />Drop: 删除数据表或数据库。<br />INDEX: 建立或删除索引。<br />Insert: 增加表的记录。<br />Select: 显示/搜索表的记录。<br />Update: 修改表中已存在的记录。<br />特别的权限：<br />ALL: 允许做任何事(和root一样)。<br />USAGE: 只允许登录--其它什么也不允许做。</p>
<p>---------------------<br />MYSQL常用命令<br />有很多朋友虽然安装好了mysql但却不知如何使用它。在这篇文章中我们就从连接MYSQL、修改密码、增加用户等方面来学习一些MYSQL的常用命令。<br />　　有很多朋友虽然安装好了mysql但却不知如何使用它。在这篇文章中我们就从连接MYSQL、修改密码、增加用户等方面来学习一些MYSQL的常用命令。 　</p>
<p>　　一、连接MYSQL　</p>
<p>　　格式： mysql -h主机地址 -u用户名 －p用户密码 　　</p>
<p>　　1、例1：连接到本机上的MYSQL</p>
<p>　　首先在打开DOS窗口，然后进入目录 mysqlbin，再键入命令mysql -uroot -p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是：mysql&gt; 　　</p>
<p>　　2、例2：连接到远程主机上的MYSQL</p>
<p>　　假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： 　　　</p>
<p>　　mysql -h110.110.110.110 -uroot -pabcd123 　　</p>
<p>　　（注:u与root可以不用加空格，其它也一样） 　　</p>
<p>　　3、退出MYSQL命令： exit （回车）</p>
<p>　　二、修改密码　　</p>
<p>　　格式：mysqladmin -u用户名 -p旧密码 password 新密码 　</p>
<p>　　1、例1：给root加个密码ab12。首先在DOS下进入目录mysqlbin，然后键入以下命令 　　</p>
<p>　　mysqladmin -uroot -password ab12 　　</p>
<p>　　注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 　　</p>
<p>　　2、例2：再将root的密码改为djg345</p>
<p>　　mysqladmin -uroot -pab12 password djg345</p>
<p>MYSQL常用命令（下）<br />　　一、操作技巧</p>
<p>　　1、如果你打命令时，回车后发现忘记加分号，你无须重打一遍命令，只要打个分号回车就可以了。也就是说你可以把一个完整的命令分成几行来打，完后用分号作结束标志就OK。</p>
<p>　　2、你可以使用光标上下键调出以前的命令。但以前我用过的一个MYSQL旧版本不支持。我现在用的是mysql-3.23.27-beta-win。</p>
<p>　　二、显示命令</p>
<p>　　1、显示数据库列表。</p>
<p>　　show databases;</p>
<p>　　刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p>
<p>　　2、显示库中的数据表：</p>
<p>　　use mysql； ／／打开库，学过FOXBASE的一定不会陌生吧</p>
<p>　　show tables;</p>
<p>　　3、显示数据表的结构：</p>
<p>　　describe 表名;</p>
<p>　　4、建库：</p>
<p>　　create database 库名;</p>
<p>　　5、建表：</p>
<p>　　use 库名；</p>
<p>　　create table 表名 (字段设定列表)；</p>
<p>　　6、删库和删表:</p>
<p>　　drop database 库名;</p>
<p>　　drop table 表名；</p>
<p>　　7、将表中记录清空：</p>
<p>　　delete from 表名;</p>
<p>　　8、显示表中的记录：</p>
<p>　　select * from 表名;</p>
<p>三、一个建库和建表以及插入数据的实例</p>
<p>　　drop database if exists school; //如果存在SCHOOL则删除<br />　　create database school; //建立库SCHOOL<br />　　use school; //打开库SCHOOL<br />　　create table teacher //建立表TEACHER<br />　　(<br />　　id int(3) auto_increment not null primary key,<br />　　name char(10) not null,<br />　　address varchar(50) default '深圳',<br />　　year date<br />　　); //建表结束<br />　　//以下为插入字段<br />　　insert into teacher values('','glchengang','深圳一中','1976-10-10');<br />　　insert into teacher values('','jack','深圳一中','1975-12-23');</p>
<p>　　注：在建表中（1）将ID设为长度为3的数字字段:int(3)并让它每个记录自动加一:auto_increment并不能为空:not null而且让他成为主字段primary key<br />　　（2）将NAME设为长度为10的字符字段<br />　　（3）将ADDRESS设为长度50的字符字段，而且缺省值为深圳。varchar和char有什么区别呢，只有等以后的文章再说了。<br />　　（4）将YEAR设为日期字段。</p>
<p>　　如果你在mysql提示符键入上面的命令也可以，但不方便调试。你可以将以上命令原样写入一个文本文件中假设为school.sql，然后复制到c:\下，并在DOS状态进入目录\mysql\bin，然后键入以下命令：<br />　　mysql -uroot -p密码 &lt; c:\school.sql<br />　　如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。</p>
<p>四、将文本数据转到数据库中</p>
<p>　　1、文本数据应符合的格式：字段数据之间用tab键隔开，null值用\n来代替.<br />　　例：<br />　　3 rose 深圳二中 1976-10-10<br />　　4 mike 深圳一中 1975-12-23</p>
<p>　　2、数据传入命令 load data local infile "文件名" into table 表名;<br />　　注意：你最好将文件复制到\mysql\bin目录下，并且要先用use命令打表所在的库 。</p>
<p>五、备份数据库：（命令在DOS的\mysql\bin目录下执行）</p>
<p>　　mysqldump --opt school&gt;school.bbb<br />　　注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。</p>
<p>一.SELECT语句的完整语法为：&nbsp;<br />SELECT[ALL|DISTINCT|DISTINCTROW|TOP]&nbsp;<br />{*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,&hellip;]]}&nbsp;<br />FROM tableexpression[,&hellip;][IN externaldatabase]&nbsp;<br />[WHERE&hellip;]&nbsp;<br />[GROUP BY&hellip;]&nbsp;<br />[HAVING&hellip;]&nbsp;<br />[ORDER BY&hellip;]&nbsp;<br />[WITH OWNERACCESS OPTION]&nbsp;<br />说明：&nbsp;<br />用中括号([])括起来的部分表示是可选的，用大括号({})括起来的部分是表示必须从中选择其中的一个。&nbsp;<br />1 FROM子句&nbsp;<br />FROM 子句指定了SELECT语句中字段的来源。FROM子句后面是包含一个或多个的表达式(由逗号分开)，其中的表达式可为单一表名称、已保存的查询或由 INNER JOIN、LEFT JOIN 或 RIGHT JOIN 得到的复合结果。如果表或查询存储在外部数据库，在IN 子句之后指明其完整路径。&nbsp;<br />例：下列SQL语句返回所有有定单的客户：&nbsp;<br />SELECT OrderID,Customer.customerID&nbsp;<br />FROM Orders Customers&nbsp;<br />WHERE Orders.CustomerID=Customers.CustomeersID</p>
<p>2 ALL、DISTINCT、DISTINCTROW、TOP谓词&nbsp;<br />(1) ALL 返回满足SQL语句条件的所有记录。如果没有指明这个谓词，默认为ALL。&nbsp;<br />例：SELECT ALL FirstName,LastName&nbsp;<br />FROM Employees&nbsp;<br />(2) DISTINCT 如果有多个记录的选择字段的数据相同，只返回一个。&nbsp;<br />(3) DISTINCTROW 如果有重复的记录，只返回一个&nbsp;<br />(4) TOP显示查询头尾若干记录。也可返回记录的百分比，这是要用 TOP N PERCENT子句（其中N 表示百分比）&nbsp;<br />例：返回5%定货额最大的定单&nbsp;<br />SELECT TOP 5 PERCENT*&nbsp;<br />FROM [ Order Details]&nbsp;<br />ORDER BY UnitPrice*Quantity*(1-Discount) DESC</p>
<p>3 用 AS 子句为字段取别名&nbsp;<br />如果想为返回的列取一个新的标题，或者，经过对字段的计算或总结之后，产生了一个新的值，希望把它放到一个新的列里显示，则用AS保留。&nbsp;<br />例：返回FirstName字段取别名为NickName&nbsp;<br />SELECT FirstName AS NickName ,LastName ,City&nbsp;<br />FROM Employees&nbsp;<br />例：返回新的一列显示库存价值&nbsp;<br />SELECT ProductName ,UnitPrice ,UnitsInStock ,UnitPrice*UnitsInStock AS valueInStock&nbsp;<br />FROM Products</p>
<p>二 .WHERE 子句指定查询条件</p>
<p>1 比较运算符&nbsp;<br />比较运算符 含义&nbsp;<br />= 等于&nbsp;<br />&gt; 大于&nbsp;<br />&lt; 小于&nbsp;<br />&gt;= 大于等于&nbsp;<br />&lt;= 小于等于&nbsp;<br />&lt;&gt; 不等于&nbsp;<br />!&gt; 不大于&nbsp;<br />!&lt; 不小于&nbsp;<br />例：返回96年1月的定单&nbsp;<br />SELECT OrderID, CustomerID, OrderDate&nbsp;<br />FROM Orders&nbsp;<br />WHERE OrderDate&gt;#1/1/96# AND OrderDate&lt;#1/30/96#&nbsp;<br />注意：&nbsp;<br />Mcirosoft JET SQL 中，日期用&lsquo;#&rsquo;定界。日期也可以用Datevalue()函数来代替。在比较字符型的数据时，要加上单引号&rsquo;&rsquo;，尾空格在比较中被忽略。&nbsp;<br />例：&nbsp;<br />WHERE OrderDate&gt;#96-1-1#&nbsp;<br />也可以表示为：&nbsp;<br />WHERE OrderDate&gt;Datevalue(&lsquo;1/1/96&rsquo;)&nbsp;<br />使用 NOT 表达式求反。&nbsp;<br />例：查看96年1月1日以后的定单&nbsp;<br />WHERE Not OrderDate&lt;=#1/1/96#&nbsp;<br />2 范围（BETWEEN 和 NOT BETWEEN）&nbsp;<br />BETWEEN &hellip;AND&hellip;运算符指定了要搜索的一个闭区间。&nbsp;<br />例：返回96年1月到96年2月的定单。&nbsp;<br />WHERE OrderDate Between #1/1/96# And #2/1/96#&nbsp;<br />3 列表（IN ，NOT IN）&nbsp;<br />IN 运算符用来匹配列表中的任何一个值。IN子句可以代替用OR子句连接的一连串的条件。&nbsp;<br />例：要找出住在 London、Paris或Berlin的所有客户&nbsp;<br />SELECT CustomerID, CompanyName, ContactName, City&nbsp;<br />FROM Customers&nbsp;<br />WHERE City In(&lsquo;London&rsquo;,&rsquo; Paris&rsquo;,&rsquo; Berlin&rsquo;)&nbsp;<br />4 模式匹配(LIKE)&nbsp;<br />LIKE运算符检验一个包含字符串数据的字段值是否匹配一指定模式。&nbsp;<br />LIKE运算符里使用的通配符&nbsp;<br />通配符 含义&nbsp;<br />？ 任何一个单一的字符&nbsp;<br />* 任意长度的字符&nbsp;<br /># 0~9之间的单一数字&nbsp;<br />[字符列表] 在字符列表里的任一值&nbsp;<br />[！字符列表] 不在字符列表里的任一值&nbsp;<br />- 指定字符范围，两边的值分别为其上下限&nbsp;<br />例：返回邮政编码在（171）555-0000到（171）555-9999之间的客户&nbsp;<br />SELECT CustomerID ,CompanyName,City,Phone&nbsp;<br />FROM Customers&nbsp;<br />WHERE Phone Like &lsquo;(171)555-####&rsquo;&nbsp;<br />LIKE运算符的一些样式及含义&nbsp;<br />样式 含义 不符合&nbsp;<br />LIKE &lsquo;A*&rsquo; A后跟任意长度的字符 Bc,c255&nbsp;<br />LIKE&rsquo;5[*]&rsquo; 5*5 555&nbsp;<br />LIKE&rsquo;5?5&rsquo; 5与5之间有任意一个字符 55,5wer5&nbsp;<br />LIKE&rsquo;5##5&rsquo; 5235，5005 5kd5,5346&nbsp;<br />LIKE&rsquo;[a-z]&rsquo; a-z间的任意一个字符 5,%&nbsp;<br />LIKE&rsquo;[!0-9]&rsquo; 非0-9间的任意一个字符 0,1&nbsp;<br />LIKE&rsquo;[[]&rsquo; 1,*&nbsp;<br />三 .用ORDER BY子句排序结果&nbsp;<br />ORDER子句按一个或多个（最多16个）字段排序查询结果，可以是升序（ASC）也可以是降序（DESC），缺省是升序。ORDER子句通常放在SQL语句的最后。&nbsp;<br />ORDER子句中定义了多个字段，则按照字段的先后顺序排序。&nbsp;<br />例：&nbsp;<br />SELECT ProductName,UnitPrice, UnitInStock&nbsp;<br />FROM Products&nbsp;<br />ORDER BY UnitInStock DESC , UnitPrice DESC, ProductName&nbsp;<br />ORDER BY 子句中可以用字段在选择列表中的位置号代替字段名，可以混合字段名和位置号。&nbsp;<br />例：下面的语句产生与上列相同的效果。&nbsp;<br />SELECT ProductName,UnitPrice, UnitInStock&nbsp;<br />FROM Products&nbsp;<br />ORDER BY 1 DESC , 2 DESC,3&nbsp;<br />四 .运用连接关系实现多表查询&nbsp;<br />例：找出同一个城市中供应商和客户的名字&nbsp;<br />SELECT Customers.CompanyName, Suppliers.ComPany.Name&nbsp;<br />FROM Customers, Suppliers&nbsp;<br />WHERE Customers.City=Suppliers.City&nbsp;<br />例：找出产品库存量大于同一种产品的定单的数量的产品和定单&nbsp;<br />SELECT ProductName,OrderID, UnitInStock, Quantity&nbsp;<br />FROM Products, [Order Deails]&nbsp;<br />WHERE Product.productID=[Order Details].ProductID&nbsp;<br />AND UnitsInStock&gt;Quantity&nbsp;<br />另一种方法是用 Microsof JET SQL 独有的 JNNER JOIN&nbsp;<br />语法：&nbsp;<br />FROM table1 INNER JOIN table2&nbsp;<br />ON table1.field1 comparision table2.field2&nbsp;<br />其中comparision 就是前面WHERE子句用到的比较运算符。&nbsp;<br />SELECT FirstName,lastName,OrderID,CustomerID,OrderDate&nbsp;<br />FROM Employees&nbsp;<br />INNER JOIN Orders ON Employees.EmployeeID=Orders.EmployeeID&nbsp;<br />注意：&nbsp;<br />INNER JOIN不能连接Memo OLE Object Single Double 数据类型字段。&nbsp;<br />在一个JOIN语句中连接多个ON子句&nbsp;<br />语法：&nbsp;<br />SELECT fields&nbsp;<br />FROM table1 INNER JOIN table2&nbsp;<br />ON table1.field1 compopr table2.field1 AND&nbsp;<br />ON table1.field2 compopr table2.field2 OR&nbsp;<br />ON table1.field3 compopr table2.field3&nbsp;<br />也可以&nbsp;<br />SELECT fields&nbsp;<br />FROM table1 INNER JOIN&nbsp;<br />（table2 INNER JOIN [( ]table3&nbsp;<br />[INNER JOER] [( ]tablex[INNER JOIN]&nbsp;<br />ON table1.field1 compopr table2.field1&nbsp;<br />ON table1.field2 compopr table2.field2&nbsp;<br />ON table1.field3 compopr table2.field3&nbsp;<br />外部连接返回更多记录，在结果中保留不匹配的记录，不管存不存在满足条件的记录都要返回另一侧的所有记录。&nbsp;<br />FROM table [LEFT|RIGHT]JOIN table2&nbsp;<br />ON table1.field1comparision table.field2&nbsp;<br />用左连接来建立外部连接，在表达式的左边的表会显示其所有的数据&nbsp;<br />例：不管有没有定货量，返回所有商品&nbsp;<br />SELECT ProductName ,OrderID&nbsp;<br />FROM Products&nbsp;<br />LEFT JOIN Orders ON Products.PrductsID=Orders.ProductID&nbsp;<br />右连接与左连接的差别在于：不管左侧表里有没有匹配的记录，它都从左侧表中返回所有记录。&nbsp;<br />例：如果想了解客户的信息，并统计各个地区的客户分布，这时可以用一个右连接，即使某个地区没有客户，也要返回客户信息。&nbsp;<br />空值不会相互匹配，可以通过外连接才能测试被连接的某个表的字段是否有空值。&nbsp;<br />SELECT *&nbsp;<br />FROM talbe1&nbsp;<br />LEFT JOIN table2 ON table1.a=table2.c&nbsp;<br />1 连接查询中使用Iif函数实现以0值显示空值&nbsp;<br />Iif表达式： Iif(IsNull(Amount,0,Amout)&nbsp;<br />例：无论定货大于或小于￥50，都要返回一个标志。&nbsp;<br />Iif([Amount]&gt;50,?Big order?,?Small order?)&nbsp;<br />五. 分组和总结查询结果&nbsp;<br />在SQL的语法里，GROUP BY和HAVING子句用来对数据进行汇总。GROUP BY子句指明了按照哪几个字段来分组，而将记录分组后，用HAVING子句过滤这些记录。&nbsp;<br />GROUP BY 子句的语法&nbsp;<br />SELECT fidldlist&nbsp;<br />FROM table&nbsp;<br />WHERE criteria&nbsp;<br />[GROUP BY groupfieldlist [HAVING groupcriteria]]&nbsp;<br />注：Microsoft Jet数据库 Jet 不能对备注或OLE对象字段分组。&nbsp;<br />GROUP BY字段中的Null值以备分组但是不能被省略。&nbsp;<br />在任何SQL合计函数中不计算Null值。&nbsp;<br />GROUP BY子句后最多可以带有十个字段，排序优先级按从左到右的顺序排列。&nbsp;<br />例：在&lsquo;WA&rsquo;地区的雇员表中按头衔分组后，找出具有同等头衔的雇员数目大于1人的所有头衔。&nbsp;<br />SELECT Title ,Count(Title) as Total&nbsp;<br />FROM Employees&nbsp;<br />WHERE Region = &lsquo;WA&rsquo;&nbsp;<br />GROUP BY Title&nbsp;<br />HAVING Count(Title)&gt;1&nbsp;<br />JET SQL 中的聚积函数&nbsp;<br />聚集函数 意义&nbsp;<br />SUM ( ) 求和&nbsp;<br />AVG ( ) 平均值&nbsp;<br />COUNT ( ) 表达式中记录的数目&nbsp;<br />COUNT (* ) 计算记录的数目&nbsp;<br />MAX 最大值&nbsp;<br />MIN 最小值&nbsp;<br />VAR 方差&nbsp;<br />STDEV 标准误差&nbsp;<br />FIRST 第一个值&nbsp;<br />LAST 最后一个值&nbsp;<br />六. 用Parameters声明创建参数查询&nbsp;<br />Parameters声明的语法:&nbsp;<br />PARAMETERS name datatype[,name datatype[, &hellip;]]&nbsp;<br />其中name 是参数的标志符,可以通过标志符引用参数.&nbsp;<br />Datatype说明参数的数据类型.&nbsp;<br />使用时要把PARAMETERS 声明置于任何其他语句之前.&nbsp;<br />例:&nbsp;<br />PARAMETERS[Low price] Currency,[Beginning date]datatime&nbsp;<br />SELECT OrderID ,OrderAmount&nbsp;<br />FROM Orders&nbsp;<br />WHERE OrderAMount&gt;[low price]&nbsp;<br />AND OrderDate&gt;=[Beginning date]&nbsp;<br />七. 功能查询&nbsp;<br />所谓功能查询,实际上是一种操作查询,它可以对数据库进行快速高效的操作.它以选择查询为目的,挑选出符合条件的数据,再对数据进行批处理.功能查询包括更新查询,删除查询,添加查询,和生成表查询.<br />1 更新查询&nbsp;<br />UPDATE子句可以同时更改一个或多个表中的数据.它也可以同时更改多个字段的值.&nbsp;<br />更新查询语法:&nbsp;<br />UPDATE 表名&nbsp;<br />SET 新值&nbsp;<br />WHERE 准则&nbsp;<br />例:英国客户的定货量增加5%,货运量增加3%&nbsp;<br />UPDATE OEDERS&nbsp;<br />SET OrderAmount = OrderAmount *1.1&nbsp;<br />Freight = Freight*1.03&nbsp;<br />WHERE ShipCountry = &lsquo;UK&rsquo;&nbsp;<br />2 删除查询&nbsp;<br />DELETE子句可以使用户删除大量的过时的或冗于的数据.&nbsp;<br />注:删除查询的对象是整个记录.&nbsp;<br />DELETE子句的语法:&nbsp;<br />DELETE [表名.*]&nbsp;<br />FROM 来源表&nbsp;<br />WHERE 准则&nbsp;<br />例: 要删除所有94年前的定单&nbsp;<br />DELETE *&nbsp;<br />FROM Orders&nbsp;<br />WHERE OrderData&lt;#94-1-1#&nbsp;<br />3 追加查询&nbsp;<br />INSERT子句可以将一个或一组记录追加到一个或多个表的尾部.&nbsp;<br />INTO 子句指定接受新记录的表&nbsp;<br />valueS 关键字指定新记录所包含的数据值.&nbsp;<br />INSERT 子句的语法:&nbsp;<br />INSETR INTO 目的表或查询(字段1,字段2,&hellip;)&nbsp;<br />valueS(数值1,数值2,&hellip;)&nbsp;<br />例:增加一个客户&nbsp;<br />INSERT INTO Employees(FirstName,LastName,title)&nbsp;<br />valueS(&lsquo;Harry&rsquo;,&rsquo;Washington&rsquo;,&rsquo;Trainee&rsquo;)&nbsp;<br />4 生成表查询&nbsp;<br />可以一次性地把所有满足条件的记录拷贝到一张新表中.通常制作记录的备份或副本或作为报表的基础.&nbsp;<br />SELECT INTO子句用来创建生成表查询语法:&nbsp;<br />SELECT 字段1,字段2,&hellip;&nbsp;<br />INTO 新表[IN 外部数据库]&nbsp;<br />FROM 来源数据库&nbsp;<br />WHERE 准则&nbsp;<br />例:为定单制作一个存档备份&nbsp;<br />SELECT *&nbsp;<br />INTO OrdersArchive&nbsp;<br />FROM Orders&nbsp;<br />八. 联合查询&nbsp;<br />UNION运算可以把多个查询的结果合并到一个结果集里显示.&nbsp;<br />UNION运算的一般语法:&nbsp;<br />[表]查询1 UNION [ALL]查询2 UNION &hellip;&nbsp;<br />例:返回巴西所有供给商和客户的名字和城市&nbsp;<br />SELECT CompanyName,City&nbsp;<br />FROM Suppliers&nbsp;<br />WHERE Country = &lsquo;Brazil&rsquo;&nbsp;<br />UNION&nbsp;<br />SELECT CompanyName,City&nbsp;<br />FROM Customers&nbsp;<br />WHERE Country = &lsquo;Brazil&rsquo;&nbsp;<br />注:&nbsp;<br />缺省的情况下,UNION子句不返回重复的记录.如果想显示所有记录,可以加ALL选项&nbsp;<br />UNION运算要求查询具有相同数目的字段.但是,字段数据类型不必相同.&nbsp;<br />每一个查询参数中可以使用GROUP BY 子句 或 HAVING 子句进行分组.要想以指定的顺序来显示返回的数据,可以在最后一个查询的尾部使用OREER BY子句.&nbsp;<br />九. 交叉查询&nbsp;<br />交叉查询可以对数据进行总和,平均,计数或其他总和计算法的计算,这些数据通过两种信息进行分组:一个显示在表的左部,另一个显示在表的顶部.&nbsp;<br />Microsoft Jet SQL 用TRANSFROM语句创建交叉表查询语法:&nbsp;<br />TRANSFORM aggfunction&nbsp;<br />SELECT 语句&nbsp;<br />GROUP BY 子句&nbsp;<br />PIVOT pivotfield[IN(value1 [,value2[,&hellip;]]) ]&nbsp;<br />Aggfounction指SQL聚积函数,&nbsp;<br />SELECT语句选择作为标题的的字段,&nbsp;<br />GROUP BY 分组&nbsp;<br />说明：&nbsp;<br />Pivotfield 在查询结果集中创建列标题时用的字段或表达式,用可选的IN子句限制它的取值.&nbsp;<br />value代表创建列标题的固定值.&nbsp;<br />例:显示在1996年里每一季度每一位员工所接的定单的数目:&nbsp;<br />TRANSFORM Count(OrderID)&nbsp;<br />SELECT FirstName&amp;&rsquo;&rsquo;&amp;LastName AS FullName&nbsp;<br />FROM Employees INNER JOIN Orders&nbsp;<br />ON Employees.EmployeeID = Orders.EmployeeID&nbsp;<br />WHERE DatePart(&ldquo;yyyy&rdquo;,OrderDate)= &lsquo;1996&rsquo;&nbsp;<br />GROUP BY FirstName&amp;&rsquo;&rsquo;&amp;LastName&nbsp;<br />ORDER BY FirstName&amp;&rsquo;&rsquo;&amp;LastName&nbsp;<br />POVOT DatePart(&ldquo;q&rdquo;,OrderDate)&amp;&rsquo;季度&rsquo;&nbsp;<br />十 .子查询&nbsp;<br />子查询可以理解为 套查询.子查询是一个SELECT语句.&nbsp;<br />1 表达式的值与子查询返回的单一值做比较&nbsp;<br />语法:&nbsp;<br />表达式 comparision [ANY|ALL|SOME](子查询)&nbsp;<br />说明：&nbsp;<br />ANY 和SOME谓词是同义词,与比较运算符(=,&lt;,&gt;,&lt;&gt;,&lt;=,&gt;=)一起使用.返回一个布尔值True或 False.ANY的意思是,表达式与子查询返回的一系列的值逐一比较,只要其中的一次比较产生True结果,ANY测试的返回 True值(既WHERE子句的结果),对应于该表达式的当前记录将进入主查询的结果中.ALL测试则要求表达式与子查询返回的一系列的值的比较都产生 True结果,才回返回True值.&nbsp;<br />例:主查询返回单价比任何一个折扣大于等于25%的产品的单价要高的所有产品&nbsp;<br />SELECT * FROM Products&nbsp;<br />WHERE UnitPrice&gt;ANY&nbsp;<br />(SELECT UnitPrice FROM[Order Details] WHERE Discount&gt;0.25)</p>
<p>2 检查表达式的值是否匹配子查询返回的一组值的某个值&nbsp;<br />语法:&nbsp;<br />[NOT]IN(子查询)&nbsp;<br />例:返回库存价值大于等于1000的产品.&nbsp;<br />SELECT ProductName FROM Products&nbsp;<br />WHERE ProductID IN&nbsp;<br />(SELECT PrdoctID FROM [Order DEtails]&nbsp;<br />WHERE UnitPrice*Quantity&gt;= 1000)</p>
<p>3检测子查询是否返回任何记录&nbsp;<br />语法:&nbsp;<br />[NOT]EXISTS (子查询)&nbsp;<br />例:用EXISTS检索英国的客户&nbsp;<br />SELECT ComPanyName,ContactName&nbsp;<br />FROM Orders&nbsp;<br />WHERE EXISTS&nbsp;<br />(SELECT *&nbsp;<br />FROM Customers&nbsp;<br />WHERE Country = &lsquo;UK&rsquo; AND&nbsp;<br />Customers.CustomerID= Orders.CustomerID)</p>]]></description></item><item><title>linux sed命令详解</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769314.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 14 Nov 2012 01:31:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769314.html</guid><description><![CDATA[<div id="" class="dp-highlighter"><ol class="dp-j" start="1">
<li><span><span class="number">1</span>.&nbsp;Sed简介&nbsp;&nbsp;</span></li>
<li><span>sed&nbsp;是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为&ldquo;模式空间&rdquo;（pattern&nbsp;space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有&nbsp;改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。以下介绍的是Gnu版本的Sed&nbsp;<span class="number">3.02</span>。&nbsp;&nbsp;</span></li>
<li><span><span class="number">2</span>.&nbsp;定址&nbsp;&nbsp;</span></li>
<li><span>可以通过定址来定位你所希望编辑的行，该地址用数字构成，用逗号分隔的两个行数表示以这两行为起止的行的范围（包括行数表示的那两行）。如<span class="number">1</span>，<span class="number">3</span>表示<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>行，美元符号($)表示最后一行。范围可以通过数据，正则表达式或者二者结合的方式确定&nbsp;。&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
<li><span><span class="number">3</span>.&nbsp;Sed命令&nbsp;&nbsp;</span></li>
<li><span>调用sed命令有两种形式：&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>sed&nbsp;[options]&nbsp;<span class="string">'command'</span>&nbsp;file(s)&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>sed&nbsp;[options]&nbsp;-f&nbsp;scriptfile&nbsp;file(s)&nbsp;&nbsp;</span></li>
<li><span>a\&nbsp;&nbsp;</span></li>
<li><span>在当前行后面加入一行文本。&nbsp;&nbsp;</span></li>
<li><span>b&nbsp;lable&nbsp;&nbsp;</span></li>
<li><span>分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。&nbsp;&nbsp;</span></li>
<li><span>c\&nbsp;&nbsp;</span></li>
<li><span>用新的文本改变本行的文本。&nbsp;&nbsp;</span></li>
<li><span>d&nbsp;&nbsp;</span></li>
<li><span>从模板块（Pattern&nbsp;space）位置删除行。&nbsp;&nbsp;</span></li>
<li><span>D&nbsp;&nbsp;</span></li>
<li><span>删除模板块的第一行。&nbsp;&nbsp;</span></li>
<li><span>i\&nbsp;&nbsp;</span></li>
<li><span>在当前行上面插入文本。&nbsp;&nbsp;</span></li>
<li><span>h&nbsp;&nbsp;</span></li>
<li><span>拷贝模板块的内容到内存中的缓冲区。&nbsp;&nbsp;</span></li>
<li><span>H&nbsp;&nbsp;</span></li>
<li><span>追加模板块的内容到内存中的缓冲区&nbsp;&nbsp;</span></li>
<li><span>g&nbsp;&nbsp;</span></li>
<li><span>获得内存缓冲区的内容，并替代当前模板块中的文本。&nbsp;&nbsp;</span></li>
<li><span>G&nbsp;&nbsp;</span></li>
<li><span>获得内存缓冲区的内容，并追加到当前模板块文本的后面。&nbsp;&nbsp;</span></li>
<li><span>l&nbsp;&nbsp;</span></li>
<li><span>列表不能打印字符的清单。&nbsp;&nbsp;</span></li>
<li><span>n&nbsp;&nbsp;</span></li>
<li><span>读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。&nbsp;&nbsp;</span></li>
<li><span>N&nbsp;&nbsp;</span></li>
<li><span>追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。&nbsp;&nbsp;</span></li>
<li><span>p&nbsp;&nbsp;</span></li>
<li><span>打印模板块的行。&nbsp;&nbsp;</span></li>
<li><span>P（大写）&nbsp;&nbsp;</span></li>
<li><span>打印模板块的第一行。&nbsp;&nbsp;</span></li>
<li><span>q&nbsp;&nbsp;</span></li>
<li><span>退出Sed。&nbsp;&nbsp;</span></li>
<li><span>r&nbsp;file&nbsp;&nbsp;</span></li>
<li><span>从file中读行。&nbsp;&nbsp;</span></li>
<li><span>t&nbsp;label&nbsp;&nbsp;</span></li>
<li><span><span class="keyword">if</span>分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。&nbsp;&nbsp;</span></li>
<li><span>T&nbsp;label&nbsp;&nbsp;</span></li>
<li><span>错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。&nbsp;&nbsp;</span></li>
<li><span>w&nbsp;file&nbsp;&nbsp;</span></li>
<li><span>写并追加模板块到file末尾。&nbsp;&nbsp;</span></li>
<li><span>W&nbsp;file&nbsp;&nbsp;</span></li>
<li><span>写并追加模板块的第一行到file末尾。&nbsp;&nbsp;</span></li>
<li><span>!&nbsp;&nbsp;</span></li>
<li><span>表示后面的命令对所有没有被选定的行发生作用。&nbsp;&nbsp;</span></li>
<li><span>s/re/string&nbsp;&nbsp;</span></li>
<li><span>用string替换正则表达式re。&nbsp;&nbsp;</span></li>
<li><span>=&nbsp;&nbsp;</span></li>
<li><span>打印当前行号码。&nbsp;&nbsp;</span></li>
<li><span>#&nbsp;&nbsp;</span></li>
<li><span>把注释扩展到下一个换行符以前。&nbsp;&nbsp;</span></li>
<li><span>以下的是替换标记&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>g表示行内全面替换。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>p表示打印行。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>w表示把行写入一个文件。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>x表示互换模板块中的文本和缓冲区中的文本。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>y表示把一个字符翻译为另外的字符（但是不用于正则表达式）&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
<li><span><span class="number">4</span>.&nbsp;选项&nbsp;&nbsp;</span></li>
<li><span>-e&nbsp;command,&nbsp;--expression=command&nbsp;&nbsp;</span></li>
<li><span>允许多台编辑。&nbsp;&nbsp;</span></li>
<li><span>-h,&nbsp;--help&nbsp;&nbsp;</span></li>
<li><span>打印帮助，并显示bug列表的地址。&nbsp;&nbsp;</span></li>
<li><span>-n,&nbsp;--quiet,&nbsp;--silent&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
<li><span>取消默认输出。&nbsp;&nbsp;</span></li>
<li><span>-f,&nbsp;--filer=script-file&nbsp;&nbsp;</span></li>
<li><span>引导sed脚本文件名。&nbsp;&nbsp;</span></li>
<li><span>-V,&nbsp;--version&nbsp;&nbsp;</span></li>
<li><span>打印版本和版权信息。&nbsp;&nbsp;</span></li>
<li><span>&nbsp;&nbsp;</span></li>
<li><span><span class="number">5</span>.&nbsp;元字符集^&nbsp;&nbsp;</span></li>
<li><span>锚定行的开始&nbsp;如：/^sed/匹配所有以sed开头的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;&nbsp;</span></li>
<li><span>锚定行的结束&nbsp;如：/sed$/匹配所有以sed结尾的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>.&nbsp;&nbsp;</span></li>
<li><span>匹配一个非换行符的字符&nbsp;如：/s.d/匹配s后接一个任意字符，然后是d。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>匹配零或多个字符&nbsp;如：<span class="comment">/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。&nbsp;</span>&nbsp;</span></li>
<li><span><span class="comment">[]</span>&nbsp;</span></li>
<li><span><span class="comment">匹配一个指定范围内的字符，如/[Ss]ed/匹配sed和Sed。&nbsp;</span>&nbsp;</span></li>
<li><span><span class="comment">[^]</span>&nbsp;</span></li>
<li><span><span class="comment">匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。&nbsp;</span>&nbsp;</span></li>
<li><span><span class="comment">\(..\)</span>&nbsp;</span></li>
<li><span><span class="comment">保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。&nbsp;</span>&nbsp;</span></li>
<li><span><span class="comment">&amp;</span>&nbsp;</span></li>
<li><span><span class="comment">保存搜索字符用来替换其他字符，如s/love/**&amp;**/</span>，love这成**love**。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>\&lt;&nbsp;&nbsp;</span></li>
<li><span>锚定单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>\&gt;&nbsp;&nbsp;</span></li>
<li><span>锚定单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>x\{m\}&nbsp;&nbsp;</span></li>
<li><span>重复字符x，m次，如：/<span class="number">0</span>\{<span class="number">5</span>\}/匹配包含<span class="number">5</span>个o的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>x\{m,\}&nbsp;&nbsp;</span></li>
<li><span>重复字符x,至少m次，如：/o\{<span class="number">5</span>,\}/匹配至少有<span class="number">5</span>个o的行。&nbsp;&nbsp;&nbsp;</span></li>
<li><span>x\{m,n\}&nbsp;&nbsp;</span></li>
<li><span>重复字符x，至少m次，不多于n次，如：/o\{<span class="number">5</span>,<span class="number">10</span>\}/匹配<span class="number">5</span>--<span class="number">10</span>个o的行。&nbsp;&nbsp;</span></li>
<li><span><span class="number">6</span>.&nbsp;实例&nbsp;&nbsp;</span></li>
<li><span>删除：d命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'2d'</span>&nbsp;example-----删除example文件的第二行。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'2,$d'</span>&nbsp;example-----删除example文件的第二行到末尾所有行。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'$d'</span>&nbsp;example-----删除example文件的最后一行。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'/test/'</span>d&nbsp;example-----删除example文件所有包含test的行。&nbsp;&nbsp;</span></li>
<li><span>替换：s命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'s/test/mytest/g'</span>&nbsp;example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-n&nbsp;<span class="string">'s/^test/mytest/p'</span>&nbsp;example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'s/^192.168.0.1/&amp;localhost/'</span>&nbsp;example-----&amp;符号表示替换换字符串中被找到的部份。所有以<span class="number">192.168</span>.<span class="number">0.1</span>开头的行都会被替换成它自已加&nbsp;localhost，变成<span class="number">192.168</span>.<span class="number">0</span>.1localhost。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-n&nbsp;<span class="string">'s/\(love\)able/\1rs/p'</span>&nbsp;example-----love被标记为<span class="number">1</span>，所有loveable会被替换成lovers，而且替换的行会被打印出来。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'s#10#100#g'</span>&nbsp;example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，&ldquo;#&rdquo;在这里是分隔符，代替了默认的&ldquo;/&rdquo;分隔符。表示把所有<span class="number">10</span>替换成<span class="number">100</span>。&nbsp;&nbsp;</span></li>
<li><span>选定行的范围：逗号&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-n&nbsp;<span class="string">'/test/,/check/p'</span>&nbsp;example-----所有在模板test和check所确定的范围内的行都被打印。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-n&nbsp;<span class="string">'5,/^test/p'</span>&nbsp;example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'/test/,/check/s/$/sed&nbsp;test/'</span>&nbsp;example-----对于模板test和west之间的行，每行的末尾用字符串sed&nbsp;test替换。&nbsp;&nbsp;</span></li>
<li><span>多点编辑：e命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-e&nbsp;<span class="string">'1,5d'</span>&nbsp;-e&nbsp;<span class="string">'s/test/check/'</span>&nbsp;example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除<span class="number">1</span>至<span class="number">5</span>行，第二条命令用check替换test。命令的执&nbsp;行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;--expression=<span class="string">'s/test/check/'</span>&nbsp;--expression=<span class="string">'/love/d'</span>&nbsp;example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。&nbsp;&nbsp;</span></li>
<li><span>从文件读入：r命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'/test/r&nbsp;file'</span>&nbsp;example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。&nbsp;&nbsp;</span></li>
<li><span>写入文件：w命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-n&nbsp;<span class="string">'/test/w&nbsp;file'</span>&nbsp;example-----在example中所有包含test的行都被写入file里。&nbsp;&nbsp;</span></li>
<li><span>追加命令：a命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'/^test/a\\---&gt;this&nbsp;is&nbsp;a&nbsp;example'</span>&nbsp;example&lt;-----<span class="string">'this&nbsp;is&nbsp;a&nbsp;example'</span>被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。&nbsp;&nbsp;</span></li>
<li><span>插入：i命令&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;'/test/i\\&nbsp;&nbsp;</span></li>
<li><span><span class="keyword">new</span>&nbsp;line&nbsp;&nbsp;</span></li>
<li><span>-------------------------'&nbsp;example&nbsp;&nbsp;</span></li>
<li><span>如果test被匹配，则把反斜杠后面的文本插入到匹配行的前面。&nbsp;&nbsp;</span></li>
<li><span>下一个：n命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'/test/{&nbsp;n;&nbsp;s/aa/bb/;&nbsp;}'</span>&nbsp;example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。&nbsp;&nbsp;</span></li>
<li><span>变形：y命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'1,10y/abcde/ABCDE/'</span>&nbsp;example-----把<span class="number">1</span>--<span class="number">10</span>行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。&nbsp;&nbsp;</span></li>
<li><span>退出：q命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;<span class="string">'10q'</span>&nbsp;example-----打印完第<span class="number">10</span>行后，退出sed。&nbsp;&nbsp;</span></li>
<li><span>保持和获取：h命令和G命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-e&nbsp;<span class="string">'/test/h'</span>&nbsp;-e&nbsp;'$G&nbsp;example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将&nbsp;打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保&nbsp;持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中&nbsp;的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。&nbsp;&nbsp;</span></li>
<li><span>保持和互换：h命令和x命令&nbsp;&nbsp;</span></li>
<li><span>*&nbsp;&nbsp;</span></li>
<li><span>$&nbsp;sed&nbsp;-e&nbsp;<span class="string">'/test/h'</span>&nbsp;-e&nbsp;<span class="string">'/check/x'</span>&nbsp;example&nbsp;-----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。&nbsp;&nbsp;</span></li>
<li><span><span class="number">7</span>.&nbsp;脚本&nbsp;&nbsp;</span></li>
<li><span>Sed脚本是一个sed的命令清单，启动Sed时以-f选项引导脚本文件名。Sed对于脚本中输入的命令非常挑剔，在命令的末尾不能有任何空白或文本，如果在一行中有多个命令，要用分号分隔。以#开头的行为注释行，且不能跨行。&nbsp;&nbsp;</span></li>
</ol></div>
<p>&nbsp;</p>
<p>sed真的可以大大提高我们的工作效率，下面就写了这样一行，好多文件都被替换了，真方便</p>
<div id="" class="dp-highlighter">
<div class="bar">
<div class="tools">Java代码&nbsp;<object width="14" height="15" data="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" type="application/x-shockwave-flash"><param name="src" value="http://www.iteye.com/javascripts/syntaxhighlighter/clipboard_new.swf" /><param name="wmode" value="transparent" /><param name="flashvars" value="clipboard=sed%20's%2Flocalhost%2F127.0.0.1%2Fg'%20mysql_virtual_*.cf" /><param name="quality" value="high" /><param name="allowscriptaccess" value="always" /><param name="pluginspage" value="http://www.macromedia.com/go/getflashplayer" /></object>&nbsp;<a title="收藏这段代码" href="http://www.iteye.com/topic/587673"><img class="star" src="http://www.iteye.com/images/icon_star.png" alt="收藏代码" /></a></div>
</div>
<ol class="dp-j" start="1">
<li><span>sed&nbsp;<span class="string">'s/localhost/127.0.0.1/g'</span>&nbsp;mysql_virtual_*.cf &nbsp;</span></li>
</ol></div>]]></description></item><item><title>linux之awk用法</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769316.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 14 Nov 2012 01:31:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769316.html</guid><description><![CDATA[<p>awk是一个非常棒的数字处理工具。相比于sed常常作用于一整行的处理，awk则比较倾向于将一行分为数个&ldquo;字段&rdquo;来处理。运行效率高，而且代码简单，对格式化的文本处理能力超强。先来一个例子：<br />　　文件a，统计文件a的第一列中是浮点数的行的浮点数的平均值。用awk来实现只需要一句话就可以搞定<br /><span>$cat a<br /></span>1.021 33<br />1#.ll&nbsp;&nbsp; 44<br />2.53 6<br />ss&nbsp;&nbsp;&nbsp; 7<br /><br /><span>awk 'BEGIN{total = 0;len = 0} {if($1~/^[0-9]+\.[0-9]*/){total += $1; len++}} END{print total/len}' a<br />（分析：$1~/^[0-9]+\.[0-9]*/表示$1与&ldquo;/ /&rdquo;里面的正则表达式进行匹配，若匹配，则total加上$1，且len自增，即数目加1.&ldquo;^[0-9]+\.[0-9]*&rdquo;是个正则表达式，&ldquo;^[0-9]&rdquo;表示以数字开头，&ldquo;\.&rdquo;是转义的意思，表示&ldquo;.&rdquo;为小数点的意思。&ldquo;[0-9]*&rdquo;表示0个或多个数字）</span></p>
<p>awk的一般语法格式为：<br />　　awk [-参数 变量] 'BEGIN{初始化}条件类型1{动作1}条件类型2{动作2}。。。。END{后处理}'<br />其中：BEGIN和END中的语句分别在开始读取文件（in_file）之前和读取完文件之后发挥作用，可以理解为初始化和扫尾。<br /><span><strong>（1）参数说明：</strong></span><br />　　&nbsp;-F re：允许awk更改其字段分隔符<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-v var=$v 把v值赋值给var，如果有多个变量要赋值，那么就写多个-v，每个变量赋值对应一个-v<br />　　　　e.g. 要打印文件a的第num行到num+num1行之间的行，&nbsp;<br />　　　　　　awk -v num=$num -v num1=$num1 'NR==num,NR==num+num1{print}' a&nbsp;<br />　　-f progfile：允许awk调用并执行progfile程序文件，当然progfile必须是一个符合awk语法的程序文件。</p>
<p><span><strong>（2）awk内置变量：</strong></span><br /><strong>ARGC</strong>&nbsp;&nbsp;&nbsp; 命令行参数的个数<br /><strong>ARGV&nbsp;&nbsp;&nbsp;</strong>&nbsp;命令行参数数组<br /><strong>ARGIND</strong>&nbsp;当前被处理文件的ARGV标志符<br />e.g 有两个文件a 和b&nbsp;<br /><span>awk '{if(ARGIND==1){print "处理a文件"} if(ARGIND==2){print "处理b文件"}}' a b<br /></span>文件处理的顺序是先扫描完a文件，再扫描b文件</p>
<p><strong>NR 　　</strong>已经读出的记录数<br /><strong>FNR</strong>&nbsp;&nbsp; 　当前文件的记录数<br />上面的例子也可以写成这样：<br /><span>awk 'NR==FNR{print "处理文件a"} NR &gt; FNR{print "处理文件b"}' a b<br /></span>输入文件a和b，由于先扫描a，所以扫描a的时候必然有NR==FNR，然后扫描b的时候，FNR从1开始计数，而NR则接着a的行数继续计数，所以NR &gt; FNR</p>
<p>e.g 要显示文件的第10行至第15行<br /><span>awk 'NR==10,NR==15{print}' a</span></p>
<p><strong>FS 　　</strong>输入字段分隔符（缺省为:space:），相当于-F选项<br /><span>awk -F ':' '{print}' a</span>&nbsp;&nbsp;&nbsp; 和&nbsp;&nbsp;&nbsp;<span>awk 'BEGIN{FS=":"}{print}' a</span>&nbsp;是一样的</p>
<p><strong>OFS</strong>输出字段分隔符（缺省为:space:）<br /><span>awk -F ':' 'BEGIN{OFS=";"}{print $1,$2,$3}' b<br /></span>如果cat b为<br />1:2:3<br />4:5:6<br />那么把OFS设置成";"后就会输出<br />1;2;3<br />4;5;6<br />（小注释：awk把分割后的第1、2、3个字段用$1,$2,$3...表示，$0表示整个记录（一般就是一整行））</p>
<p><strong>NF</strong>：当前记录中的字段个数<br /><span>awk -F ':' '{print NF}' b</span>的输出为<br />3<br />3<br />表明b的每一行用分隔符":"分割后都3个字段<br />可以用NF来控制输出符合要求的字段数的行，这样可以处理掉一些异常的行<br /><span>awk -F ':' '{if (NF == 3)print}' b</span></p>
<p><strong>RS</strong>：输入记录分隔符，缺省为"\n"<br />缺省情况下，awk把一行看作一个记录；如果设置了RS，那么awk按照RS来分割记录<br />例如，如果文件c，cat c为<br />hello world; I want to go swimming tomorrow;hiahia<br />运行&nbsp;<span>awk 'BEGIN{ RS = ";" } {print}' c</span>&nbsp;的结果为<br />hello world<br />I want to go swimming tomorrow<br />hiahia<br />合理的使用RS和FS可以使得awk处理更多模式的文档，例如可以一次处理多行，例如文档d cat d的输出为<br />1 2<br />3 4 5<br /><br />6 7<br />8 9 10<br />11 12</p>
<p>hello<br />每个记录使用空行分割，每个字段使用换行符分割，这样的awk也很好写<br /><span>awk 'BEGIN{ FS = "\n"; RS = ""} {print NF}' d</span>&nbsp;输出<br />2<br />3<br />1</p>
<p><strong>ORS</strong>：输出记录分隔符，缺省为换行符，控制每个print语句后的输出符号<br /><span>awk 'BEGIN{ FS = "\n"; RS = ""; ORS = ";"} {print NF}' d</span>&nbsp;输出<br />2;3;1<br /><span><strong>（3）awk读取shell中的变量</strong></span><br />可以使用-v选项实现功能<br />&nbsp;&nbsp;&nbsp;&nbsp; $b=1<br />&nbsp;&nbsp;&nbsp;&nbsp; $cat f<br />&nbsp;&nbsp;&nbsp;&nbsp; apple<br /><br /><span>$awk -v var=$b '{print var, $var}' f<br /></span>1 apple<br />至于有没有办法把awk中的变量传给shell呢，这个问题我是这样理解的。shell调用awk实际上是fork一个子进程出来，而子进程是无法向父进程传递变量的，除非用重定向（包括管道）<br /><span>a=$(awk '{print $b, '$b'}' f)</span><br />$echo $a<br />apple 1</p>
<p><span><strong><span><strong>（4）</strong></span><span>输出重定向</span></strong></span></p>
<p>awk的输出重定向类似于shell的重定向。重定向的目标文件名必须用双引号引用起来。<br /><span>$awk '$4 &gt;=70 {print $1,$2 &gt; "destfile" }' filename<br />$awk '$4 &gt;=70 {print $1,$2 &gt;&gt; "destfile" }' filename</span></p>
<p><span><strong>（5）awk中调用shell命令：</strong></span></p>
<p>1)使用<strong>管道</strong><br />awk中的管道概念和shell的管道类似，都是使用"|"符号。如果在awk程序中打开了管道，<span>必须先关闭该管道才能打开另一个管道</span>。也就是说一次只能打开一个管道。<span>shell命令必须被双引号引用起来。<span>&ldquo;如果打算再次在awk程序中使用某个文件或管道进行读写，则可能要先关闭程序，因为其中的管道会保持打开状态直至脚本运行结束。注意，管道一旦被打开，就会保持打开状态直至awk退出。因此END块中的语句也会收到管道的影响。（可以在END的第一行关闭管道）&rdquo;</span><br /></span>awk中使用管道有两种语法，分别是：<br />awk output | shell input<br />shell output | awk input</p>
<p>对于awk output | shell input来说，shell接收awk的输出，并进行处理。需要注意的是，awk的output是先缓存在pipe中，等输出完毕后再调用shell命令 处理，shell命令只处理一次，而且处理的时机是&ldquo;awk程序结束时，或者管道关闭时（需要显式的关闭管道）&rdquo;<br /><span>$awk '/west/{count++} {printf "%s %s\t\t%-15s\n", $3,$4,$1 | "sort +1"} END{close "sort +1"; printf "The number of sales pers in the western"; printf "region is " count "." }' datafile （解释：/west/{count++}表示与&ldquo;wes&rdquo;t进行匹配，若匹配，则count自增）<br /></span>printf函数用于将输出格式化并发送给管道。所有输出集齐后，被一同发送给sort命令。必须用与打开时完全相同的命令来关闭管道(sort +1)，否则END块中的语句将与前面的输出一起被排序。此处的sort命令只执行一次。</p>
<p>在shell output | awk input中awk的input只能是getline函数。shell执行的结果缓存于pipe中，再传送给awk处理，如果有多行数据，awk的getline命令可能调用多次。<br /><span>$awk 'BEGIN{ while(("ls" | getline d) &gt; 0) print d}' f</span></p>]]></description></item><item><title>Linux中find常见用法示例</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769312.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Wed, 14 Nov 2012 01:30:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/14/2769312.html</guid><description><![CDATA[<h2>&middot;find&nbsp;&nbsp; path&nbsp;&nbsp; -option&nbsp;&nbsp; [&nbsp;&nbsp; -print ]&nbsp;&nbsp; [ -exec&nbsp;&nbsp; -ok&nbsp;&nbsp; command ]&nbsp;&nbsp; {} \;</h2>
<div>
<div>
<div>
<p>find命令的参数；</p>
<p><span>pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。</span><br />-print： find命令将匹配的文件输出到标准输出。<br />-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \;，注意{ }和\；之间的空格。<br />-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>

</div>
<div>#-print 将查找到的文件输出到标准输出<br />#-exec&nbsp;&nbsp; command&nbsp;&nbsp; {} \;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &mdash;&ndash;将查到的文件执行command操作,{} 和 \;之间有空格<br />#-ok 和-exec相同，只不过在操作前要询用户</div>
<div>&nbsp;</div>
<div>例：find . -name .svn | xargs rm -rf</div>
<div>
<p>====================================================</p>
<p>-name&nbsp;&nbsp; filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查找名为filename的文件<br />-perm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按执行权限来查找<br />-user&nbsp;&nbsp;&nbsp; username&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按文件属主来查找<br />-group groupname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按组来查找<br />-mtime&nbsp;&nbsp; -n +n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按文件更改时间来查找文件，-n指n天以内，+n指n天以前<br />-atime&nbsp;&nbsp;&nbsp; -n +n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按文件访问时间来查GIN: 0px"&gt;</p>
<p>-ctime&nbsp;&nbsp;&nbsp; -n +n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按文件创建时间来查找文件，-n指n天以内，+n指n天以前</p>

</div>
<div>-nogroup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br />-nouser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br />-newer&nbsp;&nbsp; f1 !f2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 找文件，-n指n天以内，+n指n天以前&nbsp;<br />-ctime&nbsp;&nbsp;&nbsp; -n +n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #按文件创建时间来查找文件，-n指n天以内，+n指n天以前&nbsp;<br />-nogroup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查无有效属组的文件，即文件的属组在/etc/groups中不存在<br />-nouser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查无有效属主的文件，即文件的属主在/etc/passwd中不存<br />-newer&nbsp;&nbsp; f1 !f2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查更改时间比f1新但比f2旧的文件<br />-type&nbsp;&nbsp;&nbsp; b/d/c/p/l/f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查是块设备、目录、字符设备、管道、符号链接、普通文件<br />-size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n[c]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查长度为n块[或n字节]的文件<br />-depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #使查找在进入子目录前先行查找完本目录<br />-fstype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查更改时间比f1新但比f2旧的文件<br />-type&nbsp;&nbsp;&nbsp; b/d/c/p/l/f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查是块设备、目录、字符设备、管道、符号链接、普通文件<br />-size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n[c]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查长度为n块[或n字节]的文件<br />-depth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #使查找在进入子目录前先行查找完本目录<br />-fstype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到<br />-mount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查文件时不跨越文件系统mount点<br />-follow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #如果遇到符号链接文件，就跟踪链接所指的文件<br />-cpio&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到<br />-mount&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查文件时不跨越文件系统mount点<br />-follow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #如果遇到符号链接文件，就跟踪链接所指的文件<br />-cpio&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #对匹配的文件使用cpio命令，将他们备份到磁带设备中<br />-prune&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #忽略某个目录<br />
<p>=====================================================<br />$find&nbsp;&nbsp; ~&nbsp;&nbsp; -name&nbsp;&nbsp; "*.txt"&nbsp;&nbsp; -print&nbsp;&nbsp;&nbsp; #在$HOME中查.txt文件并显示<br />$find&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; -name&nbsp;&nbsp; "*.txt"&nbsp;&nbsp; -print<br />$find&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; -name&nbsp;&nbsp; "[A-Z]*"&nbsp;&nbsp; -print&nbsp;&nbsp; #查以大写字母开头的文件<br />$find&nbsp;&nbsp; /etc&nbsp;&nbsp; -name&nbsp;&nbsp; "host*"&nbsp;&nbsp; -print #查以host开头的文件<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; -name&nbsp;&nbsp; "[a-z][a-z][0&ndash;9][0&ndash;9].txt"&nbsp;&nbsp;&nbsp; -print&nbsp;&nbsp; #查以两个小写字母和两个数字开头的txt文件<br />$find .&nbsp;&nbsp; -perm&nbsp;&nbsp; 755&nbsp;&nbsp; -print<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; -perm -007&nbsp;&nbsp; -exec ls -l {} \;&nbsp;&nbsp; #查所有用户都可读写执行的文件同-perm 777<br />$find&nbsp;&nbsp; . -type d&nbsp;&nbsp; -print<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; !&nbsp;&nbsp; -type&nbsp;&nbsp; d&nbsp;&nbsp; -print&nbsp;<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; -type l&nbsp;&nbsp; -print</p>
<p>$find&nbsp;&nbsp; .&nbsp;&nbsp; -size&nbsp;&nbsp; +1000000c&nbsp;&nbsp; -print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查长度大于1Mb的文件<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; -size&nbsp;&nbsp; 100c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查长度为100c的文件<br />$find&nbsp;&nbsp; .&nbsp;&nbsp; -size&nbsp;&nbsp; +10&nbsp;&nbsp; -print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查长度超过期作废10块的文件（1块=512字节）</p>
<p>$cd /<br />$find&nbsp;&nbsp; etc&nbsp;&nbsp; home&nbsp;&nbsp; apps&nbsp;&nbsp;&nbsp; -depth&nbsp;&nbsp; -print&nbsp;&nbsp; | cpio&nbsp;&nbsp; -ivcdC65536&nbsp;&nbsp; -o&nbsp;&nbsp; /dev/rmt0<br />$find&nbsp;&nbsp; /etc -name "passwd*"&nbsp;&nbsp; -exec grep&nbsp;&nbsp; "cnscn"&nbsp;&nbsp; {}&nbsp;&nbsp; \;&nbsp;&nbsp; #看是否存在cnscn用户<br />$find . -name "yao*"&nbsp;&nbsp; | xargs file<br />$find&nbsp;&nbsp; . -name "yao*"&nbsp;&nbsp; |&nbsp;&nbsp; xargs&nbsp;&nbsp; echo&nbsp;&nbsp;&nbsp; "" &gt; /tmp/core.log<br />$find&nbsp;&nbsp; . -name "yao*"&nbsp;&nbsp; | xargs&nbsp;&nbsp; chmod&nbsp;&nbsp; o-w</p>
<p>======================================================</p>
<p><strong>find&nbsp;&nbsp; -name april*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在当前目录下查找以april开始的文件</strong><br /><strong>find&nbsp;&nbsp; -name&nbsp;&nbsp; april*&nbsp;&nbsp; fprint file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在当前目录下查找以april开始的文件，并把结果输出到file中</strong><br /><strong>find&nbsp;&nbsp; -name ap* -o -name may*&nbsp;&nbsp; 查找以ap或may开头的文件</strong><br /><strong>find&nbsp;&nbsp; /mnt&nbsp;&nbsp; -name tom.txt&nbsp;&nbsp; -ftype vfat&nbsp;&nbsp; 在/mnt下查找名称为tom.txt且文件系统类型<span>为</span>vfat的文件</strong><br /><strong>find&nbsp;&nbsp; /mnt&nbsp;&nbsp; -name t.txt ! -ftype vfat&nbsp;&nbsp; 在/mnt下查找名称为tom.txt且文件系统类型<span>不为</span>vfat的文件</strong><br /><strong>find&nbsp;&nbsp; /tmp&nbsp;&nbsp; -name wa* -type l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在/tmp下查找名为wa开头且类型为符号链接的文件</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -mtime&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在/home下查最近两天内改动过的文件</strong><br /><strong>find /home&nbsp;&nbsp;&nbsp; -atime -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查1天之内被存取过的文件</strong><br /><strong>find /home -mmin&nbsp;&nbsp;&nbsp; +60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在/home下查60分钟前改动过的文件</strong><br /><strong>find /home&nbsp;&nbsp; -amin&nbsp;&nbsp; +30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查最近30分钟前被存取过的文件</strong><br /><strong>find /home&nbsp;&nbsp; -newer&nbsp;&nbsp; tmp.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在/home下查更新时间比tmp.txt近的文件或目录</strong><br /><strong>find /home&nbsp;&nbsp; -anewer&nbsp;&nbsp; tmp.txt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在/home下查存取时间比tmp.txt近的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -used&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出文件或目录被改动过之后，在2日内被存取过的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -user cnscn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home目录内属于用户cnscn的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -uid&nbsp;&nbsp; +501&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home目录内用户的识别码大于501的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -group&nbsp;&nbsp; cnscn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home内组为cnscn的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -gid 501&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home内组id为501的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -nouser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home内不属于本地用户的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -nogroup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 列出/home内不属于本地组的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp;&nbsp; -name tmp.txt&nbsp;&nbsp;&nbsp; -maxdepth&nbsp;&nbsp; 4&nbsp;&nbsp; 列出/home内的tmp.txt 查时深度最多为3层</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -name tmp.txt&nbsp;&nbsp; -mindepth&nbsp;&nbsp; 3&nbsp;&nbsp; 从第2层开始查</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查找大小为0的文件或空目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -size&nbsp;&nbsp; +512k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 查大于512k的文件</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -size&nbsp;&nbsp; -512k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查小于512k的文件</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -links&nbsp;&nbsp; +2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查硬连接数大于2的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /home&nbsp;&nbsp; -perm&nbsp;&nbsp; 0700&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查权限为700的文件或目录</strong><br /><strong>find&nbsp;&nbsp; /tmp&nbsp;&nbsp; -name tmp.txt&nbsp;&nbsp; -exec cat {} \;</strong><br /><strong>find&nbsp;&nbsp; /tmp&nbsp;&nbsp; -name&nbsp;&nbsp; tmp.txt&nbsp;&nbsp; -ok&nbsp;&nbsp; rm {} \;</strong></p>
<p><strong>find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -amin&nbsp;&nbsp;&nbsp; -10&nbsp;&nbsp;&nbsp;&nbsp; # 查找在系统中最后10分钟访问的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -atime&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查找在系统中最后48小时访问的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -empty&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查找在系统中为空的文件或者文件夹<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -group&nbsp;&nbsp; cat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查找在系统中属于 groupcat的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -mmin&nbsp;&nbsp; -5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 查找在系统中最后5分钟里修改过的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -mtime&nbsp;&nbsp; -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查找在系统中最后24小时里修改过的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -nouser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #查找在系统中属于作废用户的文件<br />find&nbsp;&nbsp;&nbsp; /&nbsp;&nbsp; -user&nbsp;&nbsp;&nbsp; fred&nbsp;&nbsp;&nbsp;&nbsp; #查找在系统中属于FRED这个用户的文件</strong></p>

</div>
<div>&nbsp;</div>
<div><strong>查当前目录下的所有普通文件</strong><hr size="1" />
<div><strong><strong># find . -type f -exec ls -l {} \;&nbsp;<br />-rw-r&ndash;r&ndash;&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34928 2003-02-25&nbsp;&nbsp; ./conf/httpd.conf&nbsp;<br />-rw-r&ndash;r&ndash;&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12959 2003-02-25&nbsp;&nbsp; ./conf/magic&nbsp;<br />-rw-r&ndash;r&ndash;&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 180 2003-02-25&nbsp;&nbsp; ./conf.d/README&nbsp;<br />查当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出</strong></strong>
<p>=================================================<br />在/ l o g s目录中查找更改时间在5日以前的文件并删除它们：<br />$ find logs -type f -mtime +5 -exec&nbsp;&nbsp; -ok&nbsp;&nbsp; rm {} \;</p>
<p>=================================================<br />查询当天修改过的文件<br />[root@book class]# find&nbsp;&nbsp; ./&nbsp;&nbsp; -mtime&nbsp;&nbsp; -1&nbsp;&nbsp; -type f&nbsp;&nbsp; -exec&nbsp;&nbsp; ls -l&nbsp;&nbsp; {} \;</p>
<p>=================================================<br />查询文件并询问是否要显示<br />[root@book class]# find&nbsp;&nbsp; ./&nbsp;&nbsp; -mtime&nbsp;&nbsp; -1&nbsp;&nbsp; -type f&nbsp;&nbsp; -ok&nbsp;&nbsp; ls -l&nbsp;&nbsp; {} \;&nbsp;&nbsp;<br />&lt; ls &hellip; ./classDB.inc.php &gt; ? y<br />-rw-r&ndash;r&ndash;&nbsp;&nbsp;&nbsp; 1 cnscn&nbsp;&nbsp;&nbsp; cnscn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13709&nbsp;&nbsp; 1月 12 12:22 ./classDB.inc.php<br />[root@book class]# find&nbsp;&nbsp; ./&nbsp;&nbsp; -mtime&nbsp;&nbsp; -1&nbsp;&nbsp; -type f&nbsp;&nbsp; -ok&nbsp;&nbsp; ls -l&nbsp;&nbsp; {} \;&nbsp;&nbsp;<br />&lt; ls &hellip; ./classDB.inc.php &gt; ? n<br />[root@book class]#</p>
<p>=================================================<br />查询并交给awk去处理<br />[root@book class]# who&nbsp;&nbsp; |&nbsp;&nbsp; awk&nbsp;&nbsp; &rsquo;{print $1"\t"$2}&rsquo;<br />cnscn&nbsp;&nbsp;&nbsp; pts/0</p>
<p>=================================================<br />awk&mdash;grep&mdash;sed</p>
<p>[root@book class]# df&nbsp;&nbsp; -k |&nbsp;&nbsp; awk &lsquo;{print $1}&rsquo; |&nbsp;&nbsp; grep&nbsp;&nbsp; -v&nbsp;&nbsp; &rsquo;none&rsquo; |&nbsp;&nbsp; sed&nbsp;&nbsp; s"/\/dev\///g"<br />文件系统<br />sda2<br />sda1<br />[root@book class]# df&nbsp;&nbsp; -k |&nbsp;&nbsp; awk &lsquo;{print $1}&rsquo; |&nbsp;&nbsp; grep&nbsp;&nbsp; -v&nbsp;&nbsp; &rsquo;none&rsquo;<br />文件系统<br />/dev/sda2<br />/dev/sda1</p>

</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>
<div><strong><strong><span><strong>1)</strong>在/tmp中查找所有的*.h，并在这些文件中查找&ldquo;SYSCALL_VECTOR"，最后打印出所有包含"SYSCALL_VECTOR"的文件名</span></strong></strong>
<p>A) find&nbsp;&nbsp; /tmp&nbsp;&nbsp; -name&nbsp;&nbsp; "*.h"&nbsp;&nbsp; | xargs&nbsp;&nbsp; -n50&nbsp;&nbsp; grep SYSCALL_VECTOR<br />B) grep&nbsp;&nbsp; SYSCALL_VECTOR&nbsp;&nbsp; /tmp/*.h | cut&nbsp;&nbsp;&nbsp; -d&rsquo;:'&nbsp;&nbsp; -f1| uniq &gt; filename<br />C) find&nbsp;&nbsp; /tmp&nbsp;&nbsp; -name "*.h"&nbsp;&nbsp; -exec grep "SYSCALL_VECTOR"&nbsp;&nbsp; {}&nbsp;&nbsp; \; -print</p>
<p>2)find / -name filename -exec rm -rf {} \;<br />&nbsp;&nbsp;&nbsp; find / -name filename -ok rm -rf {} \;</p>
<p><strong>3)比如要查找磁盘中大于3M的文件：<br /></strong>find . -size +3000k -exec ls -ld {} ;</p>
<p>4)将find出来的东西拷到另一个地方<br />find *.c -exec cp &lsquo;{}&rsquo; /tmp &lsquo;;&rsquo;</p>
<p>如果有特殊文件，可以用cpio，也可以用这样的语法：<br />find dir -name filename -print | cpio -pdv newdir</p>
<p>6)查找<strong>2004-11-30 16:36:37时更改过的文件</strong><br /><strong># A=`find ./ -name "*php"` |&nbsp;&nbsp; ls -l &ndash;full-time $A 2&gt;/dev/null | grep "2004-11-30 16:36:37"</strong></p>

</div>

</div>

</div>

</div>

</div>
<p title="查看所有Linux-all中的所有文章"><a>Linux-all</a>,&nbsp;<a title="查看所有Linux中的所有文章" href="http://202.112.85.88/?cat=14" rel="category tag">Linux</a>&nbsp;<strong>|</strong>&nbsp;<a href="http://202.112.85.88/?p=168#comments">No Comments &raquo;</a></p>
<h2>find 实例</h2>
<p>
<small>四月 18th, 2006</small></p>
<p><span>　　要在/usr/linux中查找所有的*.h，并在这些文件中查找&ldquo;SYSCALL_VECTOR"，最后打印出所有包含"SYSCALL_VECTOR"的文件名，有以下几种方法实现<br />find /usr/linux -name "*.h" | xargs -n50 grep SYSCALL_VECTOR<br />grep SYSCALL_VECTOR /usr/linux/*.h | cut -d&rsquo;:&rsquo; -f1 | uniq &gt; filename<br />find /usr/linux -name "*.h" -exec grep "SYSCALL_VECTOR" {} \; -print</span></p>
<p><span>　　我用find / -name filename| rm -rf，不成功，请问为什么不成功？<br />find / -name filename -exec rm -rf {} \;<br />find . -name filename |rm -rf试一下{} 表示你找出来的结果。<br />\; 则相当于&ldquo;宪法&rdquo;，没什么说头，就是这么规定的，在 -exec 后面需要一个表示该命令终结的的符号。可以在 man find 中找到答案。<br />要让rm识别find的结果，如下：<br />find / -name filename |xargs rm -rf<br />之所以find . -name filename |rm -rf不通过，是因为rm命令不接受从标准输入传过来的指令<br />查找含特定字符串的文件<br />例如查找当前目录下含有"the string you want find&hellip;"字符串的文件：<br />$find . -type f -exec grep &ldquo;the string you want find&hellip;&rdquo; {} ; -print</span></p>
<p><span>　　从根目录开始查tmpfile，一旦查到马上删除<br />find / -name "tmpfile" -exec rm {} \;</span></p>
<p><span>　　find 的perm问题<br />请问一下以下命令什么意思？关键是那个数字前的-，其他都还知道<br />find -name ".*" -perm -007<br />我知道<br />find -name ".*" -perm 755<br />这个是用来查找权限位为755的隐藏文件<br />噢，对了还有，我上边的命令都省略了find的pathname参数 find默认是查找当前工作目录的吗？<br />如果我用 -ok 替代 -exec, 那么还需要加上 {} \; 吗？<br />这个已经清楚，仍然需要，因为 -ok 只是 -exec 的提示模式，它只是多了一个确认操作的步骤,刚才没有读懂那几句E文的意思 呵呵 不好意思<br />-007是指查找所有用户都可读、写、执行的文件，要小心呀~~~<br />解释解释？<br />find -name ".*" -perm -007 和 find -name ".*" -perm 777 有区别吗？<br />-007是怎么来得呢？<br />不过有一个问题<br />我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？</span></p>
<p><span>下面引用由explover在 2002/10/01 06:15am 发表的内容：<br />-007是指查找所有用户都可读、写、执行的文件，要小心呀~~~<br />-007是查找含其它用户(不同组,非属主)可读,写,执行的文件.并不一定要同组可读写,-是指最少权限为007.<br />下面引用由一颗小白菜在 2002/10/01 10:16am 发表的内容：<br />OK了， 呵呵<br />不过有一个问题<br />我用 find . -perm -100 会列出当前目录 . , 这是为什么呢？<br />这种方法不会准确的找出目录的. -100是指权限至少是属主可运行.<br />在unix系统下,你可以拥有对目录文件的执行权你才可以进入一个目录.这便是目录文件被列出的原因.<br />find . -perm -001 -print找到往往是目录文件.<br />我的意思当然不是使用这种方法来找目录，只不过不明白其中的 -100 意义了<br />那以此类推，是不是 -010是指权限至少是owner同组可执行的吗？也就是说其实这里的010和-是分开的，-表示一个至少的意思，而且010才是真正用来描述权限位的？<br />这样子就明白了 谢谢你噢</span></p>
<p><span>　　将find出来的东西拷到另一个地方?<br />find *.c -exec cp &lsquo;{}&rsquo; /tmp &lsquo;;&rsquo;<br />如果有特殊文件，可以用cpio，也可以用这样的语法：<br />find dir -name filename -print | cpio -pdv newdir</span></p>
<p><span>　　找出磁盘中某个大小范围内的文件<br />比如要查找磁盘中大于3M的文件：<br />find . -size +3000k -exec ls -ld {} ;</span></p>
<p><span>　　如何用find查找某一天更改的文件？<br />可以使用这一行命令来实现：<br />A=`find ~ -print` | ls -l &ndash;full-time $A 2&gt;/dev/null | grep "Jun 27" | grep 1998</span></p>
<p><span>　　使用find 命令查找某个时间段的shell怎么写。比如11点到12点的。thanks<br />创建一个脚本judgetime，内容如下：<br />ls -l $*|awk &lsquo;{split($8,hour,":");if((hour[1]&gt;23 || hour[1] &lt; 1)&amp;&amp;hour[1]&lt;24)print}&rsquo;<br />到要查找的目录下，运行<br />find ./ -name "*" -exec judgetime {} \;<br />注意时间格式为２４小时制。<br />thank you ，如果我要精确到分钟呢<br />touch -t 04241112 starttemp #精确到12分钟<br />touch -t 04241220 endtemp #截止到12点20<br />find [dir] -newer starttemp -a ! -newer endtemp -exec ls -l {} \;<br />ｎｅｗｅｒ？<br />那昨天１２：１０文件如何呢？<br />每天执行的时候，用当天的日期和时间戳替换一下不就行了吗？<br />我不知道他是不是把所有的11：00~12：00的都找出来，是不是只执行一次还是每天都执行？<br />这种情况俺猜想是自己的东西放在哪忘了，只记得当时是深夜了。<br />有道理！<br />不愧是斑竹！<br />不光知道怎么解决问题，还知道在什么情况下出现这类问题，佩服佩服！<br />问题又出现了。创建这个文件的时候。本来应该是时间的一栏现在写上了2002，而不是12：00.<br />等到12：00过了吧！</span></p>
<p><span>　　删除指定日期的文件<br />find ./ -name 文件名 -exec rm -f {} \;<br />例：删除当前30天内没用过的文件,用如下命令：<br />find / -atime +30 -exec rm -f {} \;<br />我自己试着写了一小段SHELL,也用ll ,grep, rm 几个命令，用起来还差强人意。<br />对过滤出来的文件名列表中用了一个FOR语句，再执行rm 。现在我想把这段SHELL 扩展一下让它每天定时运行将 n 天前的文件删掉，有没有人能给我一些提示，谢谢！<br />还有个问题，对于前面那位朋友提到的"find / -atime +30 -exec rm -f {} \;<br />"方法，我很早就试过几次，不过好像都不太对，参数 -atime n 是查找n天前被访问过的文件，我不明白的是这里的时间参照点是什么，以及这个n天是怎么计算的。<br />问 题二、对于"ll |cut -f 1" 这个命令我是不是用错了，我只想取出 ll 中列出的文件名，但用cut -f 命令做不到 ，我只好换用 ll |cut -c 59- 这种方式得到我要的文件名，but it&rsquo;s a pool idear ！我也试过用awk ，好像也不对，看看大家可不可以给我一些小小的提醒，TKS SO MUCH<br />问题三、如何改变 I结点 的日期格式 我现在的系统显示的格式是：<br />-rw-r&mdash;&ndash; 1 msahz01 users 2253 2002年2月 2日 poheader.i<br />我想把这换成<br />-rw-rw-rw- 1 house users 2193 Apr 19 2001 hkdisp.p<br />如何才能做到这点？<br />awk 应该可以<br />ll | awk &lsquo;{print $9}&rsquo;<br />删除多少天之前的文件<br />find /yourpath -mtime +31 -exec rm {} \;<br />find /yourpath -mtime +366 -exec rm {} \;</span></p>
<p><span>find中, -ctime, -mtime及其-atime有何区别</span></p>
<p><span>请问 -ctime 和 -mtime 有什么关系 ?<br />如果父目录的 ctime 改变, 那它下面的文件的 ctime 就会自动都改了吗 ?<br />-ctime 和 -mtime ,-atime 这些信息是存在哪儿呢 ?</span></p>
<p><span>我用 -mtime -1 找到了新建或改的文件.<br />但怎样才能找到一天内 mv 来的文件呢( 它们的时间是原有的时间,早于一天 ) ?</span></p>
<p><span>用-newer选项啊。<br />你可以先touch一个你想要的时间的文件如下：<br />$ touch -t 08190800 test<br />$ ls -l test<br />-rw-r&ndash;r&ndash; 1 dba other 0 Aug 19 08:00 test<br />然后<br />$ find . -newer test -print<br />.<br />./.sh_history<br />$ ls -l .sh_history<br />-rw&mdash;&mdash;- 1 dba other 154 Aug 20 17:39 .sh_history</span></p>
<p><span>用touch可以写出你想要的任何时间的文件，然后用-newer ,! -newer选项即可成功。</span></p>
<p><span>1.ctime含inode信息修改的时间.mtime只指文件内容建立或修改的时间.<br />2 不会.<br />3.这些信息应该是存在文件系统的超级块里.</span></p>
<p><span>我查了书 -ctime 是指 inode 的改变(或称文件的状态改变).<br />请问 inode 存了哪些信息 ?<br />做了些小测试,-mtime 改, -ctime 一定也改.<br />改文件名, -ctime 也会改.<br />谁能回答 i-node 存了哪些东西 ?</span></p>
<p><span>vi /usr/include/sys/inode.h</span></p>
<p><span>班主,我不能 access /usr/include/sys/inode.h .<br />摘书如下:<br />Directories contain directory entries. Each entry contains a file or subdirectory name and an index node reference number (i-node number). To increase speed and enhance use of disk space, the data in a file is stored at various locations in the computer&rsquo;s memory. The i-node contains the addresses used to locate all the scattered blocks of data associated with a file. The i-node also records other information about the file including time of modification and access, access modes, number of links, file owner, and file type.<br />可我发现 -atime 改了, -ctime 还没改. why ?<br />( 我先 cat 一个 ASCII 文件,再用 -atime -1 有它用 -ctime -1 居然没有它.)<br />着岂不跟 inode 信息改变, ctime 就改矛盾吗?</span></p>
<p><span>我不同意你贴出来的那段文章,正如我提到的那样,atime,ctime,mtime是放到超级块里,在sco unix下是一种叫stat的结构.(stat_32),不同的系统文件系统可能不同.<br />sco 下inode的结构如下:</span></p>
<p><span>typedef struct inode<br />{<br />struct inode *i_forw; /* inode hash chain */<br />struct inode *i_back; /* &lsquo;&rsquo; */<br />struct inode *av_forw; /* freelist chain */<br />struct inode *av_back; /* &lsquo;&rsquo; */<br />int *i_fsptr; /* "typeless" pointer to fs dependent */<br />ino32_t i_number; /* i number, 1-to-1 with dev address */<br />ushort i_ftype; /* file type = IFDIR, IFREG, etc. */<br />short i_fstyp; /* File system type */<br />off_t i_size; /* size of file */<br />ushort i_uid; /* owner */<br />ushort i_gid; /* group of owner */<br />ushort i_flag;<br />ushort i_want; /* i_flag extension to avoid MP races */<br />ushort i_count; /* reference count */<br />short i_nlink; /* directory entries */<br />dev_t i_rdev; /* Raw device number */<br />#define i_namtype i_rdev /* i_ftype==IFNAM subtype */<br />dev_t i_dev; /* device where inode resides */<br />struct mount *i_mton;/* ptr to mount table entry that */<br />/* this directory is mounted on */<br />struct region *i_rp; /* ptr to shared region if any */<br />struct stdata *i_sp; /* ptr to associated stream */<br />struct iisem *isem; /* ptr to XENIX semaphores */<br />struct iisd *isd; /* ptr to XENIX shared data */<br />} i_un;<br />#define i_mnton i_un.i_mton /* i_ftype==IFDIR IMOUNT */<br />#define i_rptr i_un.i_rp /* i_ftype==IFREG || i_ftype==IFBLK */<br />#define i_sptr i_un.i_sp /* i_ftype==IFCHR || i_ftype==IFIFO */<br />#define i_sem i_un.isem /* i_ftype==IFNAM &amp;&amp; i_namtype==IFSEM */<br />#define i_sd i_un.isd /* i_ftype==IFNAM &amp;&amp; i_namtype==IFSHD */</span></p>
<p><span>struct fstypsw *i_fstypp; /* ptr to file system switch FSPTR */<br />long *i_filocks; /* pointer to filock (structure) list */<br />unsigned long i_mappages; /* number of pages currently cached */<br />unsigned long i_vcode; /* read-ahead block save (NFS) */<br />short i_wcnt; /* write open count or ITEXT count */<br />struct lockb i_cilock; /* tas to synchronize i_flag changes */<br />ushort i_rdlocks; /* count of non-exclusive lockers */<br />} inode_t;</span></p>
<p><span>所以,访问一个文件不能改变inode信息.<br />使用chown, chgrp, chmod命令可以很好的比较mtime和ctime<br />chown改变一个文件的属主,用ctime可以找到,用mtime便找不到.<br />试试看.</span></p>
<p><span>多谢斑竹! 我是在 Solaris 上面试的.我是对 -ctime 不明白.<br />试的结果如下:<br />修改文件,-mtime 改了, -ctime 也会改.<br />访问文件,-atime 改了, -ctime 没变.<br />chown, chgrp, chmod,mv, 都会使 -ctime 改变,但不影响 -atime 和 -mtime.<br />touch 可以改 -mtime and/or -atime,但 touch -a 只改访问时间时,-ctime也改了.<br />touch -m 改修改时间时,-ctime当然也改了.<br />好象还有别的很多东西可以令 -ctime 改变, 搞不清楚.<br />有什么方法可以显示 -mtime,atime,ctime 吗?<br />可以用 -ctime 来实现对目录的增量文件进行备份或 transfer 吗 ?<br />多谢!</span></p>
<p><span>没有什么工具显示,(可能是俺不知道)<br />把下面程序里的st_mtime换成st_ctime,或st_atime便可以得到你要的了.<br />#include<br />int<br />main (int argc, char **argv)<br />{<br />struct stat buf;<br />char date[80];<br />char fname[80];<br />printf("Enter filename (with full path) to check mtime : ");<br />scanf("%s",fname);<br />stat(fname, &amp;buf);<br />printf ("mtime (in sec) of %s = %ld\n", fname, buf.st_mtime);<br />strcpy(date, ctime((time_t *)&amp;(buf.st_mtime)));<br />printf ("mtime (in date) of %s = %s\n", fname, date);<br />}</span></p>
<p><span>至于文件备份,有什么不可以的么?</span></p>
<p><span>mtime ls -l 最近修改文件内容的时间<br />atime ls -lu 最近访问文件的时间<br />ctime ls -li 最近文件有所改变的状态 ,如文件修改,属性\属主 改变 ,节点 ,链接变化等 ,应该是不拘泥只是时间前后的改变</span></p>
<p><span>俺看了ls的帮助,以为只是按ctime或atime排序,显示的时间还是mtime.</span></p>
<p><span>仔细比较了一下,ayhan说的是对的.谢谢ayhan.</span></p>
<p><span>多谢 ahyan 提示 ! 我在 Solaris 上试过如下:<br />mtime 用 ls -l 看到<br />atime 用 ls -lu 看到<br />ctime 用 ls -lc 看到. (ls -li 只有 inode number)<br />摘书如下:<br />-c Uses time of last modification of the i-node (file<br />created, mode changed, and so forth) for sorting (-t)<br />or printing (-l or -n).<br />-u Uses time of last access instead of last modification<br />for sorting (with the -t option) or printing (with the<br />-l option).<br />-i For each file, prints the i-node number in the first<br />column of the report.</span></p>]]></description></item><item><title>l2tp+openswan</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/openswan.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:58:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/openswan.html</guid><description><![CDATA[<p><strong>1.&nbsp;配置</strong></p>
<p>Processor&nbsp;Types&nbsp;and&nbsp;Features&nbsp;--&gt;&nbsp;<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Processor&nbsp;Family</span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择Pentium&nbsp;4（根据实际情况，选最高的。老处理器没办法）</span></p>
<p><strong>下面的&nbsp;High&nbsp;Memory&nbsp;Support&nbsp;内存上限&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择&nbsp;64GB，</strong>这样底下会多出一个隐藏选项：</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PAE&nbsp;Support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>该选项会自动被选上</p>
<p>再进入Paravirtualized&nbsp;Guest&nbsp;Support，会出来一个隐藏选项</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Xen&nbsp;Guest&nbsp;Support&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>（=&nbsp;=）&nbsp;选中！</p>
<p>&nbsp;</p>
<p><strong>这样编译出来的内核，既可以当Dom0，也可以当DomU。内核会自动适应。</strong></p>
<p>最后看一下其他的选项&nbsp;把跟AMD处理器相关的就先拿掉吧</p>
<p>&nbsp;</p>
<p>make&nbsp;dep&nbsp;&amp;&amp;&nbsp;make&nbsp;clean&nbsp;&amp;&amp;&nbsp;make&nbsp;bzImage&nbsp;&amp;&amp;&nbsp;make&nbsp;modules&nbsp;&amp;&amp;&nbsp;make&nbsp;modules_install&nbsp;&amp;&amp;&nbsp;make&nbsp;install</p>
<p>&nbsp;</p>
<p>#########################################################################<br />#&nbsp;REQUIREMENTS<br />#########################################################################<br /><br />A&nbsp;recent&nbsp;Linux&nbsp;distribution&nbsp;based&nbsp;on&nbsp;either&nbsp;Kernel&nbsp;2.4.x,&nbsp;or&nbsp;2.6.x&nbsp;are&nbsp;<br />the&nbsp;currently&nbsp;supported&nbsp;platforms.<br /><br />Most&nbsp;recent&nbsp;distributions&nbsp;have&nbsp;package&nbsp;support&nbsp;for&nbsp;openswan.&nbsp;&nbsp;Unless<br />a&nbsp;source&nbsp;based&nbsp;build&nbsp;is&nbsp;truly&nbsp;needed,&nbsp;&nbsp;it&nbsp;is&nbsp;often&nbsp;best&nbsp;to&nbsp;use&nbsp;the&nbsp;pre-built<br />distributions&nbsp;packaged&nbsp;version.<br /><br />There&nbsp;are&nbsp;a&nbsp;few&nbsp;packages&nbsp;required&nbsp;for&nbsp;Openswan&nbsp;to&nbsp;compile&nbsp;from&nbsp;source:<br /><br />1.&nbsp;The&nbsp;GNU&nbsp;Math&nbsp;Precision&nbsp;Library:<br /><br />&nbsp;&nbsp;&nbsp;Debian&nbsp;package&nbsp;names:&nbsp;libgmp3,&nbsp;libgmp3-dev<br />&nbsp;&nbsp;&nbsp;Rpm&nbsp;package&nbsp;names:&nbsp;&nbsp;&nbsp;&nbsp;gmp,&nbsp;gmp-devel<br /><br />2.&nbsp;awk,&nbsp;flex&nbsp;and&nbsp;bison<br /><br />&nbsp;&nbsp;&nbsp;Debian&nbsp;package&nbsp;names:&nbsp;gawk/mawk,&nbsp;flex,&nbsp;bison<br />&nbsp;&nbsp;&nbsp;Rpm&nbsp;package&nbsp;names:&nbsp;&nbsp;&nbsp;&nbsp;????<br /><br />3.&nbsp;iproute2,&nbsp;iptables,&nbsp;sed,&nbsp;awk,&nbsp;bash,&nbsp;cut&nbsp;and&nbsp;possible&nbsp;other&nbsp;tools<br />&nbsp;&nbsp;&nbsp;are&nbsp;required&nbsp;at&nbsp;runtime.<br /><br />&nbsp;&nbsp;&nbsp;Debian&nbsp;package&nbsp;names:&nbsp;iproute,&nbsp;iptables,&nbsp;the&nbsp;rest&nbsp;are&nbsp;usually&nbsp;there<br />&nbsp;&nbsp;&nbsp;Rpm&nbsp;package&nbsp;names:&nbsp;&nbsp;&nbsp;&nbsp;????<br /><br />&nbsp;&nbsp;&nbsp;perl&nbsp;is&nbsp;also&nbsp;required&nbsp;for&nbsp;"ipsec&nbsp;verify".</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>The&nbsp;most&nbsp;important&nbsp;is:</p>
<p><a href="http://pptpclient.sourceforge.net/howto-debian.phtml#configure_by_hand" target="_blank">http://pptpclient.sourceforge.net/howto-debian.phtml#configure_by_hand</a></p>
<p>&nbsp;</p>
<p>openswan+++xl2tpd+++pptp-linux</p>
<p>--------------------------------------------------------------------------------------------------------------------------</p>
<p>/etc/ppp/chap-secrets</p>
<p>--------------------------------------------------------------------------------------------------------------------------</p>
<p>#&nbsp;Secrets&nbsp;for&nbsp;authentication&nbsp;using&nbsp;CHAP<br />#&nbsp;client&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;&nbsp;secret&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP&nbsp;addresses<br />"suma"&nbsp;l2tpd&nbsp;"suma"&nbsp;x.x.x.x<br />suma&nbsp;l2tpd&nbsp;suma&nbsp;*<br />suma&nbsp;l2tpd&nbsp;suma&nbsp;x.x.x.x<br />suma&nbsp;*&nbsp;suma&nbsp;*<br />"suma"&nbsp;*&nbsp;"suma"&nbsp;*<br />suma&nbsp;l2tpd&nbsp;suma&nbsp;192.168.7.1<br />suma&nbsp;*&nbsp;suma&nbsp;192.168.7.1<br />---------------------------------------------------------------------------------------------------------------------------</p>
<p>/etc/ipsec.conf</p>
<p>&nbsp;</p>
<p>conn&nbsp;L2TP-PSK-NAT<br />&nbsp;&nbsp;&nbsp;&nbsp;rightsubnet=vhost:%priv<br />&nbsp;&nbsp;&nbsp;&nbsp;also=L2TP-PSK-noNAT<br /><br />conn&nbsp;L2TP-PSK-noNAT<br />&nbsp;&nbsp;&nbsp;&nbsp;authby=secret<br />&nbsp;&nbsp;&nbsp;&nbsp;pfs=no<br />&nbsp;&nbsp;&nbsp;&nbsp;auto=add<br />&nbsp;&nbsp;&nbsp;&nbsp;keyingtries=3<br />&nbsp;&nbsp;&nbsp;&nbsp;rekey=no<br />&nbsp;&nbsp;&nbsp;&nbsp;ikelifetime=8h<br />&nbsp;&nbsp;&nbsp;&nbsp;keylife=1h<br />&nbsp;&nbsp;&nbsp;&nbsp;type=transport<br />&nbsp;&nbsp;&nbsp;&nbsp;left=x.x.x.x<br />&nbsp;&nbsp;&nbsp;&nbsp;leftprotoport=17/1701<br />&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;the&nbsp;remote&nbsp;user<br />&nbsp;&nbsp;&nbsp;&nbsp;right=%any<br />&nbsp;&nbsp;&nbsp;&nbsp;rightprotoport=17/%any<br />&nbsp;&nbsp;&nbsp;&nbsp;rightsubnet=vhost:%priv,%no</p>
<p>---------------------------------------------------------------------------------------------------------------------------</p>
<p>/etc/ipsec.secrets</p>
<p>&nbsp;</p>
<p>x.x.x.x&nbsp;%any:&nbsp;PSK&nbsp;"suma"</p>
<p>---------------------------------------------------------------------------------------------------------------------------</p>
<p>/etc/ppp/options</p>
<p>&nbsp;</p>
<p>require-mschap-v2<br />ipcp-accept-local<br />ipcp-accept-remote<br />ms-dns&nbsp;8.8.4.4<br />ms-dns&nbsp;8.8.8.8<br />noccp<br />auth<br />crtscts<br />idle&nbsp;1800<br />mtu&nbsp;1410<br />mru&nbsp;1410<br />nodefaultroute<br />debug<br />lock<br />proxyarp<br />connect-delay&nbsp;5000</p>
<p>---------------------------------------------------------------------------------------------------------------------------</p>
<p>/etc/xl2tpd/xl2tpd.conf</p>
<p>&nbsp;</p>
<p>[global]<br />listen-addr&nbsp;=&nbsp;x.x.x.x<br />ipsec&nbsp;saref=no<br /><br />[lns&nbsp;default]<br />ip&nbsp;range&nbsp;=&nbsp;192.168.7.128-192.168.7.254<br />local&nbsp;ip=192.168.7.1<br /><br />require&nbsp;chap&nbsp;=&nbsp;yes<br />refuse&nbsp;pap&nbsp;=&nbsp;yes<br />require&nbsp;authentication&nbsp;=&nbsp;yes<br />name&nbsp;=&nbsp;LinuxVPNserver<br />ppp&nbsp;debug&nbsp;=&nbsp;yes<br />pppoptfile&nbsp;=&nbsp;/etc/ppp/options<br />length&nbsp;bit&nbsp;=&nbsp;yes</p>
<p>---------------------------------------------------------------------------------------------------------------------------</p>
<p>jiaoben.sh</p>
<p>&nbsp;</p>
<p>route&nbsp;add&nbsp;-net&nbsp;&nbsp;192.168.3.0&nbsp;netmask&nbsp;255.255.255.0&nbsp;&nbsp;gw&nbsp;192.168.3.1&nbsp;device&nbsp;ppp0<br /><br />iptables&nbsp;--table&nbsp;nat&nbsp;--append&nbsp;POSTROUTING&nbsp;--jump&nbsp;MASQUERADE<br />&nbsp;echo&nbsp;1&nbsp;&gt;&nbsp;/proc/sys/net/ipv4/ip_forward<br />&nbsp;sysctl&nbsp;-p<br />&nbsp;for&nbsp;each&nbsp;in&nbsp;/proc/sys/net/ipv4/conf/*<br />&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;0&nbsp;&gt;&nbsp;$each/accept_redirects<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;0&nbsp;&gt;&nbsp;$each/send_redirects<br />&nbsp;done<br />&nbsp;service&nbsp;ipsec&nbsp;restart</p>
<p>---------------------------------------------------------------------------------------------------------------------------</p>]]></description></item><item><title>值-结果参数</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/sockaddr_in.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:54:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/sockaddr_in.html</guid><description><![CDATA[<p><strong>值-结果参数</strong>(socket编程中一到七的struct&nbsp;sockaddr_in的长度参数)<br /><br />1.概念：当函数参数是从内核到进程时，函数被调用时参数大小是一个值，它告诉内核该参数的结构大小避免内核写操作越界，函数返回时，参数的结构大小又是一个结果，它告诉进程内核写进数据的多少，这种参数叫做<strong>值-结果参数</strong>。<br /><br />2.例子：八个socket编程中涉及的函数中，总是通过指针来传递指向结构的指针。同时结构的长度也作为参数来传递，但是其传递的方法取决于结构的传递方向：是从内核到进程还是从进程到内核。详细如下：<br />1&gt;.参数从进程到内核：<br />bind、connect从进程到内核传递参数，它明确知道要拷贝多少以及拷贝的数据。因此一般传递一个长度，例如：<br />struct&nbsp;sockaddr_in&nbsp;addr;<br />memset(&amp;inAddr,&nbsp;0,&nbsp;sizeof(inAddr));<br />addr.sin_addr.s_addr=inet_addr(INADDR_ANY);<br />addr.sin_family=AF_INET;<br />addr.sin_port=htons(PORT);<br /><br />//..........<br /><br />connect(&nbsp;sockfd,&nbsp;(struct&nbsp;sockaddr*)&amp;addr,&nbsp;sizeof(addr)&nbsp;);<br /><br />2&gt;.参数从内核到进程：<br />accept、getsockname、getpeername，函数被调用时结构大小是一个值，它告诉内核该结构的大小避免内核写操作越界，函数返回时，结构大小又是一个结果，它告诉进程内核写进数据的多少，这种参数叫做<strong>值-结果参数</strong>。例如：<br />struct&nbsp;sockaddr_in&nbsp;addr;<br /><br />//..........<br /><br />socklen_t&nbsp;len&nbsp;=&nbsp;sizeof(addr);<br /><br />getpeername(&nbsp;sockfd,&nbsp;(struct&nbsp;sockaddr*)&amp;addr,&nbsp;&amp;len&nbsp;);<br /><br />[Remark]<br />sendto是从进程到内核传递参数的。<br />recvfrom是从内核到进程传递参数的。</p>]]></description></item><item><title>正则表达式</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/vim.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:52:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/vim.html</guid><description><![CDATA[<p>Vim中的正则表达式功能很强大，如果能自由运用，则可以完成很多难以想象的操作。<br />如果你比较熟悉Perl的正规表达式，可以直接参照<br /><a href="http://www.idv2.com/vimwiki/index.php?%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F#perldiff" target="_blank">与Perl正则表达式的区别</a><br />一节。<br />使用正则表达式的命令<br />使用正则表达式的命令最常见的就是 <strong>/</strong> （搜索）命令。其格式如下：<br />/正则表达式<br />另一个很有用的命令就是 <strong>:s</strong>（替换）命令，将第一个//之间的正则表达式替换成第二个//之间的字符串。<br />:s/正则表达式/替换字符串/选项<br />在学习正则表达式时可以利用 <strong>/</strong> 命令来练习。<br />元字符<br />元字符是具有特殊意义的字符。使用元字符可以表达<strong>任意字符</strong>、<strong>行首</strong>、<strong>行尾</strong>、<strong>某几个字符</strong>等意义。<br /><strong>元字符一览</strong><br />元字符<br />说明<br /><strong>.</strong><br />匹配任意一个字符<br /><strong>[abc]</strong><br />匹配方括号中的任意一个字符。可以使用-表示字符范围，<br />如<strong>[a-z0-9]</strong>匹配小写字母和阿拉伯数字。<br /><strong>[^abc]</strong><br />在方括号内开头使用<strong>^</strong>符号，表示匹配除方括号中字符之外的任意字符。<br /><strong>\d</strong><br />匹配阿拉伯数字，等同于<strong>[0-9]</strong>。<br /><strong>\D</strong><br />匹配阿拉伯数字之外的任意字符，等同于<strong>[^0-9]</strong>。<br /><strong>\x</strong><br />匹配十六进制数字，等同于<strong>[0-9A-Fa-f]</strong>。<br /><strong>\X</strong><br />匹配十六进制数字，等同于<strong>[^0-9A-Fa-f]</strong>。<br /><strong>\w</strong><br />匹配单词字母，等同于<strong>[0-9A-Za-z_]</strong>。<br /><strong>\W</strong><br />匹配单词字母之外的任意字符，等同于<strong>[^0-9A-Za-z_]</strong>。<br /><strong>\t</strong><br />匹配字符。<br /><strong>\s</strong><br />匹配空白字符，等同于<strong>[ \t]</strong>。<br /><strong>\S</strong><br />匹配非空白字符，等同于<strong>[^ \t]</strong>。<br />另外，如果要查找字符 *、.、/等，则需要在前面用 <strong>\</strong> 符号，表示这不是元字符，而只是普通字符而已。<br />元字符<br />说明<br /><strong>\*</strong><br />匹配 * 字符。<br /><strong>\.</strong><br />匹配 . 字符。<br /><strong>\/</strong><br />匹配 / 字符。<br /><strong>\\</strong><br />匹配 \ 字符。<br /><strong>\[</strong><br />匹配 [ 字符。<br />表示数量的元字符<br />元字符<br />说明<br /><strong>*</strong><br />匹配0-任意个<br /><strong>\+</strong><br />匹配1-任意个<br /><strong>\?</strong><br />匹配0-1个<br /><strong>\{n,m}</strong><br />匹配n-m个<br /><strong>\{n}</strong><br />匹配n个<br /><strong>\{n,}</strong><br />匹配n-任意个<br /><strong>\{,m}</strong><br />匹配0-m个<br />表示位置的符号<br />元字符<br />说明<br /><strong>$</strong><br />匹配行尾<br /><strong>^</strong><br />匹配行首<br /><strong>\<br />匹配单词词首<br /><strong>\&gt;</strong><br />匹配单词词尾<br /><strong>使用例</strong><br />/char\s\+[A-Za-z_]\w*;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;" 查找所有以char开头，之后是一个以上的空白，<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 最后是一个标识符和分号<br />/\d\d:\d\d:\d\d&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 查找如 17:37:01 格式的时间字符串<br />:g/^\s*$/d&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;" 删除只有空白的行<br />:s/\/4/g&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 将所有的four替换成4，但是fourteen中的four不替换<br />替换变量<br />在正规表达式中使用 <strong>\(</strong> 和 <strong>\)</strong> 符号括起正规表达式，即可在后面使用<strong>\1</strong>、<strong>\2</strong>等变量来访问 <strong>\(</strong> 和 <strong>\)</strong> 中的内容。<br /><strong>使用例</strong><br />/\(a\+\)[^a]\+\1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 查找开头和结尾处a的个数相同的字符串，<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 如 aabbbaa，aaacccaaa，但是不匹配 abbbaa<br />:s/\(http:\/\/[-a-z\._~\+%\/]\+\)/\1/&nbsp; &nbsp;" 将URL替换为http://url的格式<br />:s/\(\w\+\)\s\+\(\w\+\)/\2\t\1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; " 将 data1 data2 修改为 data2 data1<br />函数式<br />在替换命令 <strong>s///</strong> 中可以使用函数表达式来书写替换内容，格式为<br />:s/替换字符串/\=函数式<br />在函数式中可以使用 submatch(1)、submatch(2) 等来引用 <strong>\1</strong>、<strong>\2</strong> 等的内容，而submatch(0)可以引用匹配的整个内容。<br /><strong>使用例</strong><br />:%s/\/\=line(".")&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;" 将各行的 id 字符串替换为行号<br />:%s/^\/\=(line(".")-10) .".". submatch(1)&nbsp; &nbsp; " 将每行开头的单词替换为 (行号-10).单词 的格式，<br />&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;" 如第11行的 word 替换成 1. word<br />与Perl正则表达式的区别<br /><strong>元字符的区别</strong><br />Vim语法<br />Perl语法<br />含义<br />\+<br />+<br />1-任意个<br />\?<br />?<br />0-1个<br />\{n,m}<br />{n,m}<br />n-m个<br />\(和\)<br />(和)<br />分组</strong></p>]]></description></item><item><title>Linux的load average的含义</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/loadaverage.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:50:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/loadaverage.html</guid><description><![CDATA[<p>下面文章中的&nbsp; &nbsp;&nbsp; &nbsp;&ldquo;&nbsp;&nbsp;数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以CPU的数目，结果高于5的时候就表明系统在超负荷运转了。&rdquo;&nbsp; &nbsp;</p>
<p><br />具体是什么意思， 如果是cpu为8颗（双核，4核不知道如何算），目前load average 为： 20.22，20.03，18.99 应该不算超负荷运作了 ？======================================================<br />$ uptime<br />11:12:26 up 3:44, 4 users, load average: 0.38, 0.31, 0.19<br />上面的输出，load average后面分别是1分钟、5分钟、15分钟的负载情况。数据是每隔5秒钟检查一次活跃的进程数，然后根据这个数值算出来的。如果这个数除以CPU的数目，结果高于5的时候就表明系统在超负荷运转了。其算法(摘自Linux 2.4的内核代码)如下：<br /><br />文件: include/linux/sched.h:<br /><br />#define FSHIFT 11 /* nr of bits of precision */<br />#define FIXED_1 (1&lt;&lt;FSHIFT) /* 1.0 as fixed-point */<br />#define LOAD_FREQ (5*HZ) /* 5 sec intervals */<br />#define EXP_1 1884 /* 1/exp(5sec/1min) as fixed-point, 2048/pow(exp(1), 5.0/60) */<br />#define EXP_5 2014 /* 1/exp(5sec/5min), 2048/pow(exp(1), 5.0/300) */<br />#define EXP_15 2037 /* 1/exp(5sec/15min), 2048/pow(exp(1), 5.0/900) */<br /><br />#define CALC_LOAD(load,exp,n) \<br />load *= exp; \<br />load += n*(FIXED_1-exp); \<br />load &gt;&gt;= FSHIFT;<br /><br />/**********************************************************/<br /><br />文件: kernel/timer.c:<br />unsigned long avenrun[3];<br /><br />static inline void calc_load(unsigned long ticks)<br />{<br />unsigned long active_tasks; /* fixed-point */<br />static int count = LOAD_FREQ;<br /><br />count -= ticks;<br />if (count &lt; 0) {<br />count += LOAD_FREQ;<br />active_tasks = count_active_tasks();<br />CALC_LOAD(avenrun[0], EXP_1, active_tasks);<br />CALC_LOAD(avenrun[1], EXP_5, active_tasks);<br />CALC_LOAD(avenrun[2], EXP_15, active_tasks);<br />}<br />}<br /><br />/**********************************************************/<br /><br />文件: fs/proc/proc_misc.c:<br /><br />#define LOAD_INT(x) ((x) &gt;&gt; FSHIFT)<br />#define LOAD_FRAC(x) LOAD_INT(((x) &amp; (FIXED_1-1)) * 100)<br /><br />static int loadavg_read_proc(char *page, char **start, off_t off,<br />int count, int *eof, void *data)<br />{<br />int a, b, c;<br />int len;<br /><br />a = avenrun[0] + (FIXED_1/200);<br />b = avenrun[1] + (FIXED_1/200);<br />c = avenrun[2] + (FIXED_1/200);<br />len = sprintf(page,"%d.%02d %d.%02d %d.%02d %ld/%d %d\n",<br />LOAD_INT(a), LOAD_FRAC(a),<br />LOAD_INT(b), LOAD_FRAC(b),<br />LOAD_INT(c), LOAD_FRAC(c),<br />nr_running(), nr_threads, last_pid);<br />return proc_calc_metrics(page, start, off, count, eof, len);<br />}&nbsp;======================================================&nbsp;系统平均负载被定义为在特定时间间隔内运行队列中的平均进程树。如果一个进程满足以下条件则其就会位于运行队列中：<br />　　- 它没有在等待I/O操作的结果<br />　　- 它没有主动进入等待状态(也就是没有调用'wait')<br />　　- 没有被停止(例如：等待终止)<br /><br />下面这个是算法,数学不好,看的不太懂,资料上是这么说的\<br /><br />load average怎么计算？<br /><br />&nbsp; &nbsp;为 了使内核可以高效计算load average，采用了fixed-point arithmetic。fixed-point arithmetic是一种非常快速的模拟浮点运算的方法，特别是在没有FPU（float point unit）部件的处理器上，非常有用。 <br /><br />计算公式：load(t) = load(t-1) e^(-5/60) + n (1 - e^(-5/60))，迭代计算，其中n为run-queue length。 <br /><br /><strong>为什么采用这个计算公式呢？ </strong><br /><br />由Exponential Smoothing方程有，Y(t)＝ Y(t-1) + a*[X(t) - Y(t-1)],whereX(t) is the input raw data, Y(t - 1) is the value due to the previoussmoothing iteration and Y(t) is the new smoothed value.<br /><br />令a＝1-b，b为e^(-5/60)，就可以得到load average的计算公式 <br /><br />采用此公式的好处：局部的load抖动不会对load average造成重大影响，使其平滑。</p>]]></description></item><item><title>tcpdump抓取TCP/IP数据包分析</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/tcpdump.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:47:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/tcpdump.html</guid><description><![CDATA[<p>一、 tcpdump使用<br /><br />1、首先看下MAN手册<br /><br />TCPDUMP(8)<br /><br />NAME<br />tcpdump - dump traffic on a network<br /><br />SYNOPSIS<br />tcpdump [ -AdDeflLnNOpqRStuUvxX ] [ -c count ]<br />[ -C file_size ] [ -F file ]<br />[ -i interface ] [ -m module ] [ -M secret ]<br />[ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]<br />[ -W filecount ]<br />[ -E spi@ipaddr algo:secret,... ]<br />[ -y datalinktype ] [ -Z user ]<br />[ expression ]<br /><br />选项：<br /><br />-A 以ASCII码显示消息包<br /><br />-c 指定包个数<br /><br />-C 配合-w，当写入文件时，先检查文件大小是否已经超过1M，若超过，生成新文件，文件名为指定文件名加后缀1。<br /><br />-d 将匹配信息包的代码以人们能够理解的汇编格式给出<br /><br />-dd 将匹配信息包的代码以c语言程序段的格式给出<br /><br />-ddd 将匹配信息包的代码以十进制的形式给出。<br /><br />-D 列出可以抓包的所有网络接口<br /><br />-e 显示链路层内容<br /><br />-f 外部的IP以数字方式显示<br /><br />-i 指定网络接口<br /><br />-l 使标准输出变为缓冲行形式<br /><br />-n IP，端口用数字方式显示<br /><br />-t 　　 在输出的每一行不打印时间戳；<br />-v 　 　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；<br />-vv 　 输出详细的报文信息；<br />-c 　　 在收到指定的包的数目后，tcpdump就会停止；<br />-F 　　 从指定的文件中读取表达式,忽略其它的表达式；<br />-i 　　 指定监听的网络接口；<br />-r 　　 从指定的文件中读取包(这些包一般通过-w选项产生)；<br />-w 　　直接将包写入文件中，并不分析和打印出来；<br />-T 　　 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；）<br /><br />-x 让十六进制显示包内容<br /><br />2、过滤<br /><br />（1）指定接口(-i)<br /><br />如：tcpdump -i eth0<br /><br />（2）指定IP地址(host)，可以辅加and , or ，!等逻辑符，以及src，dest等表示方向。<br /><br />如：tcpdump host 192.168.1.23 捕获192.168.1.23发出或者收到的包<br /><br />tcpdump -A host 192.168.1.90 and \( 192.168.1.104 or 192.168.1.105 \) 捕获192.168.1.23与192.168.1.104或者192.168.1.105之间往来的包<br /><br />tcpdump host ! 192.168.1.23 捕获除192.168.1.23以外所有主机的包<br /><br />tcpdump -A src 192.168.1.90 and dst 192.168.1.104 指定从90发往104的包<br /><br />（3）指定端口(port)<br /><br />如：tcpdump port 80 指定捕获80端口的包<br /><br />（4）指定协议( 协议包括：ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp and udp)<br /><br />如：tcpdump tcp 指定捕获TCP包<br /><br />（5）其它(gateway, broadcast, less, greater)<br /><br />如：tcpdump broadcast 所有广播包<br /><br />二、三次握手过程分析<br /><br />用netstat -an | grep LISTEN看一下，当前主机正在监听的端口，使用另一台机telnet过来，不输入任何内容，进行抓包。<br /><br />我们这里以6000为例<br /><br />tcpdump port 6000 -c 3 -n<br /><br />内容如下：<br /><br />21:07:17.790296 IP 192.168.1.104.2511 &gt; 192.168.1.90.6000: S 3359422806:3359422806(0) win 64240 &lt;mss1460,nop,nop,sackOK&gt;<br />21:07:17.790317 IP 192.168.1.90.6000 &gt; 192.168.1.104.2511: S 3675079922:3675079922(0) ack 3359422807 win5840 &lt;mss 1460,nop,nop,sackOK&gt;<br />21:07:17.790675 IP 192.168.1.104.2511 &gt; 192.168.1.90.6000: . ack 1 win 64240<br /><br />我们来对第一个包进行分析：<br /><br />21:07:17（时间）.<br /><br />790296（ID号）<br /><br />IP (协议)<br /><br />192.168.1.104.2511 &gt; 192.168.1.90.6000: （源IP，端口，目的IP，端口）中间&gt;表示方向<br /><br />S (表示为SYN包，即发起连接包<br /><br />紧急指针&mdash; URG<br />确认序号有效&mdash;ACK<br />接收方应该尽快将这个报文段交给应用层&mdash;PSH<br />重建连接&mdash;RST<br />同步序号用来发起一个连接&mdash;SYN<br />发端完成发送任务&mdash;IN<br />)<br /><br />3359422806:3359422806(0) （IP包序号，相对序号为0）<br /><br />win 64240 （数据窗口大小，告诉对方本机接收窗口大小，windows下默认为64240，可通过setsockopt动态修改，同样可以通过修改注册表项（HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters的 TCPWindowSize)来更改默认值）<br /><br />&lt;mss1460,nop,nop,sackOK&gt; 对应TCP包头中的选项字段<br /><br />MSS: Maxitum Segment Size 最大分段大小，MSS表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。如果一方不接收来自另一方的MSS值，则MSS就定为默认的536字节。<br /><br />以上三个包正好是TCP连接的三次握手过程:<br /><br />（1） A主机发送序号为3359422806的SYN包到B，同时带有自身的WIN和MSS大小。<br /><br />（2） B主机收到后，发送SYN+ACK的返回包到A，也带自身的WIN和MSS大小，3675079922，同时为为上一个包的应答包3359422807。<br /><br />（3） A主机返回ACK，包序号为1(相对序号，如果需要看绝对序号，可以在tcpdump命令中加-S)<br /><br /><br /></p>
<p><br /><br />我们在tcpdump命令中加-x选项，后可得到如下内容：<br /><br />22:07:13.436638 IP 192.168.1.104.2799 &gt; 192.168.1.90.6000: S 3480877812:3480877812(0) win 64240 &lt;mss 1460,nop,nop,sackOK&gt;<br />0x0000: 4500 0030 b195 4000 8006 c51f c0a8 0168<br />0x0010: c0a8 015a 0aef 1770 cf79 faf4 0000 0000<br />0x0020: 7002 faf0 174e 0000 0204 05b4 0101 0402<br />22:07:13.436675 IP 192.168.1.90.6000 &gt; 192.168.1.104.2799: S 4226616929:4226616929(0) ack 3480877813 win 5840 &lt;mss 1460,nop,nop,sackOK&gt;<br />0x0000: 4500 0030 0000 4000 4006 b6b5 c0a8 015a<br />0x0010: c0a8 0168 1770 0aef fbed 0e61 cf79 faf5<br />0x0020: 7012 16d0 f10e 0000 0204 05b4 0101 0402<br />22:07:13.437019 IP 192.168.1.104.2799 &gt; 192.168.1.90.6000: . ack 1 win 64240<br />0x0000: 4500 0028 b196 4000 8006 c526 c0a8 0168<br />0x0010: c0a8 015a 0aef 1770 cf79 faf5 fbed 0e62<br />0x0020: 5010 faf0 39b2 0000<br /><br />还是一样，我们对第一个包进行分析，第一个包为SYN包，应该为一个空包，即只包括IP头和TCP头。<br />IP包头</p>
<p><img src="http://hiphotos.baidu.com/guozinong/pic/item/d7db4ef382025aaf94433578fbedab64024f1a5e.jpg" alt="" /><br />4 － IP版本号 IPV4<br />5 － IP包头长度 5个32bit （32bit也就是4字节）<br />00 － TOS (000 0000 0)前三个BIT优先权，现已忽略；4 bit的TOS分别代表:最小时延、最大吞吐量、最高可靠性和最小费用， 均为0表示一般服务；最后1BIT未用。<br />0030 －总长度，48个字节。<br />b195 －包唯一标识。<br />4000 －标志字段，和片偏移，用于分片<br />80 － TTL(128)<br />06 － 协议 TCP</p>
<p>注: 其他协议代号</p>
<p><img src="http://hiphotos.baidu.com/guozinong/pic/item/41d88411c8fcc3cec31574809245d688d63f20f2.jpg" alt="" width="758" height="209" /><br /><img src="http://hiphotos.baidu.com/guozinong/pic/item/a78c90375982b2b774af857731adcbef77099b98.jpg" alt="" width="758" height="121" /><br /><br />c51f － 表头校验码<br />c0a8 0168 － SRC IP，源IP，可以inet_ntoa转换成点号分隔的IP。<br />c0a8 015a － DST IP，目的IP。</p>
<p><br />TCP包头：</p>
<p><img src="http://hiphotos.baidu.com/guozinong/pic/item/0f3fad519822720e78bf5e497bcb0a46f31fab5f.jpg" alt="" /><br /><br />0aef －源端口，十进制为2799<br />1770 －目的端口，十进制为6000<br />cf79 faf4 包序号，十进制为217554863<br />0000 0000 确认序号，0，未设置ACK，确认序号无效<br />7002 －TCP包头长度，标志位。（0111 000000 000010）前4bitTCP长度7个32BIT（注：由于options字段长度不固定，所以需要确认整个TCP数据包的大小），中间6bit保留，后6bit为标志位（URG, ACK，PSH， RST， SYN， FIN），可以看出设置了倒数第二位，SYN位。</p>
<p><img src="http://hiphotos.baidu.com/guozinong/pic/item/04c046f70ad162d9ab7eddaf11dfa9ec8b13cd38.jpg" alt="" width="758" height="148" /><img src="http://hiphotos.baidu.com/guozinong/pic/item/d66a31f731adcbefd1abc1b5acaf2edda2cc9f35.jpg" alt="" width="758" height="259" /></p>
<p>注：比较常见的是ACK，SYN，FIN<br />faf0 － 窗口大小，十进制为64240<br />174e － 校验和，覆盖了整个的 T C P报文段: T C P首部和T C P数据<br />0000 － 紧急指针， 只有当URG标志置1时紧急指针才有效<br />0204 05b4 0101 0402 － 选项字段，8个字节 </p>]]></description></item><item><title>strace,ltrace linux下跟踪进程调用的命令</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/strace.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:43:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/strace.html</guid><description><![CDATA[<p>本工具可以用来做大多数排除,比如mount一个NFS，很慢，找不出原因，我们可以使用strace命令来跟中mount这个经常所有的调用过程。<br /><br /><br />strace 命令是一种强大的工具，它能够显示所有由用户空间程序发出的系统调用。<br />　　strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。<br />　　下面记录几个常用 option . <br />　　1 -f -F选项告诉strace同时跟踪fork和vfork出来的进程<br />　　2 -o xxx.txt 输出到某个文件。<br />　　3 -e execve 只记录 execve 这类系统调用 <br />　　&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />　　进程无法启动，软件运行速度突然变慢，程序的"SegmentFault"等等都是让每个Unix系统用户头痛的问题，<br />　　本文通过三个实际案例演示如何使用truss、strace和ltrace这三个常用的调试工具来快速诊断软件的"疑难杂症"。 <br />　　<br />　　<br />　　truss和strace用来跟踪一个进程的系统调用或信号产生的情况，而 ltrace用来跟踪进程调用库函数的情况。truss是早期为System V R4开发的调试程序，包括Aix、FreeBSD在内的大部分Unix系统都自带了这个工具；<br />　　而strace最初是为SunOS系统编写的，ltrace最早出现在GNU/DebianLinux中。<br />　　这两个工具现在也已被移植到了大部分Unix系统中，大多数Linux发行版都自带了strace和ltrace，而FreeBSD也可通过Ports安装它们。<br />　　<br />　　你不仅可以从命令行调试一个新开始的程序，也可以把truss、strace或ltrace绑定到一个已有的PID上来调试一个正在运行的程序。三个调试工具的基本使用方法大体相同，下面仅介绍三者共有，而且是最常用的三个命令行参数：<br />　　<br />　　-f ：除了跟踪当前进程外，还跟踪其子进程。<br />　　-o file ：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。<br />　　-p pid ：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。<br />　　<br />　　 使用上述三个参数基本上就可以完成大多数调试任务了，下面举几个命令行例子：<br />　　truss -o ls.truss ls -al： 跟踪ls -al的运行，将输出信息写到文件/tmp/ls.truss中。<br />　　strace -f -o vim.strace vim： 跟踪vim及其子进程的运行，将输出信息写到文件vim.strace。<br />　　ltrace -p 234： 跟踪一个pid为234的已经在运行的进程。<br />　　<br />　　 三个调试工具的输出结果格式也很相似，以strace为例：<br />　　<br />　　brk(0) = 0&times;8062aa8<br />　　brk(0&times;8063000) = 0&times;8063000<br />　　mmap2(NULL, 4096, PROT_READ, MAP_PRIVATE, 3, 0&times;92f) = 0&times;40016000<br />　　<br />　　每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 truss、strace和ltrace的工作原理大同小异，都是使用ptrace系统调用跟踪调试运行中的进程，详细原理不在本文讨论范围内，有兴趣可以参考它们的源代码。 <br />　　举两个实例演示如何利用这三个调试工具诊断软件的"疑难杂症"：<br />　　<br />　　案例一：运行clint出现Segment Fault错误<br />　　<br />　　操作系统：FreeBSD-5.2.1-release<br />　　clint是一个C++静态源代码分析工具，通过Ports安装好之后，运行：<br />　　<br />　　# clint foo.cpp<br />　　Segmentation fault (core dumped)<br />　　 在Unix系统中遇见"Segmentation Fault"就像在MS Windows中弹出"非法操作"对话框一样令人讨厌。OK，我们用truss给clint"把把脉"：<br />　　<br />　　# truss -f -o clint.truss clint<br />　　Segmentation fault (core dumped)<br />　　# tail clint.truss<br />　　 739: read(0&times;6,0&times;806f000,0&times;1000) = 4096 (0&times;1000)<br />　　 739: fstat(6,0xbfbfe4d0) = 0 (0&times;0)<br />　　 739: fcntl(0&times;6,0&times;3,0&times;0) = 4 (0&times;4)<br />　　 739: fcntl(0&times;6,0&times;4,0&times;0) = 0 (0&times;0)<br />　　 739: close(6) = 0 (0&times;0)<br />　　 739: stat("/root/.clint/plugins",0xbfbfe680) ERR#2 'No such file or directory'<br />　　SIGNAL 11<br />　　SIGNAL 11<br />　　Process stopped because of: 16<br />　　process exit, rval = 139<br />　　我们用truss跟踪clint的系统调用执行情况，并把结果输出到文件clint.truss，然后用tail查看最后几行。<br />　 　注意看clint执行的最后一条系统调用（倒数第五行）：stat("/root/.clint/plugins",0xbfbfe680) ERR#2 'No such file or directory'，问题就出在这里：clint找不到目录"/root/.clint/plugins"，从而引发了段错误。怎样解决？很简单： mkdir -p /root/.clint/plugins，不过这次运行clint还是会"Segmentation Fault"9。继续用truss跟踪，发现clint还需要这个目录"/root/.clint/plugins/python"，建好这个目录后 clint终于能够正常运行了。 <br />　　<br />　　案例二：vim启动速度明显变慢<br />　　<br />　　操作系统：FreeBSD-5.2.1-release<br />　 　vim版本为6.2.154，从命令行运行vim后，要等待近半分钟才能进入编辑界面，而且没有任何错误输出。仔细检查了.vimrc和所有的vim脚 本都没有错误配置，在网上也找不到类似问题的解决办法，难不成要hacking source code？没有必要，用truss就能找到问题所在：<br />　　<br />　　# truss -f -D -o vim.truss vim<br />　　<br />　　这里-D参数的作用是：在每行输出前加上相对时间戳，即每执行一条系统调用所耗费的时间。我们只要关注哪些系统调用耗费的时间比较长就可以了，用less仔细查看输出文件vim.truss，很快就找到了疑点：<br />　　<br />　　735: 0.000021511 socket(0&times;2,0&times;1,0&times;0) = 4 (0&times;4)<br />　　735: 0.000014248 setsockopt(0&times;4,0&times;6,0&times;1,0xbfbfe3c8,0&times;4) = 0 (0&times;0)<br />　　735: 0.000013688 setsockopt(0&times;4,0xffff,0&times;8,0xbfbfe2ec,0&times;4) = 0 (0&times;0)<br />　　735: 0.000203657 connect(0&times;4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 'Connection refused'<br />　　735: 0.000017042 close(4) = 0 (0&times;0)<br />　　735: 1.009366553 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0&times;0)<br />　　735: 0.000019556 socket(0&times;2,0&times;1,0&times;0) = 4 (0&times;4)<br />　　735: 0.000013409 setsockopt(0&times;4,0&times;6,0&times;1,0xbfbfe3c8,0&times;4) = 0 (0&times;0)<br />　　735: 0.000013130 setsockopt(0&times;4,0xffff,0&times;8,0xbfbfe2ec,0&times;4) = 0 (0&times;0)<br />　　735: 0.000272102 connect(0&times;4,{ AF_INET 10.57.18.27:6000 },16) ERR#61 'Connection refused'<br />　　735: 0.000015924 close(4) = 0 (0&times;0)<br />　　735: 1.009338338 nanosleep(0xbfbfe468,0xbfbfe460) = 0 (0&times;0)<br />　　<br />　 　vim试图连接10.57.18.27这台主机的6000端口（第四行的connect（）），连接失败后，睡眠一秒钟继续重试（第6行的 nanosleep（））。以上片断循环出现了十几次，每次都要耗费一秒多钟的时间，这就是vim明显变慢的原因。可是，你肯定会纳闷："vim怎么会无 缘无故连接其它计算机的6000端口呢？"。问得好，那么请你回想一下6000是什么服务的端口？没错，就是X Server。看来vim是要把输出定向到一个远程X Server，那么Shell中肯定定义了DISPLAY变量，查看.cshrc，果然有这么一行：setenv DISPLAY ${REMOTEHOST}:0，把它注释掉，再重新登录，问题就解决了。<br />　　<br />　　<br />　　案例三：用调试工具掌握软件的工作原理<br />　　<br />　　操作系统：Red Hat Linux 9.0<br />　 　用调试工具实时跟踪软件的运行情况不仅是诊断软件"疑难杂症"的有效的手段，也可帮助我们理清软件的"脉络"，即快速掌握软件的运行流程和工作原理，不 失为一种学习源代码的辅助方法。下面这个案例展现了如何使用strace通过跟踪别的软件来"触发灵感"，从而解决软件开发中的难题的。<br />　　大家都知道，在进程内打开一个文件，都有唯一一个文件描述符（fd：file descriptor）与这个文件对应。而本人在开发一个软件过程中遇到这样一个问题：<br />　 　已知一个fd，如何获取这个fd所对应文件的完整路径？不管是Linux、FreeBSD或是其它Unix系统都没有提供这样的API，怎么办呢？我们 换个角度思考：Unix下有没有什么软件可以获取进程打开了哪些文件？如果你经验足够丰富，很容易想到lsof，使用它既可以知道进程打开了哪些文件，也 可以了解一个文件被哪个进程打开。好，我们用一个小程序来试验一下lsof，看它是如何获取进程打开了哪些文件。lsof： 显示进程打开的文件。<br />　　<br />　　/* testlsof.c */<br />　　#include #include #include #include #include <br />　　int main(void)<br />　　{<br />　　 open("/tmp/foo", O_CREAT|O_RDONLY); /* 打开文件/tmp/foo */<br />　　 sleep(1200); /* 睡眠1200秒，以便进行后续操作 */<br />　　 return 0;<br />　　}<br />　　<br />　　将testlsof放入后台运行，其pid为3125。命令lsof -p 3125查看进程3125打开了哪些文件，我们用strace跟踪lsof的运行，输出结果保存在lsof.strace中：<br />　　<br />　　# gcc testlsof.c -o testlsof<br />　　# ./testlsof &amp;<br />　　[1] 3125<br />　　# strace -o lsof.strace lsof -p 3125<br />　　<br />　　我们以"/tmp/foo"为关键字搜索输出文件lsof.strace，结果只有一条：<br />　　<br />　　<br />　　# grep '/tmp/foo' lsof.strace<br />　　readlink("/proc/3125/fd/3", "/tmp/foo", 4096) = 8<br />　　<br />　 　原来lsof巧妙的利用了/proc/nnnn/fd/目录（nnnn为pid）：Linux内核会为每一个进程在/proc/建立一个以其pid为名 的目录用来保存进程的相关信息，而其子目录fd保存的是该进程打开的所有文件的fd。目标离我们很近了。好，我们到/proc/3125/fd/看个究 竟：<br />　　<br />　　# cd /proc/3125/fd/<br />　　# ls -l<br />　　total 0<br />　　lrwx&mdash;&mdash; 1 root root 64 Nov 5 09:50 0 -&gt; /dev/pts/0<br />　　lrwx&mdash;&mdash; 1 root root 64 Nov 5 09:50 1 -&gt; /dev/pts/0<br />　　lrwx&mdash;&mdash; 1 root root 64 Nov 5 09:50 2 -&gt; /dev/pts/0<br />　　lr-x&mdash;&mdash; 1 root root 64 Nov 5 09:50 3 -&gt; /tmp/foo<br />　　# readlink /proc/3125/fd/3<br />　　/tmp/foo<br />　　<br />　　答案已经很明显了：/proc/nnnn/fd/目录下的每一个fd文件都是符号链接，而此链接就指向被该进程打开的一个文件。我们只要用readlink()系统调用就可以获取某个fd对应的文件了，代码如下：<br />　　<br />　　<br />　　#include #include #include #include #include #include <br />　　int get_pathname_from_fd(int fd, char pathname[], int n)<br />　　{<br />　　 char buf[1024];<br />　　 pid_t pid;<br />　　 bzero(buf, 1024);<br />　　 pid = getpid();<br />　　 snprintf(buf, 1024, "/proc/%i/fd/%i", pid, fd);<br />　　 return readlink(buf, pathname, n);<br />　　}<br />　　int main(void)<br />　　{<br />　　 int fd;<br />　　 char pathname[4096];<br />　　 bzero(pathname, 4096);<br />　　 fd = open("/tmp/foo", O_CREAT|O_RDONLY);<br />　　 get_pathname_from_fd(fd, pathname, 4096);<br />　　 printf("fd=%d; pathname=%sn", fd, pathname);<br />　　 return 0;<br />　　}<br />　　<br />　 　出于安全方面的考虑，在FreeBSD 5 之后系统默认已经不再自动装载proc文件系统，因此，要想使用truss或strace跟踪程序，你必须手工装载proc文件系统：mount -t procfs proc /proc；或者在/etc/fstab中加上一行：<br />　　<br />　　proc /proc procfs rw 0 0</p>]]></description></item><item><title>nmap使用</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/NMAP.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:35:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/NMAP.html</guid><description><![CDATA[<div id="sina_keyword_ad_area2" class="articalContent  "><span style="line-height: 26px; font-family: Arial;">1) 获取远程主机的端口信息和识别主机操作系统(Get info about remote host ports and OS detection)<strong>nmap -sS -P0 -sV -O &lt;target&gt;</strong>&nbsp;</span>
<p style="margin: 0px; border-width: 0px; padding: 0px;"><span style="line-height: 26px; font-family: Arial;">&lt; target &gt; 可以是独立IP, 一个主机名 或一个子网<br />-sS TCP SYN扫描(也叫半开或隐蔽扫描)<br />-P0 选项允许你关闭ICMP ping<br />-sV 选项启用版本检测<br />-O 表示试图识别远程操作系统<br />其它选项:<br />-A 选项启用OS指纹和版本检测<br />-v 使用两次-v查看细节信息<br />nmap -sS -P0 -A -v &lt; target &gt;</span></p>
<div>
<div>&nbsp;</div>
</div>
2) 获取开放指定端口的服务器列表(Get list of servers with a specific port open)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -sT -p 80 -oG &ndash; 192.168.1.* | grep open</strong><br />改变-p的参数可指定端口，查看nmap主页寻找指定地址范围的不同方式。</p>
3) 获取网络中所有存活的主机：Find all active IP addresses in a network
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -sP 192.168.0.*</strong><br />还有许多其它的选项，这个只是一个简单的例子。<br />另一个选项:<strong><br />nmap -sP 192.168.0.0/24&nbsp;</strong><br />针对特定子网</p>
4)&nbsp;ping一个范围内的IP地址(Ping a range of IP addresses)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -sP 192.168.1.100-254</strong><br />namp接受多种类型的地址符号，多个目录/范围等。</p>
5)寻找一个给定子网中未使用的ip(Find unused IPs on a given subnet)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -T4 -sP 192.168.2.0/24 &amp;&amp; egrep &ldquo;00:00:00:00:00:00&Prime; /proc/net/arp</strong></p>
<strong>6)&nbsp;</strong>扫描本地网络中的conficker病毒(Scan for the Conficker virus on your LAN ect.)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -PN -T4 -p139,445 -n -v &ndash;script=smb-check-vulns &ndash;script-args safe=1 192.168.0.1-254</strong><br />可以把192.168.0.1-256替换成你想要检测的地址。</p>
7) 扫描网络中的非法接入点(Scan Network for Rogue APs.)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -A -p1-85,113,443,8080-8100 -T4 &ndash;min-hostgroup 50 &ndash;max-rtt-timeout 2000 &ndash;initial-rtt-timeout 300 &ndash;max-retries 3 &ndash;host-timeout 20m &ndash;max-scan-delay 1000 -oA wapscan 10.0.0.0/8</strong><br />我使用这个在非常巨大的网络中成功找出多个非法接入点。</p>
8) 在扫描时使用诱骗技术避免引起管理员的注意(Use a decoy while scanning ports to avoid getting caught by the sys admin)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>sudo nmap -sS 192.168.0.10 -D 192.168.0.2</strong></p>
<p style="margin: 0px; border-width: 0px; padding: 0px;">扫描目标设备/计算机(192.168.0.10）的开放端口并设置一个诱骗地址(192.168.0.2)，在目标的安全日志中将会显示诱骗地址而不是你的IP地址。诱骗地址必须是存活的，检查目标主机的安全日志( /var/log/)确定它是否工作。<br />&nbsp;</p>
9) 列出一个子网中的DNS反向记录(List of reverse DNS records for a subnet)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>nmap -R -sL 209.85.229.99/27 | awk &lsquo;{if($3==&rdquo;not&rdquo;)print&rdquo;(&ldquo;$2&Prime;) no PTR&rdquo;;else print$3&Prime; is &ldquo;$2}&rsquo; | grep &lsquo;(&lsquo;</strong><br />这个命令是使用nmap字在子网中查询DNS反向信息。它会生成子网中的ip地址列表和相应的PTR纪录。你可以在CDIR符号中输入子网 (i.e. /24 for a Class C)，如果你需要查询一个特定的DNS服务器，你可以在-sL后边添加&ldquo;&ndash;dns-servers x.x.x.x&rdquo;，一些安装版的namp可能需要sudo，我也希望awk是大多数发行版的标准。<br />&nbsp;</p>
10) 你的网络中有多少Linux和Windows设备？(How Many Linux And Windows Devices Are On Your Network?)
<p style="margin: 0px; border-width: 0px; padding: 0px;"><strong>sudo nmap -F -O 192.168.0.1-255 | grep &ldquo;Running: &rdquo; &gt; /tmp/os; echo &ldquo;$(cat /tmp/os | grep Linux | wc -l) Linux device(s)&rdquo;; echo &ldquo;$(cat /tmp/os | grep Windows | wc -l) Window(s) devices&rdquo;</strong></p>
</div>]]></description></item><item><title>Linux TCP/IP协议栈源码阅读笔记</title><link>http://www.cnblogs.com/isohybrid/archive/2012/11/05/TCPIP.html</link><dc:creator>isohybrid</dc:creator><author>isohybrid</author><pubDate>Sun, 04 Nov 2012 16:14:00 GMT</pubDate><guid>http://www.cnblogs.com/isohybrid/archive/2012/11/05/TCPIP.html</guid><description><![CDATA[<div id="cnblogs_post_body">
<p><span style="font-size: large;">一.linux内核网络栈代码的准备知识</span></p>
<div>&nbsp;</div>
<div><strong>1.</strong> <strong>linux内核ipv4网络部分分层结构</strong>：</div>
<div>&nbsp;</div>
<div><br /><strong>BSD socket层： </strong>这一部分处理BSD socket相关操作，每个socket在内核中以struct socket结构体现。这一部分的文件</div>
<div>&nbsp;</div>
<div>主要有：/net/socket.c /net/protocols.c etc<br /><br /><strong>INET socket层：</strong>BSD socket是个可以用于各种网络协议的接口，而当用于tcp/ip，即建立了AF_INET形式的socket时，</div>
<div>&nbsp;</div>
<div>还需要保留些额外的参数，于是就有了struct sock结构。文件主要</div>
<div>&nbsp;</div>
<div>有：/net/ipv4/protocol.c /net/ipv4/af_inet.c /net/core/sock.c etc<br /><br /><strong>TCP/UDP层：</strong>处理传输层的操作，传输层用struct inet_protocol和struct proto两个结构表示。文件主要</div>
<div>&nbsp;</div>
<div>有：/net/ipv4/udp.c /net/ipv4/datagram.c /net/ipv4/tcp.c /net/ipv4/tcp_input.c /net/ipv4//tcp_output.c /net/ipv4/tcp_minisocks.c /net/ipv4/tcp_output.c&nbsp;/net/ipv4/tcp_timer.c </div>
<div>&nbsp;</div>
<div>etc&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /><strong>IP层：</strong>处理网络层的操作，网络层用struct packet_type结构表示。文件主要有：/net/ipv4/ip_forward.c </div>
<div>ip_fragment.c ip_input.c ip_output.c etc.<br /><br /><strong>数据链路层和驱动程序：</strong>每个网络设备以struct net_device表示，通用的处理在dev.c中，驱动程序都在/driver/net目</div>
<div>&nbsp;</div>
<div>录下。</div>
<div>&nbsp;</div>
<div><strong>2.</strong> <strong>两台主机建立udp通信所走过的函数列表</strong></div>
<div>&nbsp;</div>
<div>^<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs/read_write.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/socket.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock_recvmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/socket.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet_recvmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/af_inet.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;udp_recvmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/udp.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;skb_recv_datagram&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/core/datagram.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------------<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock_queue_rcv_skb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;include/net/sock.h<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;udp_queue_rcv_skb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/udp.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;udp_rcv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/udp.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_local_deliver_finish net/ipv4/ip_input.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_local_deliver&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_input.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_recv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_input.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net_rx_action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/dev.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------------<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netif_rx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/dev.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el3_rx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver/net/3c309.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el3_interrupt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver/net/3c309.c<br /><br />＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝<br /><br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sys_write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs/read_write.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock_writev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/socket.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sock_sendmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/socket.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet_sendmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/af_inet.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;udp_sendmsg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/udp.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_build_xmit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_output.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output_maybe_reroute&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_output.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_output.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ip_finish_output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/ipv4/ip_output.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dev_queue_xmit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;net/dev.c<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--------------------------------------------<br />|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el3_start_xmit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;driver/net/3c309.c<br />V</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>3.</strong> <strong>网络路径图、重要数据结构sk_buffer及路由介绍</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;</strong>linux-net.pdf 第2.1章 第2.3章 第2.4章</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div><strong>4.</strong> <strong>从连接、发送、到接收数据包的过程</strong></div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;linux-net.pdf 第4、5、6章详细阐述</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong><span style="font-size: large;">二.linux的tcp-ip栈代码的详细分析</span></strong></div>
<div>&nbsp;</div>
<div><strong>1.数据结构(msghdr,sk_buff,socket,sock,proto_ops,proto)</strong></div>
<div>&nbsp;</div>
<div>bsd套接字层,操作的对象是socket,数据存放在msghdr这样的数据结构：</div>
<div>&nbsp;</div>
<div>创建socket需要传递family,type,protocol三个参数，创建socket其实就是创建一个socket实例，然后创建一个文件描述符结构，并且互相建立一些关联，即建立互相连接的指针，并且初始化这些对文件的写读操作映射到socket的read，write函数上来。</div>
<div>&nbsp;</div>
<div>同时初始化socket的操作函数（proto_ops结构),如果传入的type参数是STREAM类型，那么就初始化为SOCKET-&gt;ops为inet_stream_ops，如果是DGRAM类型，则SOCKET-ops为inet_dgram_ops。对于inet_stream_ops其实是一个结构体，包含了stream类型的socket操作的一些入口函数，在这些函数里主要做的是对socket进行相关的操作，同时通过调用下面提到的sock中的相关操作完成socket到sock层的传递。比如在inet_stream_ops里有个inet_release的操作，这个操作除了释放socket的类型空间操作外，还通过调用socket连接的sock的close操作，对于stream类型来说，即tcp_close来关闭sock</div>
<div>释放sock。</div>
<div>&nbsp;</div>
<div>创建socket同时还创建sock数据空间，初始化sock,初始化过程主要做的事情是初始化三个队列，receive_queue（接收到的数据包sk_buff链表队列),send_queue(需要发送数据包的sk_buff链表队列),backlog_queue(主要用于tcp中三次握手成功的那些数据包,自己猜的),根据family、type参数，初始化sock的操作，比如对于family为inet类型的，type为stream类型的，sock-&gt;proto初始化为tcp_prot.其中包括stream类型的协议sock操作对应的入口函数。</div>
<div>&nbsp;</div>
<div>在一端对socket进行write的过程中，首先会把要write的字符串缓冲区整理成msghdr的数据结构形式(参见linux内核2.4版源代码分析大全),然后调用sock_sendmsg把msghdr的数据传送至inet层，对于msghdr结构中数据区中的每个数据包，创建sk_buff结构，填充数据，挂至发送队列。一层层往下层协议传递。一下每层协议不再对数据进行拷贝。而是对sk_buff结构进行操作。</div>
<div>&nbsp;</div>
<div>inet套接字及以下层 数据存放在sk_buff这样的数据结构里：</div>
<div>&nbsp;</div>
<div>路由：</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;在linux的路由系统主要保存了三种与路由相关的数据，第一种是在物理上和本机相连接的主机地址信息表，第二种是保存了在网络访问中判断一个网络地址应该走什么路由的数据表；第三种是最新使用过的查询路由地址的缓存地址数据表。</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;1.neighbour结构 &nbsp;neighbour_table{ }是一个包含和本机所连接的所有邻元素的信息的数据结构。该结构中有个元素是neighbour结构的数组，数组的每一个元素都是一个对应于邻机的neighbour结构，系统中由于协议的不同，会有不同的判断邻居的方式，每种都有neighbour_table{}类型的实例，这些实例是通过neighbour_table{}中的指针next串联起来的。在neighbour结构中，包含有与该邻居相连的网络接口设备net_device的指针，网络接口的硬件地址，邻居的硬件地址，包含有neigh_ops{}指针，这些函数指针是直接用来连接传输数据的，包含有queue_xmit(struct * sk_buff)函数入口地址，这个函数可能会调用硬件驱动程序的发送函数。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp; 2.FIB结构 在FIB中保存的是最重要的路由规则,通过对FIB数据的查找和换算，一定能够获得路由一个地址的方法。系统中路由一般采取的手段是：先到路由缓存中查找表项，如果能够找到，直接对应的一项作为路由的规则；如果不能找到，那么就到FIB中根据规则换算传算出来，并且增加一项新的，在路由缓存中将项目添加进去。</div>
<div>&nbsp;&nbsp;&nbsp; 3.route结构（即路由缓存中的结构)</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>数据链路层：</div>
<div>&nbsp;&nbsp; </div>
<div>&nbsp;&nbsp; net_device{}结构，对应于每一个网络接口设备。这个结构中包含很多可以直接获取网卡信息的函数和变量，同时包含很多对于网卡操作的函数，这些直接指向该网卡驱动程序的许多函数入口，包括发送接收数据帧到缓冲区等。当这些完成后，比如数据接收到缓冲区后便由netif_rx(在net/core/dev.c各种设备驱动程序的上层框架程序)把它们组成sk_buff形式挂到系统接收的backlog队列然后交由上层网络协议处理。同样，对于上层协议处理下来的那些sk_buff。便由dev_queue_xmit函数放入网络缓冲区，交给网卡驱动程序的发送程序处理。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp; 在系统中存在一张链表dev_base将系统中所有的net_device{}结构连在一起。对应于内核初始化而言，系统启动时便为每个所有可能支持的网络接口设备申请了一个net_device{}空间并串连起来，然后对每个接点运行检测过程，如果检测成功，则在dev_base链表中保留这个接点，否则删除。对应于模块加载来说，则是调用register_netdev()注册net_device,在这个函数中运行检测过程，如果成功，则加到dev_base链表。否则就返回检测不到信息。删除同理，调用</div>
<div>unregister_netdev。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>2.启动分析</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;2.1 初始化进程</strong> ：start-kernel(main.c)----&gt;do_basic_setup(main.c)----&gt;sock_init(/net/socket.c)----&gt;do_initcalls(main.c)</div>
<div>&nbsp;</div>
<div><strong>void __init sock_init(void)<br /></strong>{<br />&nbsp;int i;</div>
<div>&nbsp;</div>
<div>&nbsp;printk(KERN_INFO "Linux NET4.0 for Linux 2.4/n");<br />&nbsp;printk(KERN_INFO "Based upon Swansea University Computer Society NET3.039/n");</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Initialize all address (protocol) families. 每一项表示的是针对一个地址族的操作集合，例如对于ipv4来说，在net/ipv4/af_inet.c文件中的函数inet_proto_init()就调用sock_register()函数将inet_families_ops初始化到属于IPV4的net_families数组中的一项。<br />&nbsp; */<br />&nbsp; <br />&nbsp;for (i = 0; i &lt; NPROTO; i++) <br />&nbsp;&nbsp;net_families[i] = NULL;&nbsp;&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Initialize sock SLAB cache.初始化对于sock结构预留的内存的slab缓存。<br />&nbsp; */<br />&nbsp; <br />&nbsp;sk_init();</div>
<div>&nbsp;</div>
<div>#ifdef SLAB_SKB<br />&nbsp;/*<br />&nbsp; *&nbsp;Initialize skbuff SLAB cache 初始化对于skbuff结构的slab缓存。以后对于skbuff的申请可以通过函数kmem_cache_alloc()在这个缓存中申请空间。<br />&nbsp; */<br />&nbsp;skb_init();<br />#endif</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Wan router layer. <br />&nbsp; */</div>
<div>&nbsp;</div>
<div>#ifdef CONFIG_WAN_ROUTER&nbsp; <br />&nbsp;wanrouter_init();<br />#endif</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Initialize the protocols module.&nbsp;向系统登记sock文件系统，并且将其安装到系统上来。<br />&nbsp; */</div>
<div>&nbsp;</div>
<div>&nbsp;register_filesystem(&amp;sock_fs_type);<br />&nbsp;sock_mnt = kern_mount(&amp;sock_fs_type);<br />&nbsp;/* The real protocol initialization is performed when<br />&nbsp; *&nbsp; do_initcalls is run.&nbsp; <br />&nbsp; */</div>
<div><br />&nbsp;/*<br />&nbsp; * The netlink device handler may be needed early.<br />&nbsp; */</div>
<div>&nbsp;</div>
<div>#ifdef CONFIG_NET<br />&nbsp;rtnetlink_init();<br />#endif<br />#ifdef CONFIG_NETLINK_DEV<br />&nbsp;init_netlink();<br />#endif<br />#ifdef CONFIG_NETFILTER<br />&nbsp;netfilter_init();<br />#endif</div>
<div>&nbsp;</div>
<div>#ifdef CONFIG_BLUEZ<br />&nbsp;bluez_init();<br />#endif</div>
<div>&nbsp;</div>
<div>/*yfhuang ipsec*/<br />#ifdef CONFIG_IPSEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;pfkey_init();<br />#endif<br />/*yfhuang ipsec*/<br />}</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;2.2 do_initcalls()</strong>&nbsp;中做了其它的初始化，其中包括</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协议初始化，路由初始化，网络接口设备初始化</div>
<div>&nbsp;</div>
<div><strong>(例如inet_init函数以_init开头表示是系统初始化时做，函数结束后跟module_init(inet_init),这是一个宏，在include/linux/init.c中定义，展开为_initcall(inet_init),表示这个函数在do_initcalls被调用了)</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;2.3 协议初始化</strong></div>
<div><strong>此处主要列举inet协议的初始化过程。</strong></div>
<div>&nbsp;</div>
<div>static int __init inet_init(void)<br />{<br />&nbsp;struct sk_buff *dummy_skb;<br />&nbsp;struct inet_protocol *p;<br />&nbsp;struct inet_protosw *q;<br />&nbsp;struct list_head *r;</div>
<div>&nbsp;</div>
<div>&nbsp;printk(KERN_INFO "NET4: Linux TCP/IP 1.0 for NET4.0/n");</div>
<div>&nbsp;</div>
<div>&nbsp;if (sizeof(struct inet_skb_parm) &gt; sizeof(dummy_skb-&gt;cb)) {<br />&nbsp;&nbsp;printk(KERN_CRIT "inet_proto_init: panic/n");<br />&nbsp;&nbsp;return -EINVAL;<br />&nbsp;}</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Tell SOCKET that we are alive...&nbsp;注册socket，告诉socket inet类型的地址族已经准备好了<br />&nbsp; */<br />&nbsp;&nbsp; <br />&nbsp; &nbsp;(void) sock_register(&amp;inet_family_ops);</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Add all the protocols. 包括arp,ip、ICMP、UPD、tcp_v4、tcp、igmp的初始化，主要初始化各种协议对应的inode和socket变量。</div>
<div>&nbsp;</div>
<div>其中arp_init完成系统中路由部分neighbour表的初始化</div>
<div>&nbsp;</div>
<div>ip_init完成ip协议的初始化。在这两个函数中，都通过定义一个packet_type结构的变量将这种数据包对应的协议发送数据、允许发送设备都做初始化。</div>
<div><br />&nbsp; */</div>
<div>&nbsp;</div>
<div>&nbsp;printk(KERN_INFO "IP Protocols: ");<br />&nbsp;for (p = inet_protocol_base; p != NULL;) {<br />&nbsp;&nbsp;struct inet_protocol *tmp = (struct inet_protocol *) p-&gt;next;<br />&nbsp;&nbsp;inet_add_protocol(p);<br />&nbsp;&nbsp;printk("%s%s",p-&gt;name,tmp?", ":"/n");<br />&nbsp;&nbsp;p = tmp;<br />&nbsp;}</div>
<div>&nbsp;</div>
<div>&nbsp;/* Register the socket-side information for inet_create. */<br />&nbsp;for(r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX]; ++r)<br />&nbsp;&nbsp;INIT_LIST_HEAD(r);</div>
<div>&nbsp;</div>
<div>&nbsp;for(q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)<br />&nbsp;&nbsp;inet_register_protosw(q);</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Set the ARP module up&nbsp; <br />&nbsp; */</div>
<div>&nbsp;</div>
<div>&nbsp;arp_init();</div>
<div>&nbsp;</div>
<div>&nbsp; &nbsp;/*<br />&nbsp; &nbsp; *&nbsp;Set the IP module up<br />&nbsp; &nbsp; */</div>
<div>&nbsp;</div>
<div>&nbsp;ip_init();</div>
<div>&nbsp;</div>
<div>&nbsp;tcp_v4_init(&amp;inet_family_ops);</div>
<div>&nbsp;</div>
<div>&nbsp;/* Setup TCP slab cache for open requests. */<br />&nbsp;tcp_init();</div>
<div><br />&nbsp;/*<br />&nbsp; *&nbsp;Set the ICMP layer up<br />&nbsp; */</div>
<div>&nbsp;</div>
<div>&nbsp;icmp_init(&amp;inet_family_ops);</div>
<div>&nbsp;</div>
<div>&nbsp;/* I wish inet_add_protocol had no constructor hook...<br />&nbsp;&nbsp;&nbsp; I had to move IPIP from net/ipv4/protocol.c :-( --ANK<br />&nbsp; */<br />#ifdef CONFIG_NET_IPIP<br />&nbsp;ipip_init();<br />#endif<br />#ifdef CONFIG_NET_IPGRE<br />&nbsp;ipgre_init();<br />#endif</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Initialise the multicast router<br />&nbsp; */<br />#if defined(CONFIG_IP_MROUTE)<br />&nbsp;ip_mr_init();<br />#endif</div>
<div>&nbsp;</div>
<div>&nbsp;/*<br />&nbsp; *&nbsp;Create all the /proc entries.<br />&nbsp; */<br />#ifdef CONFIG_PROC_FS<br />&nbsp;proc_net_create ("raw", 0, raw_get_info);<br />&nbsp;proc_net_create ("netstat", 0, netstat_get_info);<br />&nbsp;proc_net_create ("snmp", 0, snmp_get_info);<br />&nbsp;proc_net_create ("sockstat", 0, afinet_get_info);<br />&nbsp;proc_net_create ("tcp", 0, tcp_get_info);<br />&nbsp;proc_net_create ("udp", 0, udp_get_info);<br />#endif&nbsp;&nbsp;/* CONFIG_PROC_FS */</div>
<div>&nbsp;</div>
<div>&nbsp;ipfrag_init();</div>
<div>&nbsp;</div>
<div>&nbsp;return 0;<br />}&nbsp;&nbsp;&nbsp;</div>
<div>module_init(inet_init);</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;<strong> 2.4 路由初始化(包括neighbour表、FIB表、和路由缓存表的初始化工作)</strong></div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.4.1 rtcache表 ip_rt_init()函数 在net/ipv4/ip_output中调用，net/ipv4/route.c中定义</strong></div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2.4.2 FIB初始化 在ip_rt_init()中调用 在net/ipv4/fib_front.c中定义</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 neigbour表初始化&nbsp;&nbsp;arp_init（）函数中定义&nbsp;</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5 网络接口设备初始化</strong></div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统中网络接口都是由一个dev_base链表进行管理的。通过内核的启动方式也是通过这个链表进行操作的。在系统启动之初，将所有内核能够支持的网络接口都初始化成这个链表中的一个节点，并且每个节点都需要初始化出init函数指针，用来检测网络接口设备。然后，系统遍历整个dev_base链表，对每个节点分别调用init函数指针，如果成功，证明网络接口设备可用，那么这个节点就可以进一步初始化，如果返回失败，那么证明该网络设备不存在或是不可用，只能将该节点删除。启动结束之后，在dev_base中剩下的都是可以用的网络接口设备。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 do_initcalls----&gt;net_dev_init()(net/core/dev.c)------&gt;ethif_probe()(drivers/net/Space.c,在netdevice{}结构的init中调用，这边ethif_probe是以太网卡针对的调用)</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>3.网络设备驱动程序（略)</strong></div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong></div>
<div>&nbsp;</div>
<div><strong>4.网络连接</strong></div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1 连接的建立和关闭</strong></div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tcp连接建立的代码如下:</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server=gethostbyname(SERVER_NAME);</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sockfd=socket(AF_INET,SOCK_STREAM,0);</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address.sin_family=AF_INET；</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address.sin_port=htons(PORT_NUM);</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;address.sin_addr,server-&gt;h_addr,server-&gt;h_length);</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connect(sockfd,&amp;address,sizeof(address));</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接的初始化与建立期间主要发生的事情如下：</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）sys_socket调用：调用socket_creat(),创建出一个满足传入参数family、type、和protocol的socket,调用sock_map_fd()获取一个未被使用的文件描述符，并且申请并初始化对应的file{}结构。</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）sock_creat()：创建socket结构，针对每种不同的family的socket结构的初始化，就需要调用不同的create函数来完成。对应于inet类型的地址来说，在网络协议初始化时调用sock_register()函数中完成注册的定义如下：</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct net_proto_family inet_family_ops={</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PF_INET;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet_create</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};所以inet协议最后会调用inet_create函数。</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）inet_create: 初始化sock的状态设置为SS_UNCONNECTED,申请一个新的sock结构，并且初始化socket的成员ops初始化为inet_stream_ops,而sock的成员prot初始化为tcp_prot。然后调用sock_init_data,将该socket结构的变量sock和sock类型的变量关联起来。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）在系统初始化完毕后便是进行connect的工作，系统调用connect将一个和socket结构关联的文件描述符和一个sockaddr{}结构的地址对应的远程机器相关联，并且调用各个协议自己对应的connect连接函数。对应于tcp类型，则sock-&gt;ops-&gt;connect便为inet_stream_connect。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5）inet_stream_connect: 得到sk,sk=sock-&gt;sk,锁定sk，对自动获取sk的端口号存放在sk-&gt;num中，并且用htons()函数转换存放在sk-&gt;sport中。然后调用sk-&gt;prot-&gt;connect()函数指针，对tcp协议来说就是tcp_v4_connect()函数。然后将sock-&gt;state状态字设置为SS_CONNECTING,等待后面一系列的处理完成之后，就将状态改成SS_CONNECTTED。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6) tcp_v4_connect()：调用函数ip_route_connect()，寻找合适的路由存放在rt中。ip_route_connect找两次，第一次找到下一跳的ip地址，在路由缓存或fib中找到，然后第二次找到下一跳的具体邻居，到neigh_table中找到。然后申请出tcp头的空间存放在buff中。将sk中相关地址数据做一些针对路由的变动，并且初始化一个tcp连接的序列号，调用函数tcp_connect（），初始化tcp头，并设置tcp处理需要的定时器。一次connect（）建立的过程就结束了。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;连接的关闭主要如下：</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）close: 一个socket文件描述符对应的file{}结构中，有一个file_operations{}结构的成员f_ops，它的初始化关闭函数为sock_close函数。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）sock_close：调用函数sock_release(),参数为一个socket{}结构的指针。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）sock_release：调用inet_release，并释放socket的指针和文件空间</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4）inet_release: 调用和该socket对应协议的关闭函数inet_release,如果是tcp协议，那么调用的是tcp_close；最后释放sk。</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2 <strong>数据发送流程图</strong></div>
<div>&nbsp;</div>
<div>&nbsp;<img src="http://blog.csdn.net/images/blog_csdn_net/cz_hyf/send.gif" alt="" usemap="#mymap" border="0" /></div>
<div>&nbsp;</div>
<div>各层主要函数以及位置功能说明：</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)sock_write：初始化msghdr{}结构 net/socket.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)sock_sendmsg:net/socket.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)inet_sendmsg:net/ipv4/af_net.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)tcp_sendmsg：申请sk_buff{}结构的空间，把msghdr{}结构中的数据填入sk_buff空间。net/ipv4/tcp.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5)tcp_send_skb:net/ipv4/tcp_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6)tcp_transmit_skb:net/ipv4/tcp_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7)ip_queue_xmit:net/ipv4/ip_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8)ip_queue_xmit2:net/ipv4/ip_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9)ip_output:net/ipv4/ip_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10)ip_finish_output:net/ipv4/ip_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11)ip_finish_output2:net/ipv4/ip_output.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12)neigh_resolve_output:net/core/neighbour.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13)dev_queue_xmit:net/core/dev.c</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
<div><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3 数据接收流程图</strong></div>
<div><img src="http://blog.csdn.net/images/blog_csdn_net/cz_hyf/receive.gif" alt="" usemap="#mymap" border="0" /></div>
<div>&nbsp;</div>
<div>各层主要函数以及位置功能说明：</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1)sock_read:初始化msghdr{}的结构类型变量msg，并且将需要接收的数据存放的地址传给msg.msg_iov-&gt;iov_base.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; net/socket.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2)sock_recvmsg: 调用函数指针sock-&gt;ops-&gt;recvmsg()完成在INET Socket层的数据接收过程.其中sock-&gt;ops被初始化为inet_stream_ops,其成员recvmsg对应的函数实现为inet_recvmsg()函数. net/socket.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3)sys_recv()/sys_recvfrom():分别对应着面向连接和面向无连接的协议两种情况. net/socket.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4)inet_recvmsg:调用sk-&gt;prot-&gt;recvmsg函数完成数据接收,这个函数对于tcp协议便是tcp_recvmsg net/ipv4/af_net.c</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5)tcp_recvmsg:从网络协议栈接收数据的动作,自上而下的触发动作一直到这个函数为止,出现了一次等待的过程.函数tcp_recvmsg可能会被动地等待在sk的接收数据队列上,也就是说,系统中肯定有其他地方会去修改这个队列使得tcp_recvmsg可以进行下去.入口参数sk是这个网络连接对应的sock{}指针,msg用于存放接收到的数据.接收数据的时候会去遍历接收队列中的数据,找到序列号合适的.</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但读取队列为空时tcp_recvmsg就会调用tcp_v4_do_rcv使用backlog队列填充接收队列.</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6)tcp_v4_rcv:tcp_v4_rcv被ip_local_deliver函数调用,是从IP层协议向INET Socket层提交的"数据到"请求,入口参数skb存放接收到的数据,len是接收的数据的长度,这个函数首先移动skb-&gt;data指针,让它指向tcp头,然后更新tcp层的一些数据统计,然后进行tcp的一些值的校验.再从INET Socket层中已经建立的sock{}结构变量中查找正在等待当前到达数据的哪一项.可能这个sock{}结构已经建立,或者还处于监听端口、等待数据连接的状态。返回的sock结构指针存放在sk中。然后根据其他进程对sk的操作情况,将skb发送到合适的位置.调用如下:</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP包接收器(tcp_v4_rcv)将TCP包投递到目的套接字进行接收处理. 当套接字正被用户锁定,TCP包将暂时排入该套接字的后备队列(sk_add_backlog).这时如果某一用户线程企图锁定该套接字(lock_sock),该线程被排入套接字的后备处理等待队列(sk-&gt;lock.wq).当用户释放上锁的套接字时(release_sock,在tcp_recvmsg中调用),后备队列中的TCP包被立即注入TCP包处理器(tcp_v4_do_rcv)进行处理,然后唤醒等待队列中最先的一个用户来获得其锁定权. 如果套接字未被上锁,当用户正在读取该套接字时, TCP包将被排入套接字的预备队列(tcp_prequeue),将其传递到该用户线程上下文中进行处理.如果添加到sk-&gt;prequeue不成功,便可以添加到 sk-&gt;receive_queue队列中(用户线程可以登记到预备队列,当预备队列中出现第一个包时就唤醒等待线程.)&nbsp;&nbsp; /net/tcp_ipv4.c</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7)ip_rcv、ip_rcv_finish:从以太网接收数据，放到skb里，作ip层的一些数据及选项检查，调用ip_route_input()做路由处理,判断是进行ip转发还是将数据传递到高一层的协议.调用skb-&gt;dst-&gt;input函数指针,这个指针的实现可能有多种情况,如果路由得到的结果说明这个数据包应该转发到其他主机,这里的input便是ip_forward;如果数据包是给本机的,那么input指针初始化为ip_local_deliver函数./net/ipv4/ip_input.c</div>
<div>&nbsp;</div>
<div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8)ip_local_deliver、ip_local_deliver_finish:入口参数skb存放需要传送到上层协议的数据,从ip头中获取是否已经分拆的信息,如果已经分拆,则调用函数ip_defrag将数据包重组。然后通过调用ip_prot-&gt;handler指针调用tcp_v4_rcv(tcp)。ip_prot是inet_protocol结构指针,是用来ip层登记协议的，比如由udp,tcp,icmp等协议。 /net/ipv4/ip_input.c</div>
</div>]]></description></item></channel></rss>